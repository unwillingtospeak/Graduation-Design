import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  init_vue_runtime_esm_bundler,
  inject,
  mergeProps,
  nextTick,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toHandlers,
  useCssVars,
  vModelDynamic,
  vModelText,
  vShow,
  watch,
  watchEffect,
  watchPostEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-GZARLMGK.js";
import {
  isRef,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  reactive,
  ref,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toRefs,
  unref
} from "./chunk-HOHJQXG5.js";
import "./chunk-QOVRSCHT.js";

// node_modules/vuestic-ui/dist/esm/_commonjsHelpers.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

// node_modules/vuestic-ui/dist/esm/vendor.js
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key2) {
  var data = this.__data__, index = assocIndexOf$3(data, key2);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key2) {
  var data = this.__data__, index = assocIndexOf$2(data, key2);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key2) {
  return assocIndexOf$1(this.__data__, key2) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key2, value) {
  var data = this.__data__, index = assocIndexOf(data, key2);
  if (index < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key2) {
  return this.__data__.get(key2);
}
var _stackGet = stackGet$1;
function stackHas$1(key2) {
  return this.__data__.has(key2);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$2(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$2;
var Symbol$4 = _Symbol;
var getRawTag = _getRawTag;
var objectToString$1 = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$8;
function isObject$d(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$d;
var baseGetTag$7 = _baseGetTag;
var isObject$c = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$c(value)) {
    return false;
  }
  var tag = baseGetTag$7(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$b = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$b(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key2) {
  return object == null ? void 0 : object[key2];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object, key2) {
  var value = getValue(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$6 = _root;
var Map$4 = getNative$6(root$6, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function hashGet$1(key2) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key2];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key2) ? data[key2] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashHas$1(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$8.call(data, key2);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key2) {
  var data = map.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key2) {
  var result = getMapData$3(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key2) {
  return getMapData$2(this, key2).get(key2);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key2) {
  return getMapData$1(this, key2).has(key2);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key2, value) {
  var data = getMapData(this, key2), size2 = data.size;
  data.set(key2, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache;
var Map$2 = _Map;
var MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
function assignMergeValue$2(object, key2, value) {
  if (value !== void 0 && !eq$2(object[key2], value) || value === void 0 && !(key2 in object)) {
    baseAssignValue$2(object, key2, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key2 = props[fromRight ? length : ++index];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root$5 = _root;
var Uint8Array$1 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
var isObject$a = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$a(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var getPrototype$3 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var objectProto$8 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
var _isPrototype = isPrototype$3;
var baseCreate = _baseCreate;
var getPrototype$2 = _getPrototype;
var isPrototype$2 = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype$2(object) ? baseCreate(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$2;
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$a;
var baseGetTag$6 = _baseGetTag;
var isObjectLike$9 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$9(value) && baseGetTag$6(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$8 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$8(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$b = Array.isArray;
var isArray_1 = isArray$b;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var isFunction$1 = isFunction_1;
var isLength$2 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$2(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var isArrayLike$3 = isArrayLike_1;
var isObjectLike$7 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$7(value) && isArrayLike$3(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var baseGetTag$5 = _baseGetTag;
var getPrototype$1 = _getPrototype;
var isObjectLike$6 = isObjectLike_1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype;
var objectProto$6 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$6(value) || baseGetTag$5(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
var baseGetTag$4 = _baseGetTag;
var isLength$1 = isLength_1;
var isObjectLike$5 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$2 = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$3 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$5(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$4(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$3 = _baseUnary;
var nodeUtil$3 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
function safeGet$2(object, key2) {
  if (key2 === "constructor" && typeof object[key2] === "function") {
    return;
  }
  if (key2 == "__proto__") {
    return;
  }
  return object[key2];
}
var _safeGet = safeGet$2;
var baseAssignValue$1 = _baseAssignValue;
var eq$1 = eq_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function assignValue$3(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$5.call(object, key2) && eq$1(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue$1(object, key2, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue = _baseAssignValue;
function copyObject$6(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key2 = props[index];
    var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object, key2, newValue);
    } else {
      assignValue$2(object, key2, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var baseTimes = _baseTimes;
var isArguments$3 = isArguments_1;
var isArray$a = isArray_1;
var isBuffer$2 = isBuffer$3.exports;
var isIndex$3 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$a(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$4.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex$3(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key2 in Object(object)) {
      result.push(key2);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$9 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$9(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key2 in object) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$3.call(object, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$5 = _copyObject;
var keysIn$4 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$5(value, keysIn$4(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer$1 = _cloneBuffer.exports;
var cloneTypedArray$1 = _cloneTypedArray;
var copyArray$1 = _copyArray;
var initCloneObject$1 = _initCloneObject;
var isArguments$2 = isArguments_1;
var isArray$9 = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer$1 = isBuffer$3.exports;
var isFunction = isFunction_1;
var isObject$8 = isObject_1;
var isPlainObject$1 = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key2), srcValue = safeGet$1(source, key2), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key2, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$9(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$9(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray$1(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments$2(srcValue)) {
      newValue = objValue;
      if (isArguments$2(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$8(objValue) || isFunction(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key2, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$1 = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$7 = isObject_1;
var keysIn$3 = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key2) {
    stack || (stack = new Stack$1());
    if (isObject$7(srcValue)) {
      baseMergeDeep(object, source, key2, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key2, newValue);
    }
  }, keysIn$3);
}
var _baseMerge = baseMerge$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax$1 = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var identity = identity_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function baseRest$1(func, start) {
  return setToString$1(overRest$1(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike$1 = isArrayLike_1;
var isIndex$2 = _isIndex;
var isObject$6 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$6(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike$1(object) && isIndex$2(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$2.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike = isArrayLike_1;
function keys$3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$4 = _copyObject;
var keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$4(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
var copyObject$3 = _copyObject;
var keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$3(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$2 = _copyObject;
var getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$2(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var arrayPush$2 = _arrayPush;
var getPrototype = _getPrototype;
var getSymbols$1 = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$1(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush;
var isArray$8 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$8(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$1 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$3 = _getNative;
var root$4 = _root;
var DataView$1 = getNative$3(root$4, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$3 = _root;
var Promise$2 = getNative$2(root$3, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$2 = _root;
var Set$2 = getNative$1(root$2, "Set");
var _Set = Set$2;
var getNative = _getNative;
var root$1 = _root;
var WeakMap$2 = getNative(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView;
var Map$1 = _Map;
var Promise$1 = _Promise;
var Set$1 = _Set;
var WeakMap$1 = _WeakMap;
var baseGetTag$3 = _baseGetTag;
var toSource = _toSource;
var mapTag$3 = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap$1);
var getTag$3 = baseGetTag$3;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$3(new Map$1()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set$1 && getTag$3(new Set$1()) != setTag$3 || WeakMap$1 && getTag$3(new WeakMap$1()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag$3(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var getTag$2 = _getTag;
var isObjectLike$4 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$4(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$2 = _baseUnary;
var nodeUtil$2 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$2 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$2;
var getTag$1 = _getTag;
var isObjectLike$3 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$3(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$1 = _baseUnary;
var nodeUtil$1 = _nodeUtil.exports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer = _cloneBuffer.exports;
var copyArray = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject = _initCloneObject;
var isArray$7 = isArray_1;
var isBuffer = isBuffer$3.exports;
var isMap$1 = isMap_1;
var isObject$5 = isObject_1;
var isSet = isSet_1;
var keys = keys_1;
var keysIn = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key2, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key2, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$5(value)) {
    return value;
  }
  var isArr = isArray$7(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key22) {
      result.set(key22, baseClone$2(subValue, bitmask, customizer, key22, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key22) {
    if (props) {
      key22 = subValue;
      subValue = value[key22];
    }
    assignValue$1(result, key22, baseClone$2(subValue, bitmask, customizer, key22, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
var isArray$6 = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString$1 = (val) => typeof val === "string";
var isSymbol$5 = (val) => typeof val === "symbol";
var isObject$4 = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key2) => isString$1(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
var newTracked = (dep) => (dep.n & trackOpBit) > 0;
var targetMap = /* @__PURE__ */ new WeakMap();
var trackOpBit = 1;
var activeEffect;
var ITERATE_KEY = Symbol("");
var MAP_KEY_ITERATE_KEY = Symbol("");
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key2) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray$6(target)) {
    depsMap.forEach((dep, key22) => {
      if (key22 === "length" || key22 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type) {
      case "add":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect of isArray$6(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
var isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key2) => Symbol[key2]).filter(isSymbol$5));
var get = createGetter();
var readonlyGet = createGetter(true);
var arrayInstrumentations = createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key2](...args);
      if (res === -1 || res === false) {
        return arr[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key2, receiver) {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_isShallow") {
      return shallow;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$6(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key2)) {
      return Reflect.get(arrayInstrumentations, key2, receiver);
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol$5(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef2(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key2);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive2(res);
    }
    return res;
  };
}
var set = createSetter();
function createSetter(shallow = false) {
  return function set2(target, key2, value, receiver) {
    let oldValue = target[key2];
    if (isReadonly(oldValue) && isRef2(oldValue) && !isRef2(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$6(target) && isRef2(oldValue) && !isRef2(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$6(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn(target, key2);
    const result = Reflect.set(target, key2, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key2, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key2) {
  const hadKey = hasOwn(target, key2);
  target[key2];
  const result = Reflect.deleteProperty(target, key2);
  if (result && hadKey) {
    trigger(target, "delete", key2, void 0);
  }
  return result;
}
function has(target, key2) {
  const result = Reflect.has(target, key2);
  if (!isSymbol$5(key2) || !builtInSymbols.has(key2)) {
    track(target, "has", key2);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$6(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key2) {
    return true;
  },
  deleteProperty(target, key2) {
    return true;
  }
};
var toShallow = (value) => value;
var getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key2, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key2);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key2)) {
    return wrap(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has$1(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key2);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key2, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  const oldValue = get2.call(target, key2);
  target.set(key2, value);
  if (!hadKey) {
    trigger(target, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key2, value);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  get2 ? get2.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger(target, "delete", key2, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key2) => {
      return callback.call(thisArg, wrap(value), wrap(key2), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get$1(this, key2);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key2) && key2 in target ? instrumentations : target, key2, receiver);
  };
}
var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
var toReactive = (value) => isObject$4(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef2(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function shallowRef2(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef2(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var RefImpl = class {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
};
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key2) {
    return object == null ? void 0 : object[key2];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$2(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var baseGetTag$2 = _baseGetTag;
var isObjectLike$2 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$2(value) && baseGetTag$2(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var Symbol$2 = _Symbol;
var arrayMap$1 = _arrayMap;
var isArray$5 = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$5(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$4(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$4;
var deburrLetter = _deburrLetter;
var toString$3 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
  string = toString$3(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo$1 = "[" + rsComboRange$2 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$2 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$2 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$2 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString$2(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder$2(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$2;
var createCompounder$1 = _createCompounder;
var kebabCase = createCompounder$1(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim;
var isObject$3 = isObject_1;
var isSymbol$2 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN;
  }
  if (isObject$3(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$3(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$2 = isObject_1;
var now = now_1;
var toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$2(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var isArray$4 = isArray_1;
var isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$4(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray$3 = isArray_1;
var isKey = _isKey;
var stringToPath = _stringToPath;
var toString$1 = toString_1;
function castPath$6(value, object) {
  if (isArray$3(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$6;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$5 = _castPath;
var toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$5(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$3(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var assignValue = _assignValue;
var castPath$4 = _castPath;
var isIndex$1 = _isIndex;
var isObject$1 = isObject_1;
var toKey$2 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath$4(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key2 = toKey$2(path[index]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex$1(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath$3 = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet$1(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$3(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key2) {
  return object != null && key2 in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath;
var isArguments$1 = isArguments_1;
var isArray$2 = isArray_1;
var isIndex = _isIndex;
var isLength = isLength_1;
var toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key2 = toKey$1(path[index]);
    if (!(result = object != null && hasFunc(object, key2))) {
      break;
    }
    object = object[key2];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key2, length) && (isArray$2(object) || isArguments$1(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var Symbol$1 = _Symbol;
var isArguments = isArguments_1;
var isArray$1 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var flatten = flatten_1;
var overRest = _overRest;
var setToString = _setToString;
function flatRest$2(func) {
  return setToString(overRest(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick;
var flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var baseGetTag$1 = _baseGetTag;
var isArray = isArray_1;
var isObjectLike$1 = isObjectLike_1;
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike$1(value) && baseGetTag$1(value) == stringTag;
}
var isString_1 = isString;
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
function baseSlice$2(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseGet = _baseGet;
var baseSlice$1 = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice$1(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap = _arrayMap;
var baseClone = _baseClone;
var baseUnset = _baseUnset;
var castPath = _castPath;
var copyObject = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp;
var toNumber = toNumber_1;
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}
var clamp_1 = clamp;
function noop() {
}
var noop_1 = noop;
var debounce = debounce_1;
var isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
var baseSlice = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray = _stringToArray;
var toString = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$1 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$1;
var createCompounder = _createCompounder;
var upperFirst = upperFirst_1;
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
var baseGetTag = _baseGetTag;
var isObjectLike = isObjectLike_1;
var dateTag = "[object Date]";
function baseIsDate$1(value) {
  return isObjectLike(value) && baseGetTag(value) == dateTag;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;

// node_modules/vuestic-ui/dist/esm/src/services/global-config/global-config.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/services/global-config/config-default/index.js
var getComponentsDefaultConfig = () => ({
  VaIcon: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  },
  VaRating: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  }
});
var getComponentsAllDefaultConfig = () => ({});

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/presets/fonts.js
var VuesticIconFonts = [
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/presets/vuestic-aliases.js
var VuesticIconAliases = [
  {
    name: "arrow_back_ios",
    to: "arrow_back_ios"
  },
  {
    name: "arrow_forward_ios",
    to: "arrow_forward_ios"
  },
  {
    name: "first_page",
    to: "first_page"
  },
  {
    name: "last_page",
    to: "last_page"
  },
  {
    name: "chevron_right",
    to: "chevron_right"
  },
  {
    name: "chevron_left",
    to: "chevron_left"
  },
  {
    name: "expand_more",
    to: "expand_more"
  },
  {
    name: "expand_less",
    to: "expand_less"
  },
  {
    name: "arrow_drop_down",
    to: "arrow_drop_down"
  },
  {
    name: "arrow_drop_up",
    to: "arrow_drop_up"
  },
  {
    name: "calendar_today",
    to: "calendar_today"
  },
  {
    name: "delete_outline",
    to: "delete_outline"
  },
  {
    name: "clear",
    to: "clear"
  },
  {
    name: "check",
    to: "check"
  },
  {
    name: "warning",
    to: "warning"
  },
  {
    name: "highlight_off",
    to: "highlight_off"
  },
  {
    name: "close",
    to: "close"
  },
  {
    name: "done",
    to: "done"
  },
  {
    name: "cancel",
    to: "cancel"
  },
  {
    name: "loop",
    to: "loop"
  }
];

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/icon-config-helpers.js
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};

// node_modules/vuestic-ui/dist/esm/src/services/color-config/color-theme-presets.js
var colorsPresets = {
  default: {
    primary: "#2C82E0",
    secondary: "#767C88",
    background: "#f4f8fa",
    success: "#40e583",
    info: "#2c82e0",
    danger: "#DE1041",
    warning: "#FFAC0A",
    gray: "#babfc2",
    dark: "#1B1A1F",
    divider: "#E1E9F8",
    white: "#ffffff",
    black: "#000000",
    focus: "#ffc700"
  }
};

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/utils/global-properties.js
var extractGlobalProperties = (app) => app.config.globalProperties;
var defineGlobalProperty = (app, key2, v2) => {
  const globalProperties = extractGlobalProperties(app);
  globalProperties[key2] = v2;
};
var getGlobalProperty = (app, key2) => {
  return extractGlobalProperties(app)[key2];
};

// node_modules/vuestic-ui/dist/esm/src/services/global-config/global-config.js
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var createGlobalConfig = () => {
  const globalConfig = ref({
    colors: colorsPresets.default,
    icons: createIconsConfig({}),
    components: getComponentsDefaultConfig(),
    componentsAll: getComponentsAllDefaultConfig()
  });
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep_1(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = merge_1(cloneDeep_1(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
function useGlobalConfigSafe() {
  return inject(GLOBAL_CONFIG);
}
function useGlobalConfig() {
  const injected = inject(GLOBAL_CONFIG);
  if (!injected) {
    const vm = getCurrentInstance();
    if (!vm) {
      throw new Error("useGlobalConfig must be called in setup function");
    }
    const config = getGlobalProperty(vm.appContext, "$vaConfig");
    if (!config) {
      throw new Error("Vuestic GlobalConfigPlugin is not registered");
    }
    return config;
  }
  return injected;
}

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/types/index.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/esm/src/services/global-config/plugin/index.js
var GlobalConfigPlugin = defineVuesticPlugin((config) => ({
  install(app) {
    const globalConfig = createGlobalConfig();
    if (config) {
      globalConfig.mergeGlobalConfig(config);
    }
    app.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app, "$vaConfig", globalConfig);
  }
}));

// node_modules/vuestic-ui/dist/esm/src/services/color-config/plugin/create-color-config-plugin.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/utils/ssr-utils.js
var isServer = () => typeof window === "undefined";
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/esm/src/services/color-config/plugin/create-color-config-plugin.js
var setCSSVariable = (name, value, root2) => {
  root2.style.setProperty(`--va-${name}`, value);
};
var createColorConfigPlugin = (app) => {
  const globalConfig = getGlobalProperty(app, "$vaConfig").globalConfig;
  const renderCSSVariables = (colors = globalConfig.value.colors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    return colorNames.map((key2) => `--va-${key2}: ${colors[key2]}`).join(";");
  };
  const updateColors = (newValue) => {
    if (!newValue) {
      return;
    }
    if (isServer()) {
      return;
    }
    const root2 = document.documentElement;
    const colorNames = Object.keys(newValue);
    colorNames.forEach((key2) => {
      setCSSVariable(key2, newValue[key2], root2);
    });
  };
  updateColors(globalConfig.value.colors);
  watch(() => globalConfig.value.colors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return {
    renderCSSVarialbes: renderCSSVariables,
    renderCSSVariables,
    updateColors
  };
};

// node_modules/vuestic-ui/dist/esm/src/services/color-config/plugin/index.js
var ColorConfigPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorConfig", createColorConfigPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/toast.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/services/config-transport/createProxyComponent.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-config/VaConfig.js
init_vue_runtime_esm_bundler();
var LocalConfigKey = Symbol("LocalConfigKey");
var CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject(LocalConfigKey, CONFIGS_DEFAULT);
}
var VaConfig = defineComponent({
  name: "VaConfig",
  props: {
    components: { type: Object, default: () => ({}) }
  },
  setup(props) {
    const { components } = toRefs(props);
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, components.value]);
    provide(LocalConfigKey, nextChain);
    return {};
  },
  render() {
    return this.$slots.default ? this.$slots.default() : null;
  }
});

// node_modules/vuestic-ui/dist/esm/src/services/component-config/component-config.js
init_vue_runtime_esm_bundler();
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var useComponentConfigProps = (component) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  return computed(() => {
    var _a;
    const globalConfigProps = __spreadValues(__spreadValues({}, globalConfig.value.componentsAll), (_a = globalConfig.value.components) == null ? void 0 : _a[component.name]);
    const localConfigProps = localConfig.value.reduce((finalConfig, config) => config[component.name] ? __spreadValues(__spreadValues({}, finalConfig), config[component.name]) : finalConfig, {});
    const props = __spreadValues(__spreadValues({}, globalConfigProps), localConfigProps);
    return props;
  });
};

// node_modules/vuestic-ui/dist/esm/src/services/config-transport/createProxyComponent.js
var createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key2) => {
      const incommingProps = instance.vnode.props || {};
      const originalProp = target[key2];
      const propFromConfig = propsFromConfig.value[key2];
      if (incommingProps[key2] === void 0 && propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
var patchInstanceProps = (instance, props) => {
  instance.props = props;
};
var createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component);
    const props = createPropsWithCustomConfig(instance, propsFromConfig);
    patchInstanceProps(instance, props);
    return (_a = component.setup) == null ? void 0 : _a.call(component, shallowReadonly(props), ctx);
  };
  return new Proxy(component, {
    get(target, key2) {
      if (key2 === "setup") {
        return customSetup;
      }
      return target[key2];
    }
  });
};

// node_modules/vuestic-ui/dist/esm/src/services/config-transport/withConfigTransport.js
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({});
    return createProxyComponent(component);
  }
};

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/VaToast.js
init_vue_runtime_esm_bundler();

// node_modules/colortranslator/dist/esm/index.js
var t;
var e;
var r;
var n;
var i = function() {
  return i = Object.assign || function(t2) {
    for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
      for (var i2 in e2 = arguments[r2])
        Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
    return t2;
  }, i.apply(this, arguments);
};
function o(t2, e2, r2) {
  if (r2 || arguments.length === 2)
    for (var n2, i2 = 0, o2 = e2.length; i2 < o2; i2++)
      !n2 && i2 in e2 || (n2 || (n2 = Array.prototype.slice.call(e2, 0, i2)), n2[i2] = e2[i2]);
  return t2.concat(n2 || Array.prototype.slice.call(e2));
}
!function(t2) {
  t2.HEX = "HEX", t2.RGB = "RGB", t2.RGBA = "RGBA", t2.HSL = "HSL", t2.HSLA = "HSLA", t2.CMYK = "CMYK";
}(t || (t = {})), function(t2) {
  t2.ANALOGOUS = "ANALOGOUS", t2.COMPLEMENTARY = "COMPLEMENTARY", t2.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t2.TRIADIC = "TRIADIC", t2.TETRADIC = "TETRADIC", t2.SQUARE = "SQUARE";
}(e || (e = {})), function(t2) {
  t2.ADDITIVE = "ADDITIVE", t2.SUBTRACTIVE = "SUBTRACTIVE";
}(r || (r = {})), function(t2) {
  t2.black = "#000000", t2.silver = "#C0C0C0", t2.gray = "#808080", t2.white = "#FFFFFF", t2.maroon = "#800000", t2.red = "#FF0000", t2.purple = "#800080", t2.fuchsia = "#FF00FF", t2.green = "#008000", t2.lime = "#00FF00", t2.olive = "#808000", t2.yellow = "#FFFF00", t2.navy = "#000080", t2.blue = "#0000FF", t2.teal = "#008080", t2.aqua = "#00FFFF", t2.orange = "#FFA500", t2.aliceblue = "#F0F8FF", t2.antiquewhite = "#FAEBD7", t2.aquamarine = "#7FFFD4", t2.azure = "#F0FFFF", t2.beige = "#F5F5DC", t2.bisque = "#FFE4C4", t2.blanchedalmond = "#FFEBCD", t2.blueviolet = "#8A2BE2", t2.brown = "#A52A2A", t2.burlywood = "#DEB887", t2.cadetblue = "#5F9EA0", t2.chartreuse = "#7FFF00", t2.chocolate = "#D2691E", t2.coral = "#FF7F50", t2.cornflowerblue = "#6495ED", t2.cornsilk = "#FFF8DC", t2.crimson = "#DC143C", t2.cyan = "#00FFFF", t2.darkblue = "#00008B", t2.darkcyan = "#008B8B", t2.darkgoldenrod = "#B8860B", t2.darkgray = "#A9A9A9", t2.darkgreen = "#006400", t2.darkgrey = "#A9A9A9", t2.darkkhaki = "#BDB76B", t2.darkmagenta = "#8B008B", t2.darkolivegreen = "#556B2F", t2.darkorange = "#FF8C00", t2.darkorchid = "#9932CC", t2.darkred = "#8B0000", t2.darksalmon = "#E9967A", t2.darkseagreen = "#8FBC8F", t2.darkslateblue = "#483D8B", t2.darkslategray = "#2F4F4F", t2.darkslategrey = "#2F4F4F", t2.darkturquoise = "#00CED1", t2.darkviolet = "#9400D3", t2.deeppink = "#FF1493", t2.deepskyblue = "#00BFFF", t2.dimgray = "#696969", t2.dimgrey = "#696969", t2.dodgerblue = "#1E90FF", t2.firebrick = "#B22222", t2.floralwhite = "#FFFAF0", t2.forestgreen = "#228B22", t2.gainsboro = "#DCDCDC", t2.ghostwhite = "#F8F8FF", t2.gold = "#FFD700", t2.goldenrod = "#DAA520", t2.greenyellow = "#ADFF2F", t2.grey = "#808080", t2.honeydew = "#F0FFF0", t2.hotpink = "#FF69B4", t2.indianred = "#CD5C5C", t2.indigo = "#4B0082", t2.ivory = "#FFFFF0", t2.khaki = "#F0E68C", t2.lavender = "#E6E6FA", t2.lavenderblush = "#FFF0F5", t2.lawngreen = "#7CFC00", t2.lemonchiffon = "#FFFACD", t2.lightblue = "#ADD8E6", t2.lightcoral = "#F08080", t2.lightcyan = "#E0FFFF", t2.lightgoldenrodyellow = "#FAFAD2", t2.lightgray = "#D3D3D3", t2.lightgreen = "#90EE90", t2.lightgrey = "#D3D3D3", t2.lightpink = "#FFB6C1", t2.lightsalmon = "#FFA07A", t2.lightseagreen = "#20B2AA", t2.lightskyblue = "#87CEFA", t2.lightslategray = "#778899", t2.lightslategrey = "#778899", t2.lightsteelblue = "#B0C4DE", t2.lightyellow = "#FFFFE0", t2.limegreen = "#32CD32", t2.linen = "#FAF0E6", t2.magenta = "#FF00FF", t2.mediumaquamarine = "#66CDAA", t2.mediumblue = "#0000CD", t2.mediumorchid = "#BA55D3", t2.mediumpurple = "#9370DB", t2.mediumseagreen = "#3CB371", t2.mediumslateblue = "#7B68EE", t2.mediumspringgreen = "#00FA9A", t2.mediumturquoise = "#48D1CC", t2.mediumvioletred = "#C71585", t2.midnightblue = "#191970", t2.mintcream = "#F5FFFA", t2.mistyrose = "#FFE4E1", t2.moccasin = "#FFE4B5", t2.navajowhite = "#FFDEAD", t2.oldlace = "#FDF5E6", t2.olivedrab = "#6B8E23", t2.orangered = "#FF4500", t2.orchid = "#DA70D6", t2.palegoldenrod = "#EEE8AA", t2.palegreen = "#98FB98", t2.paleturquoise = "#AFEEEE", t2.palevioletred = "#DB7093", t2.papayawhip = "#FFEFD5", t2.peachpuff = "#FFDAB9", t2.peru = "#CD853F", t2.pink = "#FFC0CB", t2.plum = "#DDA0DD", t2.powderblue = "#B0E0E6", t2.rosybrown = "#BC8F8F", t2.royalblue = "#4169E1", t2.saddlebrown = "#8B4513", t2.salmon = "#FA8072", t2.sandybrown = "#F4A460", t2.seagreen = "#2E8B57", t2.seashell = "#FFF5EE", t2.sienna = "#A0522D", t2.skyblue = "#87CEEB", t2.slateblue = "#6A5ACD", t2.slategray = "#708090", t2.slategrey = "#708090", t2.snow = "#FFFAFA", t2.springgreen = "#00FF7F", t2.steelblue = "#4682B4", t2.tan = "#D2B48C", t2.thistle = "#D8BFD8", t2.tomato = "#FF6347", t2.turquoise = "#40E0D0", t2.violet = "#EE82EE", t2.wheat = "#F5DEB3", t2.whitesmoke = "#F5F5F5", t2.yellowgreen = "#9ACD32", t2.rebeccapurple = "#663399";
}(n || (n = {}));
var u;
var a;
var s;
var c;
var d;
var f;
var h2;
var l = Object.keys(n);
var p = ((u = {})[t.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, u[t.RGB] = /^rgb\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*\)$/, u[t.RGBA] = /^rgba\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*,\s*(\d\.?\d*)\s*\)$/, u[t.HSL] = /^hsl\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%s*\)$/, u[t.HSLA] = /^hsla\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%\s*,\s*(\d\.?\d*)\s*\)$/, u[t.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)|(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*))\s*\)$/, u);
var g = /^(\d+(?:\.\d+)?|\.\d+)%$/;
var b = /^0x([a-f\d]{1,2})$/i;
var F = "The provided string color doesn't have a correct format";
var A = "The provided color object doesn't have the proper keys or format";
var m = function(t2, e2, r2) {
  return r2 < 0 && (r2 += 6), r2 >= 6 && (r2 -= 6), r2 < 1 ? Math.round(255 * ((e2 - t2) * r2 + t2)) : r2 < 3 ? Math.round(255 * e2) : r2 < 4 ? Math.round(255 * ((e2 - t2) * (4 - r2) + t2)) : Math.round(255 * t2);
};
var y = function(t2, e2, r2) {
  e2 /= 100;
  var n2 = (r2 /= 100) <= 0.5 ? r2 * (e2 + 1) : r2 + e2 - r2 * e2, i2 = 2 * r2 - n2;
  return { r: m(i2, n2, (t2 /= 60) + 2), g: m(i2, n2, t2), b: m(i2, n2, t2 - 2) };
};
var E = function(t2, e2, r2, n2) {
  return n2 = 1 - n2, { r: Math.round(255 * (1 - t2) * n2), g: Math.round(255 * (1 - e2) * n2), b: Math.round(255 * (1 - r2) * n2) };
};
var H = function(t2, e2, r2) {
  t2 /= 255, e2 /= 255, r2 /= 255;
  var n2 = 1 - Math.max(t2, e2, r2), i2 = 1 - n2, o2 = (i2 - t2) / i2, u2 = (i2 - e2) / i2, a2 = (i2 - r2) / i2;
  return { c: Math.round(100 * o2), m: Math.round(100 * u2), y: Math.round(100 * a2), k: Math.round(100 * n2) };
};
var B = function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = 1), t2 /= 255, e2 /= 255, r2 /= 255, n2 = Math.min(n2, 1);
  var i2 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), u2 = i2 - o2, a2 = 0, s2 = 0, c2 = (i2 + o2) / 2;
  if (u2 === 0)
    a2 = 0, s2 = 0;
  else {
    switch (i2) {
      case t2:
        a2 = (e2 - r2) / u2 % 6;
        break;
      case e2:
        a2 = (r2 - t2) / u2 + 2;
        break;
      case r2:
        a2 = (t2 - e2) / u2 + 4;
    }
    (a2 = Math.round(60 * a2)) < 0 && (a2 += 360), s2 = u2 / (1 - Math.abs(2 * c2 - 1));
  }
  return { h: a2, s: Math.round(100 * s2), l: Math.round(100 * c2), a: n2 };
};
var v = function(t2, e2) {
  if (t2 < 0 && (t2 += 360), t2 > 360 && (t2 -= 360), t2 === 360 || t2 === 0)
    return t2;
  var r2 = [[0, 120], [120, 180], [180, 240], [240, 360]], n2 = [[0, 60], [60, 120], [120, 240], [240, 360]], i2 = e2 ? n2 : r2, o2 = 0, u2 = 0, a2 = 0, s2 = 0;
  return (e2 ? r2 : n2).find(function(e3, r3) {
    return t2 >= e3[0] && t2 < e3[1] && (o2 = e3[0], u2 = e3[1], a2 = i2[r3][0], s2 = i2[r3][1], true);
  }), a2 + (s2 - a2) / (u2 - o2) * (t2 - o2);
};
var M = function(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
};
var R = function(t2) {
  return g.test("" + t2) ? +("" + t2).replace(g, "$1") : Math.min(+t2, 100);
};
var S = function(t2) {
  return t2.length === 1 && (t2 += t2), parseInt(t2, 16);
};
var C = function(t2) {
  var e2 = parseInt("" + t2).toString(16).toUpperCase();
  return e2.length === 1 ? "0x0" + e2 : "0x" + e2;
};
var L = function(t2) {
  var e2 = parseInt("" + t2).toString(16).toUpperCase();
  return e2.length === 1 && (e2 = "0" + e2), e2;
};
var D = function(t2, e2) {
  return e2 === void 0 && (e2 = false), !e2 && g.test(t2) ? Math.min(255 * +t2.replace(g, "$1") / 100, 255) : b.test(t2) ? t2.length === 3 ? e2 ? parseInt(t2 + t2.slice(-1)) / 255 : parseInt(t2 + t2.slice(-1)) : e2 ? parseInt(t2) / 255 : parseInt(t2) : Math.min(+t2, e2 ? 1 : 255);
};
var G = function(t2) {
  return Math.min(g.test(t2) ? +t2.replace(g, "$1") / 100 : +t2, 1);
};
var k = function(t2) {
  return t2.sort().join().toUpperCase();
};
var O = function(t2, e2) {
  e2 === void 0 && (e2 = 0);
  var r2 = Math.pow(10, e2);
  return Math.round(+t2 * r2) / r2;
};
var X = function(t2, e2, r2) {
  return Math.max(e2, Math.min(t2, r2));
};
var I = ((a = {})[t.HEX] = function(t2) {
  return "#" + L(t2.r) + L(t2.g) + L(t2.b) + (M(t2, "a") && L(t2.a) || "");
}, a[t.RGB] = function(t2) {
  return "rgb" + (M(t2, "a") ? "a" : "") + "(" + O(t2.r) + "," + O(t2.g) + "," + O(t2.b) + (M(t2, "a") && "," + O(t2.a, 2) || "") + ")";
}, a[t.HSL] = function(t2) {
  return "hsl" + (M(t2, "a") ? "a" : "") + "(" + O(t2.h) + "," + O(t2.s) + "%," + O(t2.l) + "%" + (M(t2, "a") && "," + O(t2.a, 2) || "") + ")";
}, a[t.CMYK] = function(t2) {
  return "cmyk(" + O(t2.c) + "%," + O(t2.m) + "%," + O(t2.y) + "%," + O(t2.k) + "%)";
}, a);
var j = function(t2) {
  return (t2 > 360 || t2 < 0) && (t2 -= 360 * Math.floor(t2 / 360)), t2;
};
var T = function(t2) {
  return isNaN(+t2) || t2 > 1 ? 1 : O(t2, 2);
};
var Y = function(t2, e2, n2) {
  return e2.reduce(function(e3, u2) {
    return o(o([], e3, true), [i(i({}, t2), { h: n2 === r.ADDITIVE ? j(t2.h + u2) : j(v(v(t2.h, false) + u2, true)) })], false);
  }, [i({}, t2)]);
};
var P = function(t2, e2) {
  return Y(t2, [30, -30], e2);
};
var w = function(t2, e2) {
  return Y(t2, [180], e2);
};
var K = function(t2, e2) {
  return Y(t2, [150, -150], e2);
};
var x = function(t2, e2) {
  return Y(t2, [120, -120], e2);
};
var N = function(t2, e2) {
  return Y(t2, [60, -120, 180], e2);
};
var V = function(t2, e2) {
  return Y(t2, [90, -90, 180], e2);
};
var U = function(e2) {
  return typeof e2 == "string" ? function(e3) {
    var r2;
    if (Object.keys(t).some(function(t2) {
      if (p[t2].test(e3))
        return r2 = t2, true;
    }), !r2 && ~l.indexOf(e3) && (r2 = t.HEX), !r2)
      throw new Error(F);
    return r2;
  }(e2) : function(e3) {
    var r2, n2 = false, i2 = k(Object.keys(e3));
    if (Object.keys(t).filter(function(e4) {
      return e4 !== t.HEX;
    }).some(function(t2) {
      if (k(t2.split("")) === i2)
        return r2 = t2, true;
    }), r2 && r2 === t.RGB || r2 === t.RGBA) {
      var o2 = Object.entries(e3).map(function(t2) {
        return b.test("" + t2[1]);
      }), u2 = Object.entries(e3).map(function(t2) {
        return g.test("" + t2[1]) || !b.test("" + t2[1]) && !isNaN(+t2[1]) && +t2[1] <= 255;
      }), a2 = o2.some(function(t2, e4) {
        return e4 > 0 && t2 !== o2[e4 - 1];
      }), s2 = u2.some(function(t2, e4) {
        return e4 > 0 && t2 !== u2[e4 - 1];
      });
      !(n2 = a2 || s2 || !o2[0] && !u2[0]) && o2[0] && (r2 = t.HEX);
    }
    if (!r2 || n2)
      throw new Error(A);
    return r2;
  }(e2);
};
var $ = ((s = {})[t.HEX] = function(t2) {
  var e2 = (~l.indexOf(t2) ? n[t2] : t2).match(p.HEX), r2 = { r: S(e2[1] || e2[5]), g: S(e2[2] || e2[6]), b: S(e2[3] || e2[7]) }, i2 = e2[4] || e2[8];
  return i2 !== void 0 && (r2.a = S(i2) / 255), r2;
}, s[t.RGB] = function(t2) {
  var e2 = t2.match(p.RGB), r2 = D(e2[1] || e2[4]), n2 = D(e2[2] || e2[5]), i2 = D(e2[3] || e2[6]);
  return { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(i2, 255) };
}, s[t.RGBA] = function(t2) {
  var e2 = t2.match(p.RGBA), r2 = D(e2[1] || e2[4]), n2 = D(e2[2] || e2[5]), i2 = D(e2[3] || e2[6]), o2 = +e2[7];
  return { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(i2, 255), a: T(o2) };
}, s[t.HSL] = function(t2) {
  var e2 = t2.match(p.HSL), r2 = j(+e2[1]), n2 = R(e2[2]), i2 = R(e2[3]);
  return y(r2, n2, i2);
}, s[t.HSLA] = function(t2) {
  var e2 = t2.match(p.HSLA), r2 = j(+e2[1]), n2 = R(e2[2]), i2 = R(e2[3]), o2 = +e2[4], u2 = y(r2, n2, i2);
  return u2.a = T(o2), u2;
}, s[t.CMYK] = function(t2) {
  var e2 = t2.match(p.CMYK), r2 = G(e2[1] || e2[5]), n2 = G(e2[2] || e2[6]), i2 = G(e2[3] || e2[7]), o2 = G(e2[4] || e2[8]);
  return E(r2, n2, i2, o2);
}, s);
var q = ((c = {})[t.HEX] = function(t2) {
  var e2 = { r: D("" + t2.r), g: D("" + t2.g), b: D("" + t2.b) };
  return e2.a = M(t2, "a") ? Math.min(D("" + t2.a, true), 1) : 1, e2;
}, c[t.RGB] = function(t2) {
  var e2 = this.HEX(t2);
  return delete e2.a, e2;
}, c[t.RGBA] = function(t2) {
  return this.HEX(t2);
}, c[t.HSL] = function(t2) {
  var e2 = R("" + t2.s), r2 = R("" + t2.l);
  return y(j(t2.h), e2, r2);
}, c[t.HSLA] = function(t2) {
  var e2 = this.HSL(t2);
  return e2.a = T(t2.a), e2;
}, c[t.CMYK] = function(t2) {
  var e2 = G("" + t2.c), r2 = G("" + t2.m), n2 = G("" + t2.y), i2 = G("" + t2.k);
  return E(e2, r2, n2, i2);
}, c);
var Q = function(t2, e2) {
  return e2 === void 0 && (e2 = U(t2)), typeof t2 == "string" ? $[e2](t2) : q[e2](t2);
};
var _ = ((d = {})[t.HEX] = function(t2) {
  return { r: C(t2.r), g: C(t2.g), b: C(t2.b) };
}, d.HEXA = function(t2) {
  var e2 = _.HEX(t2);
  return e2.a = M(t2, "a") ? C(255 * t2.a) : "0xFF", e2;
}, d[t.RGB] = function(t2) {
  return M(t2, "a") && delete t2.a, t2;
}, d[t.RGBA] = function(t2) {
  return t2.a = M(t2, "a") ? O(t2.a, 2) : 1, t2;
}, d[t.HSL] = function(t2) {
  var e2 = B(t2.r, t2.g, t2.b);
  return delete e2.a, e2;
}, d[t.HSLA] = function(t2) {
  var e2 = _.HSL(t2);
  return e2.a = M(t2, "a") ? O(t2.a, 2) : 1, e2;
}, d[t.CMYK] = function(t2) {
  return H(t2.r, t2.g, t2.b);
}, d);
var z = function(e2, r2, n2) {
  var o2 = U(e2), u2 = typeof e2 == "string", a2 = Q(e2, o2), s2 = typeof e2 == "string" && M(a2, "a") || typeof e2 != "string" && M(e2, "a"), c2 = B(a2.r, a2.g, a2.b, a2.a);
  s2 || delete c2.a;
  var d2 = n2 ? c2.l / (r2 + 1) : (100 - c2.l) / (r2 + 1), f2 = Array(r2).fill(null).map(function(t2, e3) {
    return i(i({}, c2), { l: c2.l + d2 * (e3 + 1) * (1 - 2 * +n2) });
  });
  switch (o2) {
    case t.HEX:
    default:
      return f2.map(function(t2) {
        var e3 = y(t2.h, t2.s, t2.l);
        return s2 && (e3.a = t2.a), u2 ? s2 ? I.HEX(i(i({}, e3), { a: O(255 * e3.a, 2) })) : I.HEX(e3) : s2 ? _.HEXA(e3) : _.HEX(e3);
      });
    case t.RGB:
    case t.RGBA:
      return f2.map(function(t2) {
        var e3 = y(t2.h, t2.s, t2.l);
        return s2 && (e3.a = t2.a), u2 ? I.RGB(e3) : s2 ? _.RGBA(e3) : _.RGB(e3);
      });
    case t.HSL:
    case t.HSLA:
      return f2.map(function(t2) {
        return u2 ? I.HSL(t2) : s2 ? _.HSLA(i(i({}, y(t2.h, t2.s, t2.l)), { a: t2.a })) : _.HSL(y(t2.h, t2.s, t2.l));
      });
  }
};
var J = ((f = { buildHarmony: function(e2, r2, n2) {
  var i2 = U(e2), o2 = Q(e2, i2), u2 = B(o2.r, o2.g, o2.b, o2.a), a2 = typeof e2 == "string" && M(o2, "a") || typeof e2 != "string" && M(e2, "a"), s2 = typeof e2 == "string";
  switch (i2) {
    case t.HEX:
    default:
      return a2 ? this.HEXA(u2, r2, n2, s2) : this.HEX(u2, r2, n2, s2);
    case t.HSL:
      return this.HSL(u2, r2, n2, s2);
    case t.HSLA:
      return this.HSLA(u2, r2, n2, s2);
    case t.RGB:
      return this.RGB(u2, r2, n2, s2);
    case t.RGBA:
      return this.RGBA(u2, r2, n2, s2);
  }
} })[t.HEX] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(y(t3.h, t3.s, t3.l)) : _.HEX(y(t3.h, t3.s, t3.l));
  });
}, f.HEXA = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(i(i({}, y(t3.h, t3.s, t3.l)), { a: 255 * T(t3.a) })) : _.HEXA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f[t.RGB] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(y(t3.h, t3.s, t3.l)) : _.RGB(y(t3.h, t3.s, t3.l));
  });
}, f[t.RGBA] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) })) : _.RGBA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f[t.HSL] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL({ h: t3.h, s: t3.s, l: t3.l }) : _.HSL(y(t3.h, t3.s, t3.l));
  });
}, f[t.HSLA] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL(i(i({}, t3), { a: T(t3.a) })) : _.HSLA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f);
var W = ((h2 = { mix: function(t2, e2) {
  var n2, o2, u2, a2, s2, c2, d2, f2, h3, l2, p2, g2, b2, F2, A2, m2 = t2.map(function(t3) {
    var e3 = U(t3);
    return Q(t3, e3);
  }), y2 = e2 === r.SUBTRACTIVE ? m2.map(function(t3) {
    var e3, r2, n3, i2, o3, u3, a3, s3, c3, d3, f3, h4, l3, p3, g3 = (e3 = t3.r, r2 = t3.g, n3 = t3.b, i2 = Math.min(e3, r2, n3), o3 = Math.min(255 - e3, 255 - r2, 255 - n3), u3 = e3 - i2, a3 = r2 - i2, s3 = n3 - i2, c3 = Math.min(u3, a3), d3 = u3 - c3, f3 = (a3 + c3) / 2, h4 = (s3 + a3 - c3) / 2, l3 = Math.max(d3, f3, h4) / Math.max(u3, a3, s3), p3 = isNaN(l3) || l3 === 1 / 0 || l3 <= 0 ? 1 : l3, { r: d3 / p3 + o3, y: f3 / p3 + o3, b: h4 / p3 + o3 });
    return M(t3, "a") && (g3.a = t3.a), g3;
  }) : null;
  function E2(t3) {
    var n3 = e2 === r.ADDITIVE ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, y: 0, b: 0, a: 0 };
    return t3.reduce(function(t4, n4) {
      var o3 = M(n4, "a") ? n4.a : 1, u3 = { r: Math.min(t4.r + n4.r * o3, 255), b: Math.min(t4.b + n4.b * o3, 255), a: 1 - (1 - o3) * (1 - t4.a) }, a3 = "g" in t4 ? t4.g : t4.y, s3 = "g" in n4 ? n4.g : n4.y;
      return i(i({}, u3), e2 === r.ADDITIVE ? { g: Math.min(a3 + s3 * o3, 255) } : { y: Math.min(a3 + s3 * o3, 255) });
    }, n3);
  }
  if (e2 === r.ADDITIVE)
    n2 = E2(m2);
  else {
    var H2 = E2(y2);
    o2 = H2.r, u2 = H2.y, a2 = H2.b, s2 = Math.min(o2, u2, a2), c2 = Math.min(255 - o2, 255 - u2, 255 - a2), d2 = o2 - s2, f2 = u2 - s2, h3 = a2 - s2, l2 = Math.min(f2, h3), p2 = d2 + f2 - l2, g2 = f2 + 2 * l2, b2 = 2 * (h3 - l2), F2 = Math.max(p2, g2, b2) / Math.max(d2, f2, h3), A2 = isNaN(F2) || F2 === 1 / 0 || F2 <= 0 ? 1 : F2, (n2 = { r: p2 / A2 + c2, g: g2 / A2 + c2, b: b2 / A2 + c2 }).a = H2.a;
  }
  return { r: O(n2.r, 2), g: O(n2.g, 2), b: O(n2.b, 2), a: X(n2.a, 0, 1) };
} })[t.HEX] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.HEX(n2) : _.HEX(n2);
}, h2.HEXA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return n2.a = r2 ? 255 * T(n2.a) : T(n2.a), r2 ? I.HEX(n2) : _.HEXA(n2);
}, h2[t.RGB] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.RGB(n2) : _.RGB(n2);
}, h2[t.RGBA] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return r2 ? I.RGB(n2) : _.RGBA(n2);
}, h2[t.HSL] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), i2 = B(n2.r, n2.g, n2.b);
  return delete n2.a, delete i2.a, r2 ? I.HSL(i2) : _.HSL(n2);
}, h2[t.HSLA] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), i2 = B(n2.r, n2.g, n2.b, n2.a);
  return r2 ? I.HSL(i2) : _.HSLA(n2);
}, h2);
var Z = function(t2, e2) {
  return typeof t2 == "string" && e2 || typeof t2 == "object" && !e2;
};
var tt = function(t2, e2, r2, n2, i2) {
  var o2 = n2(Q(t2, e2));
  return r2 ? i2(o2) : o2;
};
var et = function(t2, e2, r2, n2, i2, o2) {
  r2 < 1 && (r2 = 5);
  var u2 = function(t3, e3, r3) {
    var n3 = r3 - 1, i3 = (e3.r - t3.r) / n3, o3 = (e3.g - t3.g) / n3, u3 = (e3.b - t3.b) / n3, a2 = T(t3.a), s2 = (T(e3.a) - a2) / n3;
    return Array(r3).fill(null).map(function(r4, c2) {
      return c2 === 0 ? t3 : c2 === n3 ? e3 : { r: O(t3.r + i3 * c2), g: O(t3.g + o3 * c2), b: O(t3.b + u3 * c2), a: O(a2 + s2 * c2, 2) };
    });
  }(Q(t2), Q(e2), r2);
  return u2.map(function(t3) {
    var e3 = i2(t3);
    return n2 ? o2(e3) : e3;
  });
};
var rt = function() {
  function n2(t2) {
    this.rgb = Q(t2), this.updateHSL(), this.updateCMYK();
  }
  return n2.prototype.updateRGB = function() {
    this.rgb = i(i({}, y(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });
  }, n2.prototype.updateRGBFromCMYK = function() {
    this.rgb = i(i({}, E(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });
  }, n2.prototype.updateHSL = function() {
    this.hsl = B(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
  }, n2.prototype.updateCMYK = function() {
    this.cmyk = H(this.rgb.r, this.rgb.g, this.rgb.b);
  }, n2.prototype.updateRGBAndCMYK = function() {
    return this.updateRGB(), this.updateCMYK(), this;
  }, n2.prototype.updateHSLAndCMYK = function() {
    return this.updateHSL(), this.updateCMYK(), this;
  }, n2.prototype.updateRGBAndHSL = function() {
    return this.updateRGBFromCMYK(), this.updateHSL(), this;
  }, n2.prototype.setH = function(t2) {
    return this.hsl.h = j(t2), this.updateRGBAndCMYK();
  }, n2.prototype.setS = function(t2) {
    return this.hsl.s = X(t2, 0, 100), this.updateRGBAndCMYK();
  }, n2.prototype.setL = function(t2) {
    return this.hsl.l = X(t2, 0, 100), this.updateRGBAndCMYK();
  }, n2.prototype.setR = function(t2) {
    return this.rgb.r = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setG = function(t2) {
    return this.rgb.g = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setB = function(t2) {
    return this.rgb.b = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setA = function(t2) {
    return this.hsl.a = this.rgb.a = X(t2, 0, 1), this;
  }, n2.prototype.setC = function(t2) {
    return this.cmyk.c = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setM = function(t2) {
    return this.cmyk.m = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setY = function(t2) {
    return this.cmyk.y = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setK = function(t2) {
    return this.cmyk.k = X(t2, 0, 100), this.updateRGBAndHSL();
  }, Object.defineProperty(n2.prototype, "H", { get: function() {
    return O(this.hsl.h);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "S", { get: function() {
    return O(this.hsl.s);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "L", { get: function() {
    return O(this.hsl.l);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "R", { get: function() {
    return O(this.rgb.r);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "G", { get: function() {
    return O(this.rgb.g);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "B", { get: function() {
    return O(this.rgb.b);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "A", { get: function() {
    return O(this.hsl.a, 2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "C", { get: function() {
    return O(this.cmyk.c);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "M", { get: function() {
    return O(this.cmyk.m);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "Y", { get: function() {
    return O(this.cmyk.y);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "K", { get: function() {
    return O(this.cmyk.k);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXObject", { get: function() {
    return _.HEX(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXAObject", { get: function() {
    return _.HEXA(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBObject", { get: function() {
    return { r: this.R, g: this.G, b: this.B };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBAObject", { get: function() {
    return i(i({}, this.RGBObject), { a: this.A });
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLObject", { get: function() {
    return { h: this.H, s: this.S, l: this.L };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLAObject", { get: function() {
    return i(i({}, this.HSLObject), { a: this.A });
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "CMYKObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEX", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b };
    return I.HEX(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXA", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b, a: 255 * this.A };
    return I.HEX(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGB", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b };
    return I.RGB(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBA", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b, a: this.A };
    return I.RGB(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSL", { get: function() {
    var t2 = this.hsl, e2 = { h: t2.h, s: t2.s, l: t2.l };
    return I.HSL(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLA", { get: function() {
    return I.HSL(this.hsl);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "CMYK", { get: function() {
    return I.CMYK(this.cmyk);
  }, enumerable: false, configurable: true }), n2.toHEX = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.HEX, I.HEX);
  }, n2.toHEXA = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.HEXA, I.HEX);
  }, n2.toRGB = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.RGB, I.RGB);
  }, n2.toRGBA = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.RGBA, I.RGB);
  }, n2.toHSL = function(e2, r2) {
    r2 === void 0 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.HSL && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.HSL, I.HSL);
  }, n2.toHSLA = function(e2, r2) {
    r2 === void 0 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.HSLA && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.HSLA, I.HSL);
  }, n2.toCMYK = function(e2, r2) {
    r2 === void 0 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.CMYK && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.CMYK, I.CMYK);
  }, n2.getBlendHEX = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HEX, I.HEX);
  }, n2.getBlendHEXA = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HEXA, I.HEX);
  }, n2.getBlendRGB = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.RGB, I.RGB);
  }, n2.getBlendRGBA = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.RGBA, I.RGB);
  }, n2.getBlendHSL = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HSL, I.HSL);
  }, n2.getBlendHSLA = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HSLA, I.HSL);
  }, n2.getMixHEX = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HEX(t2, e2, n3);
  }, n2.getMixHEXA = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HEXA(t2, e2, n3);
  }, n2.getMixRGB = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.RGB(t2, e2, n3);
  }, n2.getMixRGBA = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.RGBA(t2, e2, n3);
  }, n2.getMixHSL = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HSL(t2, e2, n3);
  }, n2.getMixHSLA = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HSLA(t2, e2, n3);
  }, n2.getShades = function(t2, e2) {
    return z(t2, e2, true);
  }, n2.getTints = function(t2, e2) {
    return z(t2, e2, false);
  }, n2.getHarmony = function(t2, n3, i2) {
    switch (n3 === void 0 && (n3 = e.COMPLEMENTARY), i2 === void 0 && (i2 = r.ADDITIVE), n3) {
      case e.ANALOGOUS:
        return J.buildHarmony(t2, P, i2);
      case e.SPLIT_COMPLEMENTARY:
        return J.buildHarmony(t2, K, i2);
      case e.TRIADIC:
        return J.buildHarmony(t2, x, i2);
      case e.TETRADIC:
        return J.buildHarmony(t2, N, i2);
      case e.SQUARE:
        return J.buildHarmony(t2, V, i2);
      default:
        return J.buildHarmony(t2, w, i2);
    }
  }, n2;
}();

// node_modules/vuestic-ui/dist/esm/src/services/color-config/color-functions.js
var colorToRgba = (color, opacity) => {
  return new rt(color).setA(opacity).RGBA;
};
var getTextColor = (color, darkColor = "dark", lightColor = "white") => {
  const { R: R2, G: G2, B: B2 } = new rt(color);
  const isLightBackground = Math.sqrt(R2 * R2 * 0.241 + G2 * G2 * 0.691 + B2 * B2 * 0.068) > 130;
  return isLightBackground ? darkColor : lightColor;
};
var getBoxShadowColor = (color) => {
  return new rt(color).setA(0.4).RGBA;
};
var getHoverColor = (color) => {
  return new rt(color).setA(0.2).RGBA;
};
var getFocusColor = (color) => {
  return new rt(color).setA(0.3).RGBA;
};
var shiftHSLAColor = (color, offset) => {
  const result = new rt(color);
  if (offset.h) {
    result.setH(result.H + offset.h);
  }
  if (offset.s) {
    result.setS(result.S + offset.s);
  }
  if (offset.l) {
    result.setL(result.L + offset.l);
  }
  if (offset.a) {
    result.setA(result.A + offset.a);
  }
  return result.HSLA;
};
var setHSLAColor = (color, newColor) => {
  const result = new rt(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
var shiftGradientColor = (color) => {
  const newColor = rt.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = rt.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
var isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);

// node_modules/vuestic-ui/dist/esm/src/composables/useColors.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const globalConfig = useGlobalConfigSafe();
  if (!globalConfig) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { setGlobalConfig, getGlobalConfig } = globalConfig;
  const setColors = (colors) => {
    setGlobalConfig((config) => __spreadProps(__spreadValues2({}, config), {
      colors: __spreadValues2(__spreadValues2({}, config.colors), colors)
    }));
  };
  const getColors = () => {
    return getGlobalConfig().colors || {};
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = getColors().primary;
    }
    const colors = getColors();
    if (!prop) {
      prop = defaultColor;
    }
    if (colors[prop]) {
      return preferVariables ? `var(--va-${prop})` : colors[prop];
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    return defaultColor;
  };
  const colorsToCSSVariable = (colors, prefix2 = "va") => {
    return Object.keys(colors).filter((key2) => colors[key2] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${colorName}`] = getColor(colors[colorName], void 0, true);
      return acc;
    }, {});
  };
  return {
    setColors,
    getColors,
    getColor,
    getBoxShadowColor,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useDropdown.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/utils/map-object.js
var mapObject = (o2, cb) => {
  const copy = {};
  Object.keys(o2).forEach((key2) => {
    copy[key2] = cb(o2[key2], key2);
  });
  return copy;
};

// node_modules/vuestic-ui/dist/esm/src/composables/useDomRect.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useRequestAnimationFrame.js
init_vue_runtime_esm_bundler();
var useRequestAnimationFrame = (cb) => {
  let animationFrameRequest = -1;
  const observe = () => {
    animationFrameRequest = requestAnimationFrame(observe);
    cb();
  };
  onMounted(() => {
    observe();
  });
  onBeforeUnmount(() => {
    cancelAnimationFrame(animationFrameRequest);
  });
};

// node_modules/vuestic-ui/dist/esm/src/composables/useDomRect.js
var keys2 = ["x", "y", "width", "height", "top", "left", "right", "bottom"];
var isDomRectEqual = (a2, b2) => {
  for (let i2 = 0; i2 < keys2.length; i2++) {
    if (a2[keys2[i2]] !== b2[keys2[i2]]) {
      return false;
    }
  }
  return true;
};
var useDomRect = (target) => {
  const domRect = ref(null);
  let prev = {};
  useRequestAnimationFrame(() => {
    if (!target.value) {
      return;
    }
    const rect = target.value.getBoundingClientRect();
    if (!isDomRectEqual(rect, prev)) {
      domRect.value = rect;
    }
    prev = rect;
  });
  watch(target, (newVal) => {
    if (newVal) {
      domRect.value = newVal.getBoundingClientRect();
    } else {
      domRect.value = null;
    }
  });
  return {
    domRect
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useClientOnly.js
init_vue_runtime_esm_bundler();
var useClientOnly = (cb) => {
  if (isServer()) {
    const result = ref(null);
    onMounted(() => {
      result.value = cb();
    });
    return result;
  }
  return ref(cb());
};

// node_modules/vuestic-ui/dist/esm/src/composables/useDropdown.js
var __defProp3 = Object.defineProperty;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key2, value) => key2 in obj ? __defProp3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a2, prop, b2[prop]);
    }
  return a2;
};
var placementsPositions = ["top", "bottom", "left", "right"].reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ["auto"]);
var coordsToCss = ({ x: x2, y: y2 }) => ({ left: `${x2}px`, top: `${y2}px` });
var parsePlacement = (placement) => {
  let [position, align] = placement.split("-");
  if (position === "auto") {
    position = "bottom";
  }
  return { position, align: align || "center" };
};
var parseOffset = (offset) => {
  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
var calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
  if (align === "start") {
    return anchorStart;
  }
  if (align === "end") {
    return anchorStart + anchorSize - contentSize;
  }
  return anchorStart + (anchorSize - contentSize) / 2;
};
var calculateContentCoords = (placement, anchor, content) => {
  const { position, align } = parsePlacement(placement);
  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
  switch (position) {
    case "top":
      return { x: alignmentX, y: anchor.top - content.height };
    case "left":
      return { y: alignmentY, x: anchor.left - content.width };
    case "right":
      return { y: alignmentY, x: anchor.right };
    case "bottom":
    default:
      return { x: alignmentX, y: anchor.bottom };
  }
};
var calculateOffsetCoords = (placement, offset) => {
  const { position } = parsePlacement(placement);
  const { main, cross } = parseOffset(offset);
  switch (position) {
    case "left":
      return { y: cross, x: -main };
    case "right":
      return { y: cross, x: main };
    case "top":
      return { y: -main, x: cross };
    case "bottom":
    default:
      return { y: main, x: cross };
  }
};
var calculateContentOverflow = (coords, content, viewport) => {
  const xMax = viewport.right;
  const yMax = viewport.bottom;
  const xMin = viewport.left;
  const yMin = viewport.top;
  return {
    top: Math.max(yMin - coords.y, 0),
    bottom: Math.max(coords.y + content.height - yMax, 0),
    left: Math.max(xMin - coords.x, 0),
    right: Math.max(coords.x + content.width - xMax, 0)
  };
};
var clamp2 = (min, v2, max) => Math.max(Math.min(v2, max), min);
var calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {
  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport);
  const x2 = coords.x - right + left;
  const y2 = coords.y - bottom + top;
  const { x: offsetX, y: offsetY } = offsetCoords;
  return {
    x: clamp2(anchor.left + offsetX - content.width, x2, anchor.right + offsetX),
    y: clamp2(anchor.top + offsetY - content.height, y2, anchor.bottom + offsetY)
  };
};
var getAutoPlacement = (placement, coords, content, viewport) => {
  const { position, align } = parsePlacement(placement);
  const overflow = calculateContentOverflow(coords, content, viewport);
  const newPlacements = {
    top: ["bottom", align].join("-"),
    bottom: ["top", align].join("-"),
    right: ["left", align].join("-"),
    left: ["right", align].join("-")
  };
  return overflow[position] ? newPlacements[position] : placement;
};
var findFirstRelativeParent = (el) => {
  while (el) {
    if (window.getComputedStyle(el).position === "relative") {
      return el;
    }
    el = el.parentElement;
  }
  return document.body;
};
var useDropdown = (anchorRef, contentRef, options) => {
  const documentRef = useClientOnly(() => document);
  const rootRef = computed(() => {
    if (!documentRef.value) {
      return void 0;
    }
    const { root: root2 } = unref(options);
    if (root2) {
      let el;
      if (typeof root2 === "string") {
        el = documentRef.value.querySelector(root2);
      } else {
        el = root2;
      }
      if (!el) {
        return documentRef.value.body;
      }
      return findFirstRelativeParent(el);
    }
    return documentRef.value.body;
  });
  const { domRect: anchorDomRect } = useDomRect(anchorRef);
  const { domRect: contentDomRect } = useDomRect(contentRef);
  const css = {
    width: "max-content",
    position: "absolute"
  };
  watchPostEffect(() => {
    var _a, _b;
    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
      return;
    }
    const { placement, offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options);
    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);
    let offsetCoords = { x: 0, y: 0 };
    if (offset) {
      offsetCoords = calculateOffsetCoords(placement, offset);
      coords = mapObject(coords, (c2, key2) => c2 + offsetCoords[key2]);
    }
    const rootRect = rootRef.value.getBoundingClientRect();
    const viewportRect = (_b = (_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) != null ? _b : rootRect;
    if (autoPlacement) {
      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect);
      if (newPlacement !== placement) {
        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);
        if (offset) {
          offsetCoords = calculateOffsetCoords(newPlacement, offset);
          coords = mapObject(coords, (c2, key2) => c2 + offsetCoords[key2]);
        }
      }
    }
    if (stickToEdges) {
      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);
    }
    coords.x -= rootRect.x;
    coords.y -= rootRect.y;
    if (contentRef.value) {
      let widthCss = {};
      if (keepAnchorWidth) {
        const { width } = anchorDomRect.value;
        widthCss = { width: `${width}px`, maxWidth: `${width}px` };
      }
      Object.assign(contentRef.value.style, __spreadValues3(__spreadValues3(__spreadValues3({}, css), coordsToCss(coords)), widthCss));
    }
  });
  return {
    anchorDomRect,
    contentDomRect
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useTextColor.js
init_vue_runtime_esm_bundler();
var useTextColor = (componentColor, isTransparent = false) => {
  const { props } = getCurrentInstance();
  const { getColor, getTextColor: getTextColor2 } = useColors();
  const textColorComputed = computed(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const componentColorHex = getColor(unref(componentColor) || props.color);
    return unref(isTransparent) ? componentColorHex : getColor(getTextColor2(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useTimer.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear2 = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear: clear2
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-icon/VaIcon.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/utils/regex.js
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g2) => g2.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/utils/dynamic-segment.js
var __defProp4 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key2, value) => key2 in obj ? __defProp4(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b2)) {
      if (__propIsEnum4.call(b2, prop))
        __defNormalProp4(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g2) => g2.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i2) => __spreadProps2(__spreadValues4({}, acc), { [paramValue]: values[i2] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/types.js
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/icon-helpers.js
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = merge_1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return merge_1(findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore), resolvedIconConfiguration);
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key2) => {
    delete configuration[key2];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};

// node_modules/vuestic-ui/dist/esm/src/services/icon-config/icon-config-hooks.js
var useIcons = (props) => {
  const { getGlobalConfig } = useGlobalConfig();
  const getIconConfig = () => {
    return getGlobalConfig().icons || [];
  };
  return {
    getIcon: (name) => getIconConfiguration(name, getIconConfig())
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useSize.js
init_vue_runtime_esm_bundler();
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size2) => {
      return typeof size2 === "string" || typeof size2 === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var useSize = (props, componentName3 = ((_a) => (_a = getCurrentInstance()) == null ? void 0 : _a.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName3 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName3]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSizeGlobal || defaultSize}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/esm/plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-icon/VaIcon.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-icon/VaIcon.css";
var __defProp5 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key2, value) => key2 in obj ? __defProp5(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp5.call(b2, prop))
      __defNormalProp5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b2)) {
      if (__propIsEnum5.call(b2, prop))
        __defNormalProp5(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps3 = (a2, b2) => __defProps3(a2, __getOwnPropDescs3(b2));
var _sfc_main = defineComponent({
  name: "VaIcon",
  props: __spreadProps3(__spreadValues5({}, useSizeProps), {
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  }),
  setup(props, { attrs }) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcons();
    const iconConfig = computed(() => getIcon(props.name));
    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const computedAttrs = computed(() => __spreadValues5(__spreadValues5({}, iconConfig.value.attrs), omit_1(attrs, ["class"])));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => {
      var _a;
      return [
        iconConfig.value.class,
        getSpinClass((_a = props.spin) != null ? _a : iconConfig.value.spin)
      ];
    });
    const transformStyle = computed(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    return {
      iconConfig,
      computedTag,
      computedAttrs,
      computedClass,
      computedStyle
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.computedTag), mergeProps({
    class: ["va-icon", _ctx.computedClass],
    "aria-hidden": "true",
    style: _ctx.computedStyle
  }, _ctx.computedAttrs, { notranslate: "" }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        _ctx.iconConfig.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.iconConfig.content), 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var VaIcon = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/VaToast.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-toast/VaToast.css";
var VaToastRenderer = defineComponent({
  name: "VaToastRenderer",
  props: {
    render: { type: Function, required: true }
  },
  setup: (props) => () => props.render()
});
var _sfc_main2 = defineComponent({
  name: "VaToast",
  components: { VaIcon, VaToastRenderer },
  emits: ["on-click", "on-close"],
  props: {
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const visible = ref(false);
    const positionX = computed(() => {
      return props.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props.offsetY}px`,
      [positionX.value]: `${props.offsetX}px`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a, _b;
      (_a = rootElement.value) == null ? void 0 : _a.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a;
      visible.value = false;
      (_a = rootElement.value) == null ? void 0 : _a.addEventListener("transitionend", destroyElement);
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return {
      visible,
      toastClasses,
      toastStyles,
      computedMessage,
      onToastClick,
      onToastClose,
      startTimer,
      clearTimer
    };
  }
});
var _hoisted_1 = ["role"];
var _hoisted_2 = { class: "va-toast__group" };
var _hoisted_3 = ["textContent"];
var _hoisted_4 = { class: "va-toast__content" };
var _hoisted_5 = ["innerHTML"];
var _hoisted_6 = ["textContent"];
var _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.closeable ? "alertdialog" : "alert",
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onToastClick && _ctx.onToastClick(...args))
      }, [
        createBaseVNode("div", _hoisted_2, [
          _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
            key: 0,
            class: "va-toast__title",
            textContent: toDisplayString(_ctx.$props.title)
          }, null, 8, _hoisted_3)) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", _hoisted_4, [
            _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: _ctx.computedMessage
            }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock("p", {
              key: 1,
              textContent: toDisplayString(_ctx.computedMessage)
            }, null, 8, _hoisted_6))
          ], 512), [
            [vShow, _ctx.$props.message]
          ]),
          _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7, [
            createVNode(_component_VaToastRenderer, {
              render: _ctx.$props.render
            }, null, 8, ["render"])
          ])) : createCommentVNode("", true),
          _ctx.$props.closeable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: "va-toast__close-icon",
            role: "button",
            "aria-label": "close toast",
            "aria-hidden": "false",
            tabindex: "0",
            size: "small",
            name: _ctx.$props.icon,
            onClick: withModifiers(_ctx.onToastClose, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
          }, null, 8, ["name", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ])
      ], 46, _hoisted_1), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  });
}
var _VaToast = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/index.js
init_vue_runtime_esm_bundler();
var VaToast = withConfigTransport(_VaToast);

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/toast.js
var __defProp6 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key2, value) => key2 in obj ? __defProp6(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp6.call(b2, prop))
      __defNormalProp6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b2)) {
      if (__propIsEnum6.call(b2, prop))
        __defNormalProp6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps4 = (a2, b2) => __defProps4(a2, __getOwnPropDescs4(b2));
var GAP = 5;
var seed = 1;
getGlobal().vaToastInstances = [];
var getTranslateValue = (item, position) => {
  if (item.el) {
    const direction = position.includes("bottom") ? -1 : 1;
    return (item.el.offsetHeight + GAP) * direction;
  }
  return 0;
};
var getNewTranslateValue = (transformY, redundantHeight, position) => {
  const direction = position.includes("bottom") ? -1 : 1;
  return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
var getNodeProps = (vNode) => {
  var _a;
  return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  var _a;
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  const nodeProps = getNodeProps(targetInstance);
  const {
    offsetX: targetOffsetX,
    offsetY: targetOffsetY,
    position: targetPosition
  } = nodeProps;
  const redundantHeight = (_a = targetInstance.el) == null ? void 0 : _a.offsetHeight;
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    if (instance.component) {
      const { offsetX, offsetY, position } = getNodeProps(instance);
      const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
      if (isNextInstance && instance.el && redundantHeight) {
        const [_2, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
        const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
        instance.el.style.transform = `translate(0, ${transformYNew}px)`;
      }
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, {
  props,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props == null ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode(component, __spreadProps4(__spreadValues6({}, props), { onClose }), children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a;
    return ((_a = instance.el) == null ? void 0 : _a.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    const { offsetX, offsetY, position } = nodeProps;
    vNode.el.style.display = "flex";
    vNode.el.id = "notification_" + seed;
    let transformY = 0;
    getGlobal().vaToastInstances.filter((item) => {
      const {
        offsetX: itemOffsetX,
        offsetY: itemOffsetY,
        position: itemPosition
      } = getNodeProps(item);
      return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
    }).forEach((item) => {
      transformY += getTranslateValue(item, position);
    });
    vNode.el.style.transform = `translate(0, ${transformY}px)`;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/plugin/index.js
var createVaToastPlugin = (app) => ({
  init(options) {
    return createToastInstance(options, app == null ? void 0 : app._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app == null ? void 0 : app._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaToast", createVaToastPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/plugin/index.js
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app, "$vaDropdown", vaDropdownPlugin);
  }
}));

// node_modules/vuestic-ui/dist/esm/src/components/va-modal/VaModal.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useStateful.js
init_vue_runtime_esm_bundler();
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var useStatefulEmits = ["update:modelValue"];
function useStateful(props, emit, defaultValue) {
  const valueState = ref(defaultValue === void 0 ? props.modelValue : defaultValue);
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props.modelValue, (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get() {
      if (props.stateful) {
        return valueState.value;
      }
      return props.modelValue;
    },
    set(value) {
      if (props.stateful) {
        valueState.value = value;
      }
      emit("update:modelValue", value);
    }
  });
  return { valueComputed };
}

// node_modules/vuestic-ui/dist/esm/src/composables/useDocument.js
var useDocument = () => useClientOnly(() => document);

// node_modules/vuestic-ui/dist/esm/src/composables/useWindow.js
var useWindow = () => useClientOnly(() => window);

// node_modules/vuestic-ui/dist/esm/src/components/va-button/VaButton.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/esm/src/composables/useRouterLink.js
init_vue_runtime_esm_bundler();
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: "" },
  replace: { type: Boolean, default: false },
  append: { type: Boolean, default: false },
  exact: { type: Boolean, default: false },
  activeClass: { type: String, default: "" },
  exactActiveClass: { type: String, default: "" },
  href: { type: String, default: "" },
  target: { type: String, default: "" },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props) => {
  const globalProperties = computed(() => {
    var _a;
    return (_a = getCurrentInstance()) == null ? void 0 : _a.appContext.config.globalProperties;
  });
  const isNuxt = computed(() => {
    var _a;
    return !!((_a = globalProperties.value) == null ? void 0 : _a.$nuxt);
  });
  const vueRouter = computed(() => {
    var _a;
    return (_a = globalProperties.value) == null ? void 0 : _a.$router;
  });
  const vueRoute = computed(() => {
    var _a;
    return (_a = globalProperties.value) == null ? void 0 : _a.$route;
  });
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    if (props.to) {
      return isNuxt.value ? "nuxt-link" : "router-link";
    }
    return props.tag;
  });
  const isLinkTag = computed(() => ["a", "router-link", "nuxt-link"].includes(tagComputed.value));
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a;
    return props.href || (props.to ? (_a = vueRouter.value) == null ? void 0 : _a.resolve(props.to, vueRoute.value).href : "");
  });
  return {
    tagComputed,
    isActiveRouterLink,
    hrefComputed,
    isLinkTag
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-icon/index.js
var VaIcon2 = withConfigTransport(VaIcon);

// node_modules/vuestic-ui/dist/esm/src/components/va-progress-circle/VaProgressCircle.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-progress-circle/VaProgressCircle.css";
var __defProp7 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key2, value) => key2 in obj ? __defProp7(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp7.call(b2, prop))
      __defNormalProp7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b2)) {
      if (__propIsEnum7.call(b2, prop))
        __defNormalProp7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps5 = (a2, b2) => __defProps5(a2, __getOwnPropDescs5(b2));
var _sfc_main3 = defineComponent({
  name: "VaProgressCircle",
  props: __spreadProps5(__spreadValues7({}, useSizeProps), {
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: Number, default: 0.06 },
    color: { type: String, default: "primary" }
  }),
  setup(props) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed(() => clamp_1(props.thickness, 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp_1(props.modelValue, 0, 100) / 100));
    const colorComputed = computed(() => getColor(props.color, void 0, true));
    return {
      infoStyle: computed(() => ({ color: colorComputed.value })),
      rootStyle: computed(() => ({
        width: sizeComputed.value,
        height: sizeComputed.value
      })),
      rootClass: computed(() => ({
        "va-progress-circle--indeterminate": props.indeterminate
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        ariaLabel: "progress state",
        ariaValuenow: !props.indeterminate ? props.modelValue : void 0
      })),
      colorComputed,
      radius,
      dasharray,
      dashoffset,
      cappedThickness
    };
  }
});
var _hoisted_12 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-circle", _ctx.rootClass],
    style: _ctx.rootStyle
  }, _ctx.ariaAttributesComputed), [
    (openBlock(), createElementBlock("svg", _hoisted_12, [
      createBaseVNode("circle", {
        class: "va-progress-circle__overlay",
        cx: "50%",
        cy: "50%",
        r: _ctx.radius,
        fill: "none",
        stroke: _ctx.colorComputed,
        "stroke-width": _ctx.cappedThickness + "%",
        "stroke-dasharray": _ctx.dasharray,
        "stroke-dashoffset": _ctx.dashoffset
      }, null, 8, _hoisted_22)
    ])),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.infoStyle),
      class: "va-progress-circle__info"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)) : createCommentVNode("", true)
  ], 16);
}
var _VaProgressCircle = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-progress-circle/index.js
var VaProgressCircle = withConfigTransport(_VaProgressCircle);

// node_modules/vuestic-ui/dist/esm/src/components/va-button/VaButton.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-button/VaButton.css";
var __defProp8 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key2, value) => key2 in obj ? __defProp8(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues8 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp8.call(b2, prop))
      __defNormalProp8(a2, prop, b2[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b2)) {
      if (__propIsEnum8.call(b2, prop))
        __defNormalProp8(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps6 = (a2, b2) => __defProps6(a2, __getOwnPropDescs6(b2));
var _sfc_main4 = defineComponent({
  name: "VaButton",
  components: { VaIcon: VaIcon2, VaProgressCircle },
  props: __spreadProps6(__spreadValues8(__spreadValues8(__spreadValues8({}, useSizeProps), useLoadingProps), useRouterLinkProps), {
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    tag: { type: String, default: "button" },
    outline: { type: Boolean, default: void 0 },
    gradient: { type: Boolean, default: void 0 },
    flat: { type: Boolean, default: void 0 },
    type: { type: String, default: "button" },
    disabled: { type: Boolean, default: false },
    block: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    round: { type: Boolean, default: void 0 },
    spaceBetweenItems: { type: Boolean, default: void 0 },
    icon: { type: String, default: void 0 },
    iconRight: { type: String, default: void 0 },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  }),
  setup(props, { slots }) {
    const button = shallowRef();
    const { sizeComputed } = useSize(props);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const hoverState = ref(false);
    const focusState = ref(false);
    const { getColor, getGradientBackground: getGradientBackground2, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const isSlotContentPassed = computed(() => {
      var _a, _b, _c;
      return !!((_c = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) == null ? void 0 : _b[0]) == null ? void 0 : _c.children);
    });
    const computedType = computed(() => {
      switch (tagComputed.value) {
        case "a":
        case "router-link":
        case "nuxt-link":
          return void 0;
        default:
          return props.type;
      }
    });
    const onlyIcon = computed(() => {
      return Boolean(!slots.default && (props.iconRight && !props.icon || !props.iconRight && props.icon));
    });
    const computedClass = computed(() => ({
      "va-button--default": !props.flat && !props.outline && !props.disabled,
      "va-button--flat": props.flat,
      "va-button--outline": props.outline,
      "va-button--disabled": props.disabled,
      "va-button--hover": hoverState.value,
      "va-button--focus": focusState.value,
      "va-button--large": props.size === "large",
      "va-button--small": props.size === "small",
      "va-button--normal": !props.size || props.size === "medium",
      "va-button--loading": props.loading,
      "va-button--block": props.block,
      "va-button--square": !props.rounded,
      "va-button--round": props.round || onlyIcon.value,
      "va-button--no-label": !isSlotContentPassed.value,
      "va-button--space-between-items": props.spaceBetweenItems
    }));
    const ariaLabelComputed = computed(() => onlyIcon.value ? props.icon || props.iconRight : void 0);
    const loaderSize = computed(() => {
      const size2 = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size2 ? `${+size2[1] / 2}${size2[2]}` : sizeComputed.value;
    });
    const computedStyle = computed(() => {
      const borderColor = props.outline ? colorComputed.value : "";
      let background = props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
      if (isTransparentBackground.value) {
        background = "var(--va-transparent)";
      }
      if (hoverState.value) {
        const alpha = props.outline ? -0.9 : -0.8;
        const lightness = 5;
        const color = isTransparentBackground.value ? shiftHSLAColor2(colorComputed.value, { a: alpha }) : shiftHSLAColor2(colorComputed.value, { l: lightness });
        background = props.gradient ? getGradientBackground2(color) : color;
      }
      if (focusState.value) {
        const alpha = props.outline ? -0.8 : -0.7;
        const lightness = 10;
        const color = isTransparentBackground.value ? shiftHSLAColor2(colorComputed.value, { a: alpha }) : shiftHSLAColor2(colorComputed.value, { l: lightness });
        background = props.gradient ? getGradientBackground2(color) : color;
      }
      return {
        color: textColorComputed.value,
        borderColor,
        background
      };
    });
    const focus = () => {
      var _a;
      return (_a = button.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      return (_a = button.value) == null ? void 0 : _a.blur();
    };
    return {
      button,
      tagComputed,
      hrefComputed,
      computedClass,
      computedStyle,
      computedType,
      textColorComputed,
      loaderSize,
      focusState,
      ariaLabelComputed,
      hoverState,
      focus,
      blur
    };
  }
});
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    class: ["va-button", _ctx.computedClass],
    ref: "button",
    "aria-live": "polite",
    "aria-disabled": _ctx.$props.disabled,
    "aria-label": _ctx.ariaLabelComputed,
    style: _ctx.computedStyle,
    disabled: _ctx.$props.disabled,
    type: _ctx.computedType,
    href: _ctx.hrefComputed,
    target: _ctx.$props.target,
    to: _ctx.$props.to,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    "active-class": _ctx.$props.activeClass,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass,
    tabindex: _ctx.loading ? -1 : 0
  }, toHandlers(_ctx.$attrs), {
    onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.focusState = true),
    onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.focusState = false),
    onMouseleave: _cache[2] || (_cache[2] = ($event) => _ctx.hoverState = false),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.hoverState = true)
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(["va-button__content", { "va-button__content--loading": _ctx.loading }])
      }, [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-button__left-icon",
          name: _ctx.icon,
          size: _ctx.size,
          color: _ctx.textColorComputed
        }, null, 8, ["name", "size", "color"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.iconRight ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          class: "va-button__right-icon",
          name: _ctx.iconRight,
          size: _ctx.size,
          color: _ctx.textColorComputed
        }, null, 8, ["name", "size", "color"])) : createCommentVNode("", true)
      ], 2),
      _ctx.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
        key: 0,
        class: "va-button__loader",
        indeterminate: "",
        size: _ctx.loaderSize,
        color: _ctx.computedStyle.color,
        thickness: 0.15
      }, null, 8, ["size", "color", "thickness"])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["aria-disabled", "aria-label", "class", "style", "disabled", "type", "href", "target", "to", "replace", "append", "active-class", "exact", "exact-active-class", "tabindex"]);
}
var VaButton = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-button/index.js
var VaButton2 = withConfigTransport(VaButton);

// node_modules/vuestic-ui/dist/esm/src/components/va-modal/VaModal.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-modal/VaModal.css";
var __defProp9 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key2, value) => key2 in obj ? __defProp9(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues9 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp9.call(b2, prop))
      __defNormalProp9(a2, prop, b2[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b2)) {
      if (__propIsEnum9.call(b2, prop))
        __defNormalProp9(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps7 = (a2, b2) => __defProps7(a2, __getOwnPropDescs7(b2));
var ModalElement = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a;
    return props.isTransition ? h(Transition, __spreadValues9({}, attrs), slots) : (_a = slots.default) == null ? void 0 : _a.call(slots, attrs);
  }
});
var _sfc_main5 = defineComponent({
  name: "VaModal",
  inheritAttrs: false,
  components: { VaButton: VaButton2, VaIcon: VaIcon2, ModalElement },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  props: __spreadProps7(__spreadValues9({}, useStatefulProps), {
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "OK" },
    cancelText: { type: String, default: "Cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String] },
    backgroundColor: { type: String, default: "white" },
    noPadding: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding,
      [`va-modal--size-${props.size}`]: props.size !== "medium"
    }));
    const computedModalContainerStyle = computed(() => ({ "z-index": props.zIndex }));
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayStyles = computed(() => {
      var _a;
      const moreThanOneModalIsOpen = !!((_a = document2.value) == null ? void 0 : _a.querySelectorAll(".va-modal__overlay").length);
      if (!props.overlay || moreThanOneModalIsOpen) {
        return;
      }
      return {
        "background-color": `rgba(0, 0, 0, ${props.overlayOpacity})`,
        "z-index": props.zIndex && Number(props.zIndex) - 1
      };
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = () => {
      valueComputed.value = false;
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      hide();
      emit("cancel");
    };
    const ok = () => {
      hide();
      emit("ok");
    };
    const onOutsideClick = () => {
      if (props.noOutsideDismiss || props.noDismiss) {
        return;
      }
      emit("click-outside");
      cancel();
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e2) => {
      e2.modalsCounter = e2.modalsCounter ? e2.modalsCounter + 1 : 1;
      const modalNumber = e2.modalsCounter;
      const isOnTop = () => e2.modalsCounter === modalNumber;
      const hideModal = () => {
        if (e2.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isOnTop()) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    const window2 = useWindow();
    const document2 = useDocument();
    watchEffect(() => {
      var _a, _b, _c, _d;
      if (valueComputed.value) {
        (_a = window2.value) == null ? void 0 : _a.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window2.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
      if (props.blur) {
        if (valueComputed.value) {
          (_c = document2.value) == null ? void 0 : _c.body.classList.add("va-modal-overlay-background--blurred");
        } else {
          (_d = document2.value) == null ? void 0 : _d.body.classList.remove("va-modal-overlay-background--blurred");
        }
      }
    });
    const publicMethods = {
      show,
      hide,
      toggle,
      cancel,
      ok,
      onOutsideClick,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    };
    return __spreadValues9({
      getColor,
      rootElement,
      valueComputed,
      computedClass,
      computedDialogStyle,
      computedModalContainerStyle,
      computedOverlayStyles
    }, publicMethods);
  }
});
var _hoisted_13 = ["aria-labelledby"];
var _hoisted_23 = {
  key: 0,
  class: "va-modal__anchor"
};
var _hoisted_32 = {
  key: 0,
  class: "va-modal"
};
var _hoisted_42 = { key: 0 };
var _hoisted_52 = {
  key: 1,
  class: "va-modal__header"
};
var _hoisted_62 = {
  key: 2,
  class: "va-modal__message"
};
var _hoisted_72 = {
  key: 3,
  class: "va-modal__message"
};
var _hoisted_8 = {
  key: 4,
  class: "va-modal__footer"
};
var _hoisted_9 = {
  key: 5,
  class: "va-modal__footer"
};
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_button = resolveComponent("va-button");
  const _component_modal_element = resolveComponent("modal-element");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass]),
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": _ctx.title
  }, [
    _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", _hoisted_23, [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ show: _ctx.show, hide: _ctx.hide, toggle: _ctx.toggle })))
    ])) : createCommentVNode("", true),
    (openBlock(), createBlock(Teleport, {
      to: _ctx.attachElement,
      disabled: _ctx.$props.disableAttachment
    }, [
      createVNode(_component_modal_element, mergeProps({
        name: "va-modal",
        isTransition: !_ctx.$props.withoutTransitions,
        appear: "",
        duration: 300
      }, _ctx.$attrs, {
        onBeforeEnter: _ctx.onBeforeEnterTransition,
        onAfterEnter: _ctx.onAfterEnterTransition,
        onBeforeLeave: _ctx.onBeforeLeaveTransition,
        onAfterLeave: _ctx.onAfterLeaveTransition
      }), {
        default: withCtx(() => [
          _ctx.valueComputed ? (openBlock(), createElementBlock("div", _hoisted_32, [
            _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-modal__overlay",
              style: normalizeStyle(_ctx.computedOverlayStyles),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onOutsideClick && _ctx.onOutsideClick(...args))
            }, null, 4)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "va-modal__container",
              style: normalizeStyle(_ctx.computedModalContainerStyle)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["va-modal__dialog", _ctx.computedClass]),
                style: normalizeStyle(_ctx.computedDialogStyle)
              }, [
                _ctx.$props.fullscreen ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  name: "close",
                  class: "va-modal__close",
                  role: "button",
                  "aria-label": "close",
                  "aria-hidden": "false",
                  tabindex: "0",
                  onClick: _ctx.cancel,
                  onKeydown: [
                    withKeys(_ctx.cancel, ["space"]),
                    withKeys(_ctx.cancel, ["enter"])
                  ]
                }, null, 8, ["onClick", "onKeydown"])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "va-modal__inner",
                  style: normalizeStyle({ maxWidth: _ctx.$props.maxWidth, maxHeight: _ctx.$props.maxHeight })
                }, [
                  _ctx.$slots.content ? (openBlock(), createElementBlock("div", _hoisted_42, [
                    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ cancel: _ctx.cancel, ok: _ctx.ok })))
                  ])) : createCommentVNode("", true),
                  !_ctx.$slots.content ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "va-modal__title",
                      style: normalizeStyle({ color: _ctx.getColor("primary") })
                    }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("", true),
                    _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_52, [
                      renderSlot(_ctx.$slots, "header")
                    ])) : createCommentVNode("", true),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_62, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_72, [
                      renderSlot(_ctx.$slots, "default")
                    ])) : createCommentVNode("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_8, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(_component_va_button, {
                        key: 0,
                        color: "gray",
                        class: "mr-2",
                        flat: "",
                        onClick: _ctx.cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$props.cancelText), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])) : createCommentVNode("", true),
                      createVNode(_component_va_button, { onClick: _ctx.ok }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.$props.okText), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ])) : createCommentVNode("", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_9, [
                      renderSlot(_ctx.$slots, "footer")
                    ])) : createCommentVNode("", true)
                  ], 64)) : createCommentVNode("", true)
                ], 4)
              ], 6)
            ], 4)
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["isTransition", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])
    ], 8, ["to", "disabled"]))
  ], 10, _hoisted_13);
}
var _VaModal = _export_sfc(_sfc_main5, [["render", _sfc_render5]]);
var VaModal = withConfigTransport(_VaModal);

// node_modules/vuestic-ui/dist/esm/src/components/va-modal/modal.js
init_vue_runtime_esm_bundler();
var __defProp10 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key2, value) => key2 in obj ? __defProp10(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues10 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp10.call(b2, prop))
      __defNormalProp10(a2, prop, b2[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b2)) {
      if (__propIsEnum10.call(b2, prop))
        __defNormalProp10(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps8 = (a2, b2) => __defProps8(a2, __getOwnPropDescs8(b2));
var getNodeProps2 = (vNode) => {
  var _a;
  return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props, appContext } = {}) => {
  var _a;
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props == null ? void 0 : props.onClose) == null ? void 0 : _a2.call(props, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props == null ? void 0 : props["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props, value);
    if ((props == null ? void 0 : props.withoutTransitions) && !value) {
      nextTick(() => {
        destroy2(el);
      });
    }
  };
  vNode = h(component, __spreadProps8(__spreadValues10({}, props), {
    stateful: (_a = props == null ? void 0 : props.stateful) != null ? _a : true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  }));
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps2(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-modal/plugin/index.js
var createVaModalPlugin = (app) => ({
  init(options) {
    return createModalInstance(options, app == null ? void 0 : app._context);
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaModal", createVaModalPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/utils/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app.use(plugin(...options));
  } else {
    app.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/esm/src/components/va-accordion/VaAccordion.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-accordion/hooks/useAccordion.js
init_vue_runtime_esm_bundler();
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props, state) => {
  let items2 = [];
  const onItemMounted = (item) => {
    items2.push(item);
  };
  const onItemUnmounted = (item) => {
    items2 = items2.filter((i2) => i2 !== item);
  };
  const onItemChanged = (changedItem) => {
    state.value = items2.map((item) => {
      if (item === changedItem) {
        return item.state.value;
      }
      if (!props.multiply) {
        item.state.value = false;
      }
      return item.state.value;
    });
  };
  provide(AccordionServiceKey, {
    isInsideAccordion: true,
    onItemMounted,
    onItemUnmounted,
    onItemChanged,
    props: computed(() => props)
  });
  const updateItemStates = () => {
    items2.forEach((item, index) => {
      item.state.value = state.value[index];
    });
  };
  onMounted(updateItemStates);
  watch(state, updateItemStates);
  return { items: items2 };
};
var useAccordionItem = (state) => {
  const accordion = inject(AccordionServiceKey, {
    props: ref({ inset: void 0, popout: void 0 }),
    onItemChanged: () => void 0,
    onItemMounted: () => void 0,
    onItemUnmounted: () => void 0
  });
  const item = { state };
  onMounted(() => accordion.onItemMounted(item));
  onBeforeUnmount(() => accordion.onItemUnmounted(item));
  return {
    accordionProps: accordion.props,
    toggle: () => {
      state.value = !state.value;
      accordion.onItemChanged(item);
    }
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-accordion/VaAccordion.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-accordion/VaAccordion.css";
var __defProp11 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key2, value) => key2 in obj ? __defProp11(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues11 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp11.call(b2, prop))
      __defNormalProp11(a2, prop, b2[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b2)) {
      if (__propIsEnum11.call(b2, prop))
        __defNormalProp11(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps9 = (a2, b2) => __defProps9(a2, __getOwnPropDescs9(b2));
var _sfc_main6 = defineComponent({
  name: "VaAccordion",
  emits: useStatefulEmits,
  props: __spreadProps9(__spreadValues11({}, useStatefulProps), {
    modelValue: { type: Array, default: () => [] },
    multiply: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    popout: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, []);
    const { items: items2 } = useAccordion(props, valueComputed);
    return { collapses: items2, value: valueComputed };
  }
});
var _hoisted_14 = { class: "va-accordion" };
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_14, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaAccordion = _export_sfc(_sfc_main6, [["render", _sfc_render6]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-accordion/index.js
var VaAccordion = withConfigTransport(_VaAccordion);

// node_modules/vuestic-ui/dist/esm/src/components/va-affix/VaAffix.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-affix/VaAffix-utils.js
var __defProp12 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key2, value) => key2 in obj ? __defProp12(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues12 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp12.call(b2, prop))
      __defNormalProp12(a2, prop, b2[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b2)) {
      if (__propIsEnum12.call(b2, prop))
        __defNormalProp12(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps10 = (a2, b2) => __defProps10(a2, __getOwnPropDescs10(b2));
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState(__spreadValues12({ coordinates: initialPosition }, options)) : computeAffixedState(__spreadValues12({ coordinates }, options));
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState(__spreadProps10(__spreadValues12({}, nextState), { width: coordinates.width }));
  } else if (prevState.width !== coordinates.width) {
    setState(__spreadProps10(__spreadValues12({}, prevState), { width: coordinates.width }));
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle_1((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear2) => clear2());
}

// node_modules/vuestic-ui/dist/esm/src/components/va-affix/VaAffix.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-affix/VaAffix.css";
var __defProp13 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols13 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp13 = (obj, key2, value) => key2 in obj ? __defProp13(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues13 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp13.call(b2, prop))
      __defNormalProp13(a2, prop, b2[prop]);
  if (__getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(b2)) {
      if (__propIsEnum13.call(b2, prop))
        __defNormalProp13(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps11 = (a2, b2) => __defProps11(a2, __getOwnPropDescs11(b2));
var _sfc_main7 = defineComponent({
  name: "VaAffix",
  emits: ["change"],
  props: {
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  setup(props, { emit }) {
    const element = shallowRef();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props.offsetTop;
      }
      return props.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
      }
      return props.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = __spreadProps11(__spreadValues13({}, props), {
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      });
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop_1;
    onMounted(() => {
      var _a;
      initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return {
      computedClass,
      computedStyle,
      isAffixed,
      element
    };
  }
});
var _hoisted_15 = {
  ref: "element",
  class: "va-affix"
};
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_15, [
    createBaseVNode("div", {
      style: normalizeStyle({ visibility: _ctx.isAffixed ? "hidden" : "inherit" })
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.isAffixed ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.computedClass),
      style: normalizeStyle(_ctx.computedStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)) : createCommentVNode("", true)
  ], 512);
}
var _VaAffix = _export_sfc(_sfc_main7, [["render", _sfc_render7]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-affix/index.js
var VaAffix = withConfigTransport(_VaAffix);

// node_modules/vuestic-ui/dist/esm/src/components/va-alert/VaAlert.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/services/utils.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var warn = (...attrs) => {
  return false;
};
var hasOwnProperty2 = (object, key2) => {
  return Object.prototype.hasOwnProperty.call(object, key2);
};
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject_1(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (typeof option !== "object" || !option) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}`;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-alert/useAlertStyles.js
init_vue_runtime_esm_bundler();
var useAlertStyles = (props) => {
  const { getColor } = useColors();
  const isTransparentBackground = computed(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props.color));
  const alertStyle = computed(() => {
    let background = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background = "transparent";
    }
    if (props.border) {
      background = "var(--va-white)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      background,
      boxShadow
    };
  });
  const contentStyle = computed(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border ? getColor("dark") : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-alert/VaAlert.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-alert/VaAlert.css";
var __defProp14 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols14 = Object.getOwnPropertySymbols;
var __hasOwnProp14 = Object.prototype.hasOwnProperty;
var __propIsEnum14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp14 = (obj, key2, value) => key2 in obj ? __defProp14(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues14 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp14.call(b2, prop))
      __defNormalProp14(a2, prop, b2[prop]);
  if (__getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(b2)) {
      if (__propIsEnum14.call(b2, prop))
        __defNormalProp14(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps12 = (a2, b2) => __defProps12(a2, __getOwnPropDescs12(b2));
var _sfc_main8 = defineComponent({
  name: "VaAlert",
  components: { VaIcon: VaIcon2 },
  emits: useStatefulEmits,
  props: __spreadProps12(__spreadValues14({}, useStatefulProps), {
    modelValue: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  }),
  setup(props, { slots, emit }) {
    const alertStyles = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit);
    const hide = () => {
      valueComputed.value = false;
    };
    const hasIcon = computed(() => props.icon || slots.icon);
    const hasTitle = computed(() => props.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props.border}`);
    const closeIcon = computed(() => props.closeText || "close");
    const uniqueId = computed(generateUniqueId);
    const titleIdComputed = computed(() => `aria-title-${uniqueId.value}`);
    const descriptionIdComputed = computed(() => `aria-description-${uniqueId.value}`);
    return __spreadProps12(__spreadValues14({}, alertStyles), {
      valueComputed,
      hasIcon,
      hasTitle,
      borderClass,
      closeIcon,
      hide,
      titleIdComputed,
      descriptionIdComputed
    });
  }
});
var _hoisted_16 = ["role", "aria-labelledby", "aria-describedby"];
var _hoisted_24 = ["id"];
var _hoisted_33 = ["id"];
var _hoisted_43 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_53 = ["aria-label"];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "fade"
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-alert",
        style: normalizeStyle(_ctx.alertStyle),
        role: _ctx.closeable ? "alertdialog" : "alert",
        "aria-labelledby": _ctx.titleIdComputed,
        "aria-describedby": _ctx.descriptionIdComputed
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.borderStyle),
          class: normalizeClass([_ctx.borderClass, "va-alert__border"])
        }, null, 6),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__icon",
          "aria-hidden": "true"
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, { name: _ctx.icon }, null, 8, ["name"])
          ])
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__content"
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle(_ctx.titleStyle),
            class: "va-alert__title",
            id: _ctx.titleIdComputed
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 12, _hoisted_24)) : createCommentVNode("", true),
          createBaseVNode("span", { id: _ctx.descriptionIdComputed }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.description), 1)
            ])
          ], 8, _hoisted_33)
        ], 4),
        _ctx.closeable ? (openBlock(), createElementBlock("div", _hoisted_43, [
          createBaseVNode("div", {
            style: normalizeStyle(_ctx.contentStyle),
            class: "va-alert__close--closeable",
            role: "button",
            tabindex: "0",
            "aria-label": _ctx.closeText || "close alert",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.hide()),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys(($event) => _ctx.hide(), ["space"])),
              _cache[2] || (_cache[2] = withKeys(($event) => _ctx.hide(), ["enter"]))
            ]
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              !_ctx.closeText ? (openBlock(), createBlock(_component_va_icon, {
                key: 0,
                name: _ctx.closeIcon,
                size: "small"
              }, null, 8, ["name"])) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(_ctx.closeText), 1)
            ])
          ], 44, _hoisted_53)
        ])) : createCommentVNode("", true)
      ], 12, _hoisted_16)
    ]),
    _: 3
  })) : createCommentVNode("", true);
}
var _VaAlert = _export_sfc(_sfc_main8, [["render", _sfc_render8]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-alert/index.js
var VaAlert = withConfigTransport(_VaAlert);

// node_modules/vuestic-ui/dist/esm/src/components/va-app-bar/VaAppBar.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useScroll.js
init_vue_runtime_esm_bundler();
function getTargetElement(target) {
  if (!target) {
    throw new Error("Cant find target");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(target, onScrollCallback) {
  const scrollRoot = shallowRef();
  let targetElement;
  onMounted(() => {
    targetElement = getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScrollCallback);
  });
  onBeforeUnmount(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScrollCallback);
  });
  return scrollRoot;
}

// node_modules/vuestic-ui/dist/esm/src/components/va-app-bar/VaAppBar.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-app-bar/VaAppBar.css";
var _sfc_main9 = defineComponent({
  name: "VaAppBar",
  props: {
    gradient: { type: Boolean, default: false },
    bottom: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    hideOnScroll: { type: Boolean, default: false },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: void 0 },
    absolute: { type: Boolean, default: false }
  },
  setup(props) {
    const prevScrollPosition = ref(0);
    const doShowShadow = ref(false);
    const isHidden = ref(false);
    const scrollRoot = setupScroll(props.target, (e2) => {
      const target = e2.target;
      if (prevScrollPosition.value < target.scrollTop) {
        isHidden.value = !!props.hideOnScroll;
        doShowShadow.value = !!props.shadowOnScroll;
      } else {
        isHidden.value = false;
        doShowShadow.value = false;
      }
      prevScrollPosition.value = target.scrollTop;
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color, "primary"));
    const shadowColorComputed = computed(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return doShowShadow.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const transformComputed = computed(() => {
      if (!isHidden.value) {
        return "";
      }
      return props.bottom ? "translateY(100%)" : "translateY(-100%)";
    });
    const computedStyle = computed(() => ({
      background: props.gradient ? getGradientBackground(colorComputed.value) : colorComputed.value,
      "box-shadow": computedShadow.value,
      transform: transformComputed.value,
      position: props.absolute ? "absolute" : void 0
    }));
    const computedClass = computed(() => ({
      "va-app-bar": true,
      "va-app-bar--bottom": props.bottom
    }));
    return {
      scrollRoot,
      computedStyle,
      computedClass
    };
  }
});
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    role: "toolbar",
    class: normalizeClass(_ctx.computedClass),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _VaAppBar = _export_sfc(_sfc_main9, [["render", _sfc_render9]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-app-bar/index.js
var VaAppBar = withConfigTransport(_VaAppBar);

// node_modules/vuestic-ui/dist/esm/src/components/va-avatar/VaAvatar.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-avatar/VaAvatar.css";
var __defProp15 = Object.defineProperty;
var __defProps13 = Object.defineProperties;
var __getOwnPropDescs13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols15 = Object.getOwnPropertySymbols;
var __hasOwnProp15 = Object.prototype.hasOwnProperty;
var __propIsEnum15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp15 = (obj, key2, value) => key2 in obj ? __defProp15(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues15 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp15.call(b2, prop))
      __defNormalProp15(a2, prop, b2[prop]);
  if (__getOwnPropSymbols15)
    for (var prop of __getOwnPropSymbols15(b2)) {
      if (__propIsEnum15.call(b2, prop))
        __defNormalProp15(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps13 = (a2, b2) => __defProps13(a2, __getOwnPropDescs13(b2));
var _sfc_main10 = defineComponent({
  name: "VaAvatar",
  components: { VaIcon: VaIcon2, VaProgressCircle },
  props: __spreadProps13(__spreadValues15(__spreadValues15({}, useLoadingProps), useSizeProps), {
    color: { type: String, default: "info" },
    textColor: { type: String, default: "white" },
    square: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    src: { type: String, default: null },
    alt: { type: String, default: "" },
    fontSize: { type: String, default: "" }
  }),
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: props.loading ? "transparent" : colorComputed.value,
      borderRadius: props.square ? 0 : "",
      fontSize: props.fontSize || fontSizeComputed.value,
      width: sizeComputed.value,
      minWidth: sizeComputed.value,
      height: sizeComputed.value
    }));
    return {
      sizeComputed,
      computedStyle,
      colorComputed
    };
  }
});
var _hoisted_17 = ["aria-hidden"];
var _hoisted_25 = ["src", "alt"];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: "va-avatar",
    style: normalizeStyle(_ctx.computedStyle),
    "aria-hidden": !_ctx.$props.src,
    "aria-live": "polite"
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
        key: 0,
        size: _ctx.sizeComputed,
        color: _ctx.colorComputed,
        indeterminate: ""
      }, null, 8, ["size", "color"])) : _ctx.$props.src ? (openBlock(), createElementBlock("img", {
        key: 1,
        src: _ctx.$props.src,
        alt: _ctx.$props.alt
      }, null, 8, _hoisted_25)) : _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 2,
        name: _ctx.$props.icon
      }, null, 8, ["name"])) : createCommentVNode("", true)
    ])
  ], 12, _hoisted_17);
}
var _VaAvatar = _export_sfc(_sfc_main10, [["render", _sfc_render10]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-avatar/index.js
var VaAvatar = withConfigTransport(_VaAvatar);

// node_modules/vuestic-ui/dist/esm/src/components/va-backtop/VaBacktop.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-backtop/VaBacktop.css";
var _sfc_main11 = defineComponent({
  name: "VaBacktop",
  components: { VaButton: VaButton2 },
  props: {
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    }
  },
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        return document.querySelector(props.target);
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const visible = computed(() => targetScrollValue.value > props.visibilityHeight);
    onMounted(() => {
      targetElement = getTargetElement2();
      targetElement.addEventListener("scroll", handleScroll, true);
    });
    onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    return {
      computedStyle,
      visible,
      scrollToTop
    };
  }
});
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": "back to top",
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "expand_less",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 36)) : createCommentVNode("", true);
}
var _VaBacktop = _export_sfc(_sfc_main11, [["render", _sfc_render11]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-backtop/index.js
var VaBacktop = withConfigTransport(_VaBacktop);

// node_modules/vuestic-ui/dist/esm/src/components/va-badge/VaBadge.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-badge/VaBadge.css";
var _sfc_main12 = defineComponent({
  name: "VaBadge",
  props: {
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    overlap: { type: Boolean, default: false },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    transparent: { type: Boolean, default: false },
    left: { type: Boolean, default: false },
    bottom: { type: Boolean, default: false }
  },
  setup(props, { slots }) {
    const isEmpty = computed(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed(() => slots.default || props.dot);
    const badgeClass = computed(() => ({
      "va-badge--visible-empty": props.visibleEmpty,
      "va-badge--empty": isEmpty.value,
      "va-badge--dot": props.dot,
      "va-badge--multiLine": props.multiLine,
      "va-badge--floating": isFloating.value,
      "va-badge--left": props.left,
      "va-badge--bottom": props.bottom,
      "va-badge--overlap": props.overlap
    }));
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const badgeStyle = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1
    }));
    return { badgeClass, badgeStyle };
  }
});
var _hoisted_18 = { class: "va-badge__text" };
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-badge", _ctx.badgeClass]),
    role: "alert"
  }, [
    createBaseVNode("span", {
      class: "va-badge__text-wrapper",
      style: normalizeStyle(_ctx.badgeStyle)
    }, [
      createBaseVNode("span", _hoisted_18, [
        renderSlot(_ctx.$slots, "text", {}, () => [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ])
      ])
    ], 4),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaBadge = _export_sfc(_sfc_main12, [["render", _sfc_render12]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-badge/index.js
var VaBadge = withConfigTransport(_VaBadge);

// node_modules/vuestic-ui/dist/esm/src/components/va-breadcrumbs/VaBreadcrumbs.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useAlign.js
init_vue_runtime_esm_bundler();
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-breadcrumbs/VaBreadcrumbs.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-breadcrumbs/VaBreadcrumbs.css";
var __defProp16 = Object.defineProperty;
var __defProps14 = Object.defineProperties;
var __getOwnPropDescs14 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols16 = Object.getOwnPropertySymbols;
var __hasOwnProp16 = Object.prototype.hasOwnProperty;
var __propIsEnum16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp16 = (obj, key2, value) => key2 in obj ? __defProp16(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues16 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp16.call(b2, prop))
      __defNormalProp16(a2, prop, b2[prop]);
  if (__getOwnPropSymbols16)
    for (var prop of __getOwnPropSymbols16(b2)) {
      if (__propIsEnum16.call(b2, prop))
        __defNormalProp16(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps14 = (a2, b2) => __defProps14(a2, __getOwnPropDescs14(b2));
var _sfc_main13 = defineComponent({
  name: "VaBreadcrumbs",
  props: __spreadProps14(__spreadValues16({}, useAlignProps), {
    separator: { type: String, default: "/" },
    color: { type: String, default: "gray" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null }
  }),
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : getColor(props.color);
    });
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : getColor(props.color);
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a, _b;
          return !!((_b = (_a = node2 == null ? void 0 : node2.type) == null ? void 0 : _a.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = slots.separator ? slots.separator() : [props.separator];
      return h("span", {
        ariaHidden: true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty2(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      var _a;
      const childNodes = ((_a = slots == null ? void 0 : slots.default()) == null ? void 0 : _a.reduce(childNodeFilter, [])) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty2(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h("span", {
        class: "va-breadcrumbs__item",
        ariaCurrent: isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
        style: {
          color: !isLastIndexChildNodes(index) && !isDisabledChild(child) ? computedThemesActiveColor.value : null
        }
      }, [child]);
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      ariaLabel: isAllChildLinks.value ? "breadcrumbs" : void 0
    }, getChildren());
  }
});

// node_modules/vuestic-ui/dist/esm/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.css";
var __defProp17 = Object.defineProperty;
var __defProps15 = Object.defineProperties;
var __getOwnPropDescs15 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols17 = Object.getOwnPropertySymbols;
var __hasOwnProp17 = Object.prototype.hasOwnProperty;
var __propIsEnum17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp17 = (obj, key2, value) => key2 in obj ? __defProp17(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues17 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp17.call(b2, prop))
      __defNormalProp17(a2, prop, b2[prop]);
  if (__getOwnPropSymbols17)
    for (var prop of __getOwnPropSymbols17(b2)) {
      if (__propIsEnum17.call(b2, prop))
        __defNormalProp17(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps15 = (a2, b2) => __defProps15(a2, __getOwnPropDescs15(b2));
var _sfc_main14 = defineComponent({
  name: "VaBreadcrumbsItem",
  props: __spreadProps15(__spreadValues17({}, useRouterLinkProps), {
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  }),
  setup: (props) => {
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return { tagComputed, hrefComputed, classComputed };
  }
});
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-breadcrumb-item", _ctx.classComputed]),
    "active-class": _ctx.$props.activeClass,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to,
    target: _ctx.$props.target,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ]),
    _: 3
  }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
}
var _VaBreadcrumbsItem = _export_sfc(_sfc_main14, [["render", _sfc_render13]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-breadcrumbs/index.js
var VaBreadcrumbsItem = withConfigTransport(_VaBreadcrumbsItem);
var VaBreadcrumbs = withConfigTransport(_sfc_main13);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-dropdown/VaButtonDropdown.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useEmitProxy.js
var __defProp18 = Object.defineProperty;
var __defProps16 = Object.defineProperties;
var __getOwnPropDescs16 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols18 = Object.getOwnPropertySymbols;
var __hasOwnProp18 = Object.prototype.hasOwnProperty;
var __propIsEnum18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp18 = (obj, key2, value) => key2 in obj ? __defProp18(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues18 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp18.call(b2, prop))
      __defNormalProp18(a2, prop, b2[prop]);
  if (__getOwnPropSymbols18)
    for (var prop of __getOwnPropSymbols18(b2)) {
      if (__propIsEnum18.call(b2, prop))
        __defNormalProp18(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps16 = (a2, b2) => __defProps16(a2, __getOwnPropDescs16(b2));
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key2) => __spreadProps16(__spreadValues18({}, acc), {
      [eventToListenerName(getEvent(key2))]: (...args) => emit(getEmit(key2), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key2) => __spreadProps16(__spreadValues18({}, acc), {
      [getEvent(key2)]: (...args) => emit(getEmit(key2), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/VaDropdown.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useBem.js
init_vue_runtime_esm_bundler();
var useBem = (prefix2, modifiers) => {
  const modifiersList = computed(() => isFunction_1(modifiers) ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${kebabCase_1(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_2, key2) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key2);
    },
    get(_2, key2, receiver) {
      switch (key2) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key2, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/esm/src/composables/useClickOutside.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useCaptureEvent.js
init_vue_runtime_esm_bundler();
var __defProp19 = Object.defineProperty;
var __getOwnPropSymbols19 = Object.getOwnPropertySymbols;
var __hasOwnProp19 = Object.prototype.hasOwnProperty;
var __propIsEnum19 = Object.prototype.propertyIsEnumerable;
var __defNormalProp19 = (obj, key2, value) => key2 in obj ? __defProp19(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues19 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp19.call(b2, prop))
      __defNormalProp19(a2, prop, b2[prop]);
  if (__getOwnPropSymbols19)
    for (var prop of __getOwnPropSymbols19(b2)) {
      if (__propIsEnum19.call(b2, prop))
        __defNormalProp19(a2, prop, b2[prop]);
    }
  return a2;
};
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, __spreadValues19({ capture: true }, options)));
  onBeforeUnmount(() => window.removeEventListener(event, cb, __spreadValues19({ capture: true }, options)));
};

// node_modules/vuestic-ui/dist/esm/src/composables/useClickOutside.js
var checkIfElementChild = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray = (a2) => Array.isArray(a2) ? a2 : [a2];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("click", (event) => {
    const clickTarget = event.target;
    const isClickInside = safeArray(elements).some((element) => unref(element) && checkIfElementChild(unref(element), clickTarget));
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};

// node_modules/vuestic-ui/dist/esm/src/composables/useDebounce.js
init_vue_runtime_esm_bundler();
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce_1(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useHTMLElement.js
init_vue_runtime_esm_bundler();
var extractHTMLElement = (el) => el && "$el" in el ? el.$el : el;
var useTemplateRef = (key2) => {
  const vm = getCurrentInstance();
  const el = shallowRef();
  const updateEl = () => {
    var _a;
    el.value = (_a = vm.proxy) == null ? void 0 : _a.$refs[key2];
  };
  onMounted(updateEl);
  onUpdated(updateEl);
  onBeforeUnmount(updateEl);
  return el;
};
var useHTMLElement = (key2) => {
  if (isRef(key2)) {
    return computed({
      get() {
        return extractHTMLElement(key2.value);
      },
      set(value) {
        key2.value = value;
      }
    });
  }
  if (key2) {
    const el2 = useTemplateRef(key2);
    return computed({
      get() {
        return extractHTMLElement(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef();
  return computed({
    set(value) {
      el.value = extractHTMLElement(value);
    },
    get() {
      return el.value;
    }
  });
};

// node_modules/vuestic-ui/dist/esm/src/composables/useIsMounted.js
init_vue_runtime_esm_bundler();
var useIsMounted = () => {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  onBeforeUnmount(() => {
    isMounted.value = false;
  });
  return isMounted;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/hooks/useAnchorSelector.js
init_vue_runtime_esm_bundler();
var useAnchorSelector = (props) => {
  const anchorRef = ref();
  const document2 = useDocument();
  const computedAnchorRef = computed({
    set(v2) {
      anchorRef.value = v2;
    },
    get() {
      var _a, _b, _c, _d;
      if (props.anchorSelector) {
        return (_b = (_a = document2.value) == null ? void 0 : _a.querySelector(props.anchorSelector)) != null ? _b : anchorRef.value;
      } else if (props.innerAnchorSelector && anchorRef.value) {
        return (_d = (_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) != null ? _d : anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/hooks/useCursorAnchor.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useEvent.js
init_vue_runtime_esm_bundler();
var useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useClientOnly(() => window);
  const capture = typeof target === "boolean" ? target : false;
  watch(source, (newValue, oldValue) => {
    var _a, _b;
    if (!Array.isArray(event)) {
      (_a = unref(newValue)) == null ? void 0 : _a.addEventListener(event, listener, capture);
      (_b = unref(oldValue)) == null ? void 0 : _b.removeEventListener(event, listener, capture);
    } else {
      event.forEach((e2) => {
        var _a2, _b2;
        (_a2 = unref(newValue)) == null ? void 0 : _a2.addEventListener(e2, listener, capture);
        (_b2 = unref(oldValue)) == null ? void 0 : _b2.removeEventListener(e2, listener, capture);
      });
    }
  }, { immediate: true });
};

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/hooks/useCursorAnchor.js
var __defProp20 = Object.defineProperty;
var __defProps17 = Object.defineProperties;
var __getOwnPropDescs17 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols20 = Object.getOwnPropertySymbols;
var __hasOwnProp20 = Object.prototype.hasOwnProperty;
var __propIsEnum20 = Object.prototype.propertyIsEnumerable;
var __defNormalProp20 = (obj, key2, value) => key2 in obj ? __defProp20(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues20 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp20.call(b2, prop))
      __defNormalProp20(a2, prop, b2[prop]);
  if (__getOwnPropSymbols20)
    for (var prop of __getOwnPropSymbols20(b2)) {
      if (__propIsEnum20.call(b2, prop))
        __defNormalProp20(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps17 = (a2, b2) => __defProps17(a2, __getOwnPropDescs17(b2));
var useCursorAnchor = (anchorRef, noUpdate) => {
  const mouse = reactive({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e2) => {
    const { x: x2, y: y2 } = anchorRef.value.getBoundingClientRect();
    mouse.x = e2.clientX - x2;
    mouse.y = e2.clientY - y2;
  }, anchorRef);
  const mouseOffset = {
    x: 0,
    y: 0
  };
  watchEffect(() => {
    if (noUpdate.value) {
      return;
    }
    mouseOffset.x = mouse.x;
    mouseOffset.y = mouse.y;
  });
  return computed(() => {
    if (!anchorRef.value) {
      return void 0;
    }
    const target = anchorRef.value;
    const getBoundingClientRect = () => {
      const rect = target.getBoundingClientRect();
      const x2 = rect.left + mouseOffset.x;
      const y2 = rect.top + mouseOffset.y;
      return __spreadProps17(__spreadValues20({}, rect), {
        x: x2,
        y: y2,
        bottom: y2 + 1,
        right: x2 + 1,
        left: x2,
        top: y2
      });
    };
    return new Proxy(target, {
      get(target2, key2) {
        if (key2 === "getBoundingClientRect") {
          return getBoundingClientRect;
        }
        return target2[key2];
      }
    });
  });
};

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/hooks/useDropdownNavigation.js
init_vue_runtime_esm_bundler();
var isTyping = (e2) => {
  const target = e2.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
var openKey = ["ArrowDown", "ArrowUp", "Enter", "Space"];
var useKeyboardNavigation = (anchorRef, isOpened) => {
  useEvent("keydown", (e2) => {
    if (isTyping(e2)) {
      return;
    }
    if (!openKey.includes(e2.key)) {
      return;
    }
    isOpened.value = !isOpened.value;
    e2.preventDefault();
  }, anchorRef);
  useEvent("keydown", (e2) => {
    if (e2.key === "Escape" && isOpened.value) {
      isOpened.value = false;
      e2.preventDefault();
    }
  }, true);
};
var useMouseNavigation = (anchorRef, listeners) => {
  useEvent(["click", "contextmenu", "dblclick"], (e2) => {
    if (isTyping(e2)) {
      return;
    }
    listeners[e2.type](e2);
  }, anchorRef);
  useEvent(["mouseleave", "mouseenter"], (e2) => {
    listeners[e2.type](e2);
  }, anchorRef);
};

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/VaDropdown.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/VaDropdown.css";
var __defProp21 = Object.defineProperty;
var __defProps18 = Object.defineProperties;
var __getOwnPropDescs18 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols21 = Object.getOwnPropertySymbols;
var __hasOwnProp21 = Object.prototype.hasOwnProperty;
var __propIsEnum21 = Object.prototype.propertyIsEnumerable;
var __defNormalProp21 = (obj, key2, value) => key2 in obj ? __defProp21(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues21 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp21.call(b2, prop))
      __defNormalProp21(a2, prop, b2[prop]);
  if (__getOwnPropSymbols21)
    for (var prop of __getOwnPropSymbols21(b2)) {
      if (__propIsEnum21.call(b2, prop))
        __defNormalProp21(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps18 = (a2, b2) => __defProps18(a2, __getOwnPropDescs18(b2));
var _sfc_main15 = defineComponent({
  name: "VaDropdown",
  props: __spreadProps18(__spreadValues21({}, useStatefulProps), {
    stateful: { default: true },
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    target: { type: String, default: void 0 },
    preventOverflow: { type: Boolean, default: false },
    keepAnchorWidth: { type: Boolean, default: false },
    isContentHoverable: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    offset: { type: [Array, Number], default: 0 },
    stickToEdges: { type: Boolean, default: false },
    autoPlacement: { type: Boolean, default: true },
    cursor: { type: Boolean, default: false },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    placement: {
      type: String,
      default: "auto",
      validator: (value) => placementsPositions.includes(value)
    },
    keyboardNavigation: { type: Boolean, default: false }
  }),
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "close", "open"],
  setup(props, { emit }) {
    const contentRef = shallowRef();
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const computedClass = useBem("va-dropdown", () => pick_1(props, ["disabled"]));
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onMouseEnter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseLeave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    const emitAndClose = (eventName, close, e2) => {
      emit(eventName, e2);
      if (close && props.trigger !== "none") {
        valueComputed.value = false;
      }
    };
    const elRef = useHTMLElement("anchorRef");
    if (props.keyboardNavigation) {
      useKeyboardNavigation(elRef, valueComputed);
    }
    useMouseNavigation(elRef, {
      click(e2) {
        if (props.trigger !== "click" && kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-click", props.closeOnAnchorClick, e2);
        } else {
          if (props.trigger !== "click") {
            return;
          }
          valueComputed.value = true;
          emit("anchor-click", e2);
        }
      },
      contextmenu(e2) {
        if (kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        e2.preventDefault();
        if (valueComputed.value) {
          emitAndClose("anchor-right-click", props.closeOnAnchorClick, e2);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-right-click", e2);
        }
      },
      dblclick(e2) {
        if (props.trigger !== "dblclick" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-dblclick", props.closeOnAnchorClick, e2);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-dblclick", e2);
        }
      },
      mouseenter: onMouseEnter,
      mouseleave: onMouseLeave
    });
    const { anchorRef: computedAnchorRef } = useAnchorSelector(props);
    useClickOutside([computedAnchorRef, contentRef], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    const cursorAnchor = useCursorAnchor(computedAnchorRef, valueComputed);
    useDropdown(computed(() => props.cursor ? cursorAnchor.value : computedAnchorRef.value), contentRef, computed(() => ({
      placement: props.placement,
      keepAnchorWidth: props.keepAnchorWidth,
      offset: props.offset,
      stickToEdges: props.stickToEdges,
      autoPlacement: props.autoPlacement,
      root: teleportTargetComputed.value,
      viewport: targetComputed.value
    })));
    const idComputed = computed(generateUniqueId);
    const document2 = useDocument();
    const isPopoverFloating = computed(() => props.preventOverflow || props.cursor);
    const targetComputed = computed(() => {
      var _a, _b, _c;
      const target = (_a = document2.value) == null ? void 0 : _a.querySelector(props.target || "body");
      if (!target) {
        return (_b = document2.value) == null ? void 0 : _b.body;
      }
      if (computedAnchorRef.value && !target.contains(computedAnchorRef.value)) {
        return (_c = document2.value) == null ? void 0 : _c.body;
      }
      return target;
    });
    const teleportTargetComputed = computed(() => {
      if (!isPopoverFloating.value) {
        return elRef.value;
      }
      return targetComputed.value;
    });
    const teleportDisabled = computed(() => props.disabled || !isPopoverFloating.value);
    return {
      teleportTargetComputed,
      teleportDisabled,
      isMounted: useIsMounted(),
      anchorRef: computedAnchorRef,
      valueComputed,
      contentRef,
      computedClass,
      idComputed,
      emitAndClose,
      onMouseEnter,
      onMouseLeave,
      hide: () => {
        valueComputed.value = false;
      },
      show: () => {
        valueComputed.value = true;
      }
    };
  }
});
var _hoisted_19 = ["aria-disabled", "aria-expanded", "aria-controls"];
var _hoisted_26 = ["id"];
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-dropdown", _ctx.computedClass]),
    ref: "anchorRef",
    role: "button",
    "aria-label": "toggle dropdown",
    "aria-disabled": _ctx.$props.disabled,
    "aria-expanded": !!_ctx.valueComputed,
    "aria-controls": _ctx.idComputed
  }, [
    renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show }))),
    _ctx.isMounted ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.teleportTargetComputed,
      disabled: _ctx.teleportDisabled
    }, [
      _ctx.valueComputed ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "contentRef",
        class: "va-dropdown__content-wrapper",
        id: _ctx.idComputed,
        onMouseover: _cache[0] || (_cache[0] = ($event) => _ctx.$props.isContentHoverable && _ctx.onMouseEnter()),
        onMouseout: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.emitAndClose("content-click", _ctx.closeOnContentClick), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show })))
      ], 40, _hoisted_26)) : createCommentVNode("", true)
    ], 8, ["to", "disabled"])) : createCommentVNode("", true)
  ], 10, _hoisted_19);
}
var _VaDropdown = _export_sfc(_sfc_main15, [["render", _sfc_render14]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.css";
var _sfc_main16 = defineComponent({
  name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "white" },
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return { computedStyle };
  }
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-dropdown__content",
    style: normalizeStyle(_ctx.computedStyle),
    role: "listbox"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaDropdownContent = _export_sfc(_sfc_main16, [["render", _sfc_render15]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/components/VaDropdownContent/index.js
var VaDropdownContent = withConfigTransport(_VaDropdownContent);

// node_modules/vuestic-ui/dist/esm/src/components/va-dropdown/index.js
var VaDropdown = withConfigTransport(_VaDropdown);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-group/VaButtonGroup.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-button-group/VaButtonGroup.css";
var __defProp22 = Object.defineProperty;
var __defProps19 = Object.defineProperties;
var __getOwnPropDescs19 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp22 = (obj, key2, value) => key2 in obj ? __defProp22(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues22 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp22.call(b2, prop))
      __defNormalProp22(a2, prop, b2[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b2)) {
      if (__propIsEnum22.call(b2, prop))
        __defNormalProp22(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps19 = (a2, b2) => __defProps19(a2, __getOwnPropDescs19(b2));
var _sfc_main17 = defineComponent({
  name: "VaButtonGroup",
  components: { VaConfig },
  props: {
    color: { type: String, default: "primary" },
    gradient: { type: Boolean, default: void 0 },
    textColor: { type: String, default: void 0 },
    rounded: { type: Boolean, default: true },
    outline: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  setup(props) {
    const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const computedBackground = computed(() => {
      if (props.outline || props.flat) {
        return "";
      }
      return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
    });
    const computedStyle = computed(() => {
      const backgroundProperty = props.gradient ? "background-image" : "background";
      return {
        [backgroundProperty]: computedBackground.value,
        color: textColorComputed.value
      };
    });
    const buttonConfig = computed(() => ({
      VaButton: __spreadProps19(__spreadValues22({}, props), {
        color: props.gradient ? "#00000000" : props.color,
        textColor: textColorComputed.value
      })
    }));
    const computedClass = computed(() => ({ "va-button-group_square": !props.rounded }));
    return {
      buttonConfig,
      computedStyle,
      computedClass
    };
  }
});
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-group", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    createVNode(_component_va_config, { components: _ctx.buttonConfig }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["components"])
  ], 6);
}
var _VaButtonGroup = _export_sfc(_sfc_main17, [["render", _sfc_render16]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-group/index.js
var VaButtonGroup = withConfigTransport(_VaButtonGroup);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-dropdown/VaButtonDropdown.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-button-dropdown/VaButtonDropdown.css";
var __defProp23 = Object.defineProperty;
var __defProps20 = Object.defineProperties;
var __getOwnPropDescs20 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols23 = Object.getOwnPropertySymbols;
var __hasOwnProp23 = Object.prototype.hasOwnProperty;
var __propIsEnum23 = Object.prototype.propertyIsEnumerable;
var __defNormalProp23 = (obj, key2, value) => key2 in obj ? __defProp23(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues23 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp23.call(b2, prop))
      __defNormalProp23(a2, prop, b2[prop]);
  if (__getOwnPropSymbols23)
    for (var prop of __getOwnPropSymbols23(b2)) {
      if (__propIsEnum23.call(b2, prop))
        __defNormalProp23(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps20 = (a2, b2) => __defProps20(a2, __getOwnPropDescs20(b2));
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy([{ listen: "click", emit: "main-button-click" }]);
var componentName = "VaButtonDropdown";
var _sfc_main18 = defineComponent({
  name: componentName,
  components: {
    VaButtonGroup,
    VaButton: VaButton2,
    VaDropdown,
    VaDropdownContent
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  props: __spreadProps20(__spreadValues23({}, useStatefulProps), {
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    outline: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    gradient: { type: Boolean, default: void 0 },
    icon: { type: String, default: "expand_more" },
    openedIcon: { type: String, default: "expand_less" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => placementsPositions.includes(placement)
    },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String }
  }),
  setup(props, { emit, slots }) {
    const { valueComputed } = useStateful(props, emit);
    const computedIcon = computed(() => {
      return valueComputed.value ? props.openedIcon : props.icon;
    });
    const computedClass = computed(() => ({
      "va-button-dropdown": true,
      "va-button-dropdown--split": props.split,
      "va-button-dropdown--normal": props.size === "medium",
      "va-button-dropdown--large": props.size === "large",
      "va-button-dropdown--small": props.size === "small"
    }));
    const computedButtonIcons = computed(() => {
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return props.hideIcon ? {} : { [propName]: computedIcon.value };
    });
    const computedViewStyles = computed(() => pick_1(props, ["outline", "gradient", "rounded", "flat", "size", "color"]));
    const computedMainButtonProps = computed(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    return {
      hideDropdown,
      valueComputed,
      computedIcon,
      computedClass,
      listeners: createListeners(emit),
      mainButtonListeners: createMainButtonListeners(emit),
      computedButtonIcons,
      computedViewStyles,
      computedMainButtonProps
    };
  }
});
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.computedClass)
  }, [
    !_ctx.$props.split ? (openBlock(), createBlock(_component_va_dropdown, {
      key: 0,
      disabled: _ctx.$props.disabled,
      placement: _ctx.$props.placement,
      offset: _ctx.$props.offset,
      "keep-anchor-width": _ctx.$props.keepAnchorWidth,
      "close-on-content-click": _ctx.$props.closeOnContentClick,
      stateful: _ctx.$props.stateful,
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event)
    }, {
      anchor: withCtx(() => [
        createVNode(_component_va_button, mergeProps({
          disabled: _ctx.$props.disabled,
          round: !_ctx.$props.label && !_ctx.$slots.label
        }, __spreadValues23(__spreadValues23({}, _ctx.computedButtonIcons), _ctx.computedViewStyles), toHandlers(_ctx.listeners), {
          onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled", "round", "onKeydown"])
      ]),
      default: withCtx(() => [
        createVNode(_component_va_dropdown_content, null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["disabled", "placement", "offset", "keep-anchor-width", "close-on-content-click", "stateful", "modelValue"])) : (openBlock(), createBlock(_component_va_button_group, mergeProps({
      key: 1,
      class: { "va-button-group__left-icon": _ctx.$props.leftIcon }
    }, _ctx.computedViewStyles), {
      default: withCtx(() => [
        !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 0,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true),
        createVNode(_component_va_dropdown, {
          disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
          placement: _ctx.$props.placement,
          offset: _ctx.$props.offset,
          stateful: _ctx.$props.stateful,
          modelValue: _ctx.valueComputed,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
        }, {
          anchor: withCtx(() => [
            createVNode(_component_va_button, mergeProps({
              "aria-label": "toggle dropdown",
              disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
              icon: _ctx.computedIcon
            }, toHandlers(_ctx.listeners), {
              onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
            }), null, 16, ["disabled", "icon", "onKeydown"])
          ]),
          default: withCtx(() => [
            createVNode(_component_va_dropdown_content, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["disabled", "placement", "offset", "stateful", "modelValue"]),
        _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 1,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["class"]))
  ], 2);
}
var _VaButtonDropdown = _export_sfc(_sfc_main18, [["render", _sfc_render17]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-dropdown/index.js
var VaButtonDropdown = withConfigTransport(_VaButtonDropdown);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-toggle/VaButtonToggle.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-button-toggle/VaButtonToggle.css";
var __defProp24 = Object.defineProperty;
var __getOwnPropSymbols24 = Object.getOwnPropertySymbols;
var __hasOwnProp24 = Object.prototype.hasOwnProperty;
var __propIsEnum24 = Object.prototype.propertyIsEnumerable;
var __defNormalProp24 = (obj, key2, value) => key2 in obj ? __defProp24(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues24 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp24.call(b2, prop))
      __defNormalProp24(a2, prop, b2[prop]);
  if (__getOwnPropSymbols24)
    for (var prop of __getOwnPropSymbols24(b2)) {
      if (__propIsEnum24.call(b2, prop))
        __defNormalProp24(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main19 = defineComponent({
  name: "VaButtonToggle",
  components: {
    VaButtonGroup,
    VaButton: VaButton2
  },
  emits: ["update:modelValue"],
  props: {
    options: {
      type: Array,
      required: true
    },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    activeButtonTextColor: { type: String },
    modelValue: { type: [String, Number], default: "" },
    outline: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    toggleColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isFlatOrOutline = computed(() => props.outline || props.flat);
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      } else {
        return isFlatOrOutline.value ? colorComputed.value : shiftHSLAColor(colorComputed.value, { l: -6 });
      }
    });
    const { textColorComputed: activeButtonTextColor } = useTextColor(activeButtonColor);
    const isToggled = (value) => value === props.modelValue;
    const getButtonProps = (option = {}) => {
      var _a;
      const iconsProps = {
        icon: option.icon,
        iconRight: option.iconRight
      };
      if (!isToggled(option.value)) {
        return iconsProps;
      }
      return __spreadValues24(__spreadValues24({
        color: activeButtonColor.value,
        textColor: (_a = props.activeButtonTextColor) != null ? _a : activeButtonTextColor.value
      }, iconsProps), isFlatOrOutline.value && { outline: false, flat: false });
    };
    const getButtonClass = (buttonValue) => ({ "va-button--active": isToggled(buttonValue) });
    const changeValue = (value) => emit("update:modelValue", value);
    return {
      getButtonProps,
      getButtonClass,
      changeValue,
      isToggled
    };
  }
});
var _hoisted_110 = { class: "va-button-toggle" };
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", _hoisted_110, [
    createVNode(_component_va_button_group, {
      color: _ctx.color,
      textColor: _ctx.textColor,
      rounded: _ctx.rounded,
      outline: _ctx.outline,
      flat: _ctx.flat,
      gradient: _ctx.gradient
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
          return openBlock(), createBlock(_component_va_button, mergeProps({
            key: option.value,
            "aria-pressed": _ctx.isToggled(option.value),
            class: _ctx.getButtonClass(option.value),
            disabled: _ctx.disabled,
            size: _ctx.size
          }, _ctx.getButtonProps(option), {
            onClick: ($event) => _ctx.changeValue(option.value)
          }), {
            default: withCtx(() => [
              createTextVNode(toDisplayString(option.label), 1)
            ]),
            _: 2
          }, 1040, ["aria-pressed", "class", "disabled", "size", "onClick"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["color", "textColor", "rounded", "outline", "flat", "gradient"])
  ]);
}
var _VaButtonToggle = _export_sfc(_sfc_main19, [["render", _sfc_render18]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-button-toggle/index.js
var VaButtonToggle = withConfigTransport(_VaButtonToggle);

// node_modules/vuestic-ui/dist/esm/src/components/va-card/VaCard.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-card/VaCard.css";
var __defProp25 = Object.defineProperty;
var __defProps21 = Object.defineProperties;
var __getOwnPropDescs21 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols25 = Object.getOwnPropertySymbols;
var __hasOwnProp25 = Object.prototype.hasOwnProperty;
var __propIsEnum25 = Object.prototype.propertyIsEnumerable;
var __defNormalProp25 = (obj, key2, value) => key2 in obj ? __defProp25(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues25 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp25.call(b2, prop))
      __defNormalProp25(a2, prop, b2[prop]);
  if (__getOwnPropSymbols25)
    for (var prop of __getOwnPropSymbols25(b2)) {
      if (__propIsEnum25.call(b2, prop))
        __defNormalProp25(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps21 = (a2, b2) => __defProps21(a2, __getOwnPropDescs21(b2));
var _sfc_main20 = defineComponent({
  name: "VaCard",
  emits: ["click"],
  props: __spreadProps21(__spreadValues25({}, useRouterLinkProps), {
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "white" }
  }),
  setup(props) {
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor();
    const stripeStyles = computed(() => ({ background: getColor(props.stripeColor) }));
    const cardClasses = computed(() => ({
      "va-card--square": props.square,
      "va-card--outlined": props.outlined,
      "va-card--no-border": !props.bordered,
      "va-card--disabled": props.disabled,
      "va-card--link": isLinkTag.value
    }));
    const cardStyles = computed(() => {
      if (props.gradient && props.color) {
        return {
          background: getGradientBackground(getColor(props.color)),
          color: textColorComputed.value
        };
      }
      return { background: getColor(props.color), color: textColorComputed.value };
    });
    return {
      cardClasses,
      cardStyles,
      stripeStyles,
      tagComputed,
      hrefComputed
    };
  }
});
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-card", _ctx.cardClasses]),
    style: normalizeStyle(_ctx.cardStyles),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass
  }, {
    default: withCtx(() => [
      _ctx.stripe ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-card__stripe",
        style: normalizeStyle(_ctx.stripeStyles)
      }, null, 4)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: "va-card__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, [
        renderSlot(_ctx.$slots, "default")
      ])
    ]),
    _: 3
  }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
}
var _VaCard = _export_sfc(_sfc_main20, [["render", _sfc_render19]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-card/VaCardContent.js
init_vue_runtime_esm_bundler();
var _sfc_main21 = defineComponent({
  name: "VaCardContent"
});
var _hoisted_111 = { class: "va-card__content" };
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_111, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VaCardContentBase = _export_sfc(_sfc_main21, [["render", _sfc_render20]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-card/VaCardTitle.js
init_vue_runtime_esm_bundler();
var _sfc_main22 = defineComponent({
  name: "VaCardTitle",
  props: {
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      titleStyles: computed(() => ({
        color: props.textColor ? getColor(props.textColor) : ""
      }))
    };
  }
});
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-card__title",
    style: normalizeStyle(_ctx.titleStyles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var VaCardTitleBase = _export_sfc(_sfc_main22, [["render", _sfc_render21]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-card/VaCardActions.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-card/VaCardActions.css";
var __defProp26 = Object.defineProperty;
var __getOwnPropSymbols26 = Object.getOwnPropertySymbols;
var __hasOwnProp26 = Object.prototype.hasOwnProperty;
var __propIsEnum26 = Object.prototype.propertyIsEnumerable;
var __defNormalProp26 = (obj, key2, value) => key2 in obj ? __defProp26(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues26 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp26.call(b2, prop))
      __defNormalProp26(a2, prop, b2[prop]);
  if (__getOwnPropSymbols26)
    for (var prop of __getOwnPropSymbols26(b2)) {
      if (__propIsEnum26.call(b2, prop))
        __defNormalProp26(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main23 = defineComponent({
  name: "VaCardActions",
  props: __spreadValues26({}, useAlignProps),
  setup(props) {
    const { alignComputed } = useAlign(props);
    return {
      alignComputed
    };
  }
});
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.vertical ? "va-card__actions_vertical" : "va-card__actions"]),
    style: normalizeStyle(_ctx.alignComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var VaCardActionsBase = _export_sfc(_sfc_main23, [["render", _sfc_render22]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-card/index.js
var VaCardContent = withConfigTransport(VaCardContentBase);
var VaCardTitle = withConfigTransport(VaCardTitleBase);
var VaCardActions = withConfigTransport(VaCardActionsBase);
var VaCard = withConfigTransport(_VaCard);

// node_modules/vuestic-ui/dist/esm/src/components/va-carousel/VaCarousel.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-carousel/hooks/useCarousel.js
init_vue_runtime_esm_bundler();
var useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    goTo,
    prev,
    next
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-carousel/hooks/useCarouselAnimation.js
init_vue_runtime_esm_bundler();
var __defProp27 = Object.defineProperty;
var __defProps22 = Object.defineProperties;
var __getOwnPropDescs22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols27 = Object.getOwnPropertySymbols;
var __hasOwnProp27 = Object.prototype.hasOwnProperty;
var __propIsEnum27 = Object.prototype.propertyIsEnumerable;
var __defNormalProp27 = (obj, key2, value) => key2 in obj ? __defProp27(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues27 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp27.call(b2, prop))
      __defNormalProp27(a2, prop, b2[prop]);
  if (__getOwnPropSymbols27)
    for (var prop of __getOwnPropSymbols27(b2)) {
      if (__propIsEnum27.call(b2, prop))
        __defNormalProp27(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps22 = (a2, b2) => __defProps22(a2, __getOwnPropDescs22(b2));
var useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  let direction = 1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      if (props.infinite) {
        currentSlide.value += 1;
        if (currentSlide.value >= props.items.length) {
          currentSlide.value = 0;
        }
      } else {
        if (currentSlide.value <= 0) {
          direction = 1;
        }
        if (currentSlide.value >= props.items.length - 1) {
          direction = -1;
        }
        currentSlide.value += direction;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props.effect === "fade") {
      return __spreadProps22(__spreadValues27({}, slidesContainerStyle.value), {
        transition: "none"
      });
    }
    if (props.vertical) {
      return __spreadProps22(__spreadValues27({}, slidesContainerStyle.value), {
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      });
    }
    return __spreadProps22(__spreadValues27({}, slidesContainerStyle.value), {
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    });
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last2 = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last2) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last2 && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-carousel/hooks/useCarouselColors.js
init_vue_runtime_esm_bundler();
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("dark"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-image/VaImage.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-image/VaImage.css";
var _sfc_main24 = defineComponent({
  name: "VaImage",
  emits: ["loaded", "error"],
  props: {
    ratio: { type: Number, default: 1 },
    contain: { type: Boolean, default: false },
    src: { type: String, required: true },
    alt: { type: String, default: "" }
  },
  setup(props, { emit }) {
    const loading = ref(true);
    const loadingError = ref(false);
    const imageStyles = computed(() => ({
      objectFit: props.contain ? "contain" : "cover"
    }));
    const paddingStyles = computed(() => ({
      paddingBottom: `${1 / props.ratio * 100}%`
    }));
    const handleLoad = () => {
      loading.value = false;
      emit("loaded", props.src);
    };
    const handleError = (err) => {
      loadingError.value = true;
      loading.value = false;
      emit("error", err);
    };
    watch(() => props.src, () => {
      loading.value = true;
      loadingError.value = false;
    });
    return {
      loading,
      loadingError,
      imageStyles,
      paddingStyles,
      handleLoad,
      handleError
    };
  }
});
var _hoisted_112 = {
  class: "va-image",
  "aria-live": "polite"
};
var _hoisted_27 = {
  key: 0,
  class: "va-image__error"
};
var _hoisted_34 = { class: "va-image__img" };
var _hoisted_44 = ["src", "alt"];
var _hoisted_54 = { class: "va-image__overlay" };
var _hoisted_63 = {
  key: 1,
  class: "va-image__loader"
};
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_112, [
    _ctx.loadingError ? (openBlock(), createElementBlock("div", _hoisted_27, [
      renderSlot(_ctx.$slots, "error")
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      style: normalizeStyle(_ctx.paddingStyles)
    }, null, 4),
    withDirectives(createBaseVNode("div", _hoisted_34, [
      createBaseVNode("img", {
        style: normalizeStyle(_ctx.imageStyles),
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
        onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
      }, null, 44, _hoisted_44)
    ], 512), [
      [vShow, !_ctx.loadingError && !_ctx.loading]
    ]),
    createBaseVNode("div", _hoisted_54, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.loading ? (openBlock(), createElementBlock("div", _hoisted_63, [
      renderSlot(_ctx.$slots, "loader")
    ])) : createCommentVNode("", true)
  ]);
}
var _VaImage = _export_sfc(_sfc_main24, [["render", _sfc_render23]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-image/index.js
var VaImage = withConfigTransport(_VaImage);

// node_modules/vuestic-ui/dist/esm/src/components/va-hover/VaHover.js
init_vue_runtime_esm_bundler();
var __defProp28 = Object.defineProperty;
var __defProps23 = Object.defineProperties;
var __getOwnPropDescs23 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols28 = Object.getOwnPropertySymbols;
var __hasOwnProp28 = Object.prototype.hasOwnProperty;
var __propIsEnum28 = Object.prototype.propertyIsEnumerable;
var __defNormalProp28 = (obj, key2, value) => key2 in obj ? __defProp28(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues28 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp28.call(b2, prop))
      __defNormalProp28(a2, prop, b2[prop]);
  if (__getOwnPropSymbols28)
    for (var prop of __getOwnPropSymbols28(b2)) {
      if (__propIsEnum28.call(b2, prop))
        __defNormalProp28(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps23 = (a2, b2) => __defProps23(a2, __getOwnPropDescs23(b2));
var _sfc_main25 = defineComponent({
  name: "VaHover",
  props: __spreadProps23(__spreadValues28({}, useStatefulProps), {
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  }),
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return { onMouseEnter, onMouseLeave, valueComputed };
  }
});
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-hover",
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ hover: _ctx.valueComputed })))
  ], 32);
}
var _VaHover = _export_sfc(_sfc_main25, [["render", _sfc_render24]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-hover/index.js
var VaHover = withConfigTransport(_VaHover);

// node_modules/vuestic-ui/dist/esm/src/components/va-carousel/VaCarousel.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-carousel/VaCarousel.css";
var __defProp29 = Object.defineProperty;
var __defProps24 = Object.defineProperties;
var __getOwnPropDescs24 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols29 = Object.getOwnPropertySymbols;
var __hasOwnProp29 = Object.prototype.hasOwnProperty;
var __propIsEnum29 = Object.prototype.propertyIsEnumerable;
var __defNormalProp29 = (obj, key2, value) => key2 in obj ? __defProp29(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues29 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp29.call(b2, prop))
      __defNormalProp29(a2, prop, b2[prop]);
  if (__getOwnPropSymbols29)
    for (var prop of __getOwnPropSymbols29(b2)) {
      if (__propIsEnum29.call(b2, prop))
        __defNormalProp29(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps24 = (a2, b2) => __defProps24(a2, __getOwnPropDescs24(b2));
var _sfc_main26 = defineComponent({
  name: "VaCarousel",
  components: { VaImage, VaButton: VaButton2, VaHover },
  props: __spreadProps24(__spreadValues29({}, useStatefulProps), {
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: Number, default: 1e3 },
    autoscrollPauseDuration: { type: Number, default: 2e3 },
    infinite: { type: Boolean, default: false },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" }
  }),
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed: currentSlide } = useStateful(props, emit, 0);
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton
    } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props, currentSlide);
    const isObjectSlides = computed(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => +index === currentSlide.value;
    return __spreadValues29({
      doShowNextButton,
      doShowPrevButton,
      computedSlidesStyle,
      goTo: withPause(goTo),
      prev: withPause(prev),
      next: withPause(next),
      slides,
      isObjectSlides,
      isCurrentSlide
    }, useCarouselColor());
  }
});
var _hoisted_113 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_28 = { class: "va-carousel__content" };
var _hoisted_35 = ["aria-hidden", "aria-current", "aria-label"];
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_hover = resolveComponent("va-hover");
  const _component_va_image = resolveComponent("va-image");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-carousel", {
      "va-carousel--vertical": _ctx.$props.vertical,
      [`va-carousel--${_ctx.$props.effect}`]: true
    }]),
    style: normalizeStyle({ height: _ctx.height }),
    role: "region",
    "aria-label": "carousel"
  }, [
    _ctx.$props.arrows ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.doShowPrevButton ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-carousel__arrow va-carousel__arrow--left",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.prev && _ctx.prev(...args)),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.prev && _ctx.prev(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "expand_less" : "chevron_left",
                "aria-label": "go previous slide"
              }, null, 8, ["color", "icon"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true),
      _ctx.doShowNextButton ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-carousel__arrow va-carousel__arrow--right",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.next && _ctx.next(...args)),
        onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.next && _ctx.next(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "next-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "expand_more" : "chevron_right",
                "aria-label": "go next slide"
              }, null, 8, ["color", "icon"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_113, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
        return openBlock(), createElementBlock("div", mergeProps({
          class: ["va-carousel__indicator", { "va-carousel__indicator--active": index === _ctx.modelValue }],
          key: index
        }, _ctx.indicatorTrigger === "hover" ? { onmouseover: () => _ctx.goTo(index) } : { onclick: () => _ctx.goTo(index) }), [
          renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
            createVNode(_component_va_hover, { stateful: "" }, {
              default: withCtx(({ hover }) => [
                createVNode(_component_va_button, {
                  "aria-label": `go slide #${index + 1}`,
                  round: "",
                  color: _ctx.isCurrentSlide(index) ? _ctx.computedActiveColor : hover ? _ctx.computedHoverColor : _ctx.computedColor
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(index + 1), 1)
                  ]),
                  _: 2
                }, 1032, ["aria-label", "color"])
              ]),
              _: 2
            }, 1024)
          ])
        ], 16);
      }), 128))
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_28, [
      createBaseVNode("div", {
        class: "va-carousel__slides",
        style: normalizeStyle(_ctx.computedSlidesStyle),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.slides, (item, index) => {
          return openBlock(), createElementBlock("div", {
            class: "va-carousel__slide",
            key: item,
            style: normalizeStyle(_ctx.effect === "fade" ? { animation: _ctx.fadeKeyframe } : ""),
            role: "listitem",
            "aria-hidden": !_ctx.isCurrentSlide(index),
            "aria-current": _ctx.isCurrentSlide(index),
            "aria-label": `slide ${index + 1} of ${_ctx.slides.length}`
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
              createVNode(_component_va_image, {
                src: _ctx.isObjectSlides ? item.src : item,
                alt: _ctx.isObjectSlides ? item.alt : ""
              }, null, 8, ["src", "alt"])
            ])
          ], 12, _hoisted_35);
        }), 128))
      ], 4)
    ])
  ], 6);
}
var _VaCarousel = _export_sfc(_sfc_main26, [["render", _sfc_render25]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-carousel/index.js
var VaCarousel = withConfigTransport(_VaCarousel);

// node_modules/vuestic-ui/dist/esm/src/components/va-checkbox/VaCheckbox.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useKeyboardOnlyFocus.js
init_vue_runtime_esm_bundler();
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked = true;
    },
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/esm/src/composables/useSelectable.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useValidation.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useSyncProp.js
init_vue_runtime_esm_bundler();
function useSyncProp(propName, props, emit, defaultValue) {
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return props[propName] === void 0 ? statefulValue.value : props[propName];
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/esm/src/composables/useFocus.js
init_vue_runtime_esm_bundler();
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const isFocused = ref(false);
  const onFocus = (e2) => {
    isFocused.value = true;
    emit == null ? void 0 : emit("focus", e2);
  };
  const onBlur = (e2) => {
    isFocused.value = false;
    emit == null ? void 0 : emit("blur", e2);
  };
  const focus = () => {
    var _a;
    (_a = el == null ? void 0 : el.value) == null ? void 0 : _a.focus();
  };
  const blur = () => {
    var _a;
    (_a = el == null ? void 0 : el.value) == null ? void 0 : _a.blur();
  };
  if (el) {
    onMounted(() => {
      var _a, _b;
      if ((el == null ? void 0 : el.value) instanceof HTMLElement) {
        (_a = el.value) == null ? void 0 : _a.addEventListener("focus", onFocus);
        (_b = el.value) == null ? void 0 : _b.addEventListener("blur", onBlur);
      }
    });
    onBeforeUnmount(() => {
      var _a, _b;
      if ((el == null ? void 0 : el.value) instanceof HTMLElement) {
        (_a = el.value) == null ? void 0 : _a.removeEventListener("focus", onFocus);
        (_b = el.value) == null ? void 0 : _b.removeEventListener("blur", onBlur);
      }
    });
  }
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-form/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/esm/src/composables/useValidation.js
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString_1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction_1(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  modelValue: { required: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
var useValidationEmits = ["update:error", "update:errorMessages"];
var useValidation = (props, emit, reset, focus) => {
  const { isFocused, onFocus, onBlur } = useFocus();
  const [computedError] = useSyncProp("error", props, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props, emit, []);
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
  };
  const validate = () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    let error = false;
    let errorMessages = [];
    const rules = flatten_1(props.rules);
    normalizeValidationRules(rules, props.modelValue).forEach((validationResult) => {
      if (isString_1(validationResult)) {
        errorMessages = [...errorMessages, validationResult];
        error = true;
      } else if (validationResult === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  watch(isFocused, (newVal) => !newVal && validate());
  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation });
  const context = {
    resetValidation,
    focus,
    validate,
    reset,
    hasError: () => computedError.value
  };
  const form = inject(FormServiceKey, void 0);
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": !!computedErrorMessages.value.length,
    "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
  }));
  onMounted(() => {
    form == null ? void 0 : form.onChildMounted(context);
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.onChildUnmounted(context);
  });
  return {
    computedError,
    computedErrorMessages,
    listeners: { onFocus, onBlur },
    validate,
    resetValidation,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useSelectable.js
var __defProp30 = Object.defineProperty;
var __defProps25 = Object.defineProperties;
var __getOwnPropDescs25 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols30 = Object.getOwnPropertySymbols;
var __hasOwnProp30 = Object.prototype.hasOwnProperty;
var __propIsEnum30 = Object.prototype.propertyIsEnumerable;
var __defNormalProp30 = (obj, key2, value) => key2 in obj ? __defProp30(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues30 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp30.call(b2, prop))
      __defNormalProp30(a2, prop, b2[prop]);
  if (__getOwnPropSymbols30)
    for (var prop of __getOwnPropSymbols30(b2)) {
      if (__propIsEnum30.call(b2, prop))
        __defNormalProp30(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps25 = (a2, b2) => __defProps25(a2, __getOwnPropDescs25(b2));
var useSelectableProps = __spreadProps25(__spreadValues30(__spreadValues30(__spreadValues30({}, useStatefulProps), useLoadingProps), useValidationProps), {
  arrayValue: { type: null, default: null },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
});
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => emit("update:modelValue", false);
  const focus = () => {
    var _a;
    return (_a = input.value) == null ? void 0 : _a.focus();
  };
  const { computedError, computedErrorMessages, validate, validationAriaAttributes } = useValidation(props, emit, reset, focus);
  const { valueComputed } = useStateful(props, emit);
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [label.value, container.value].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      computedError.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a;
    if (modelIsArray.value) {
      return (_a = props.modelValue) == null ? void 0 : _a.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-input/VaInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/utils/child-props.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/utils/resolve-component-props.js
var __defProp31 = Object.defineProperty;
var __defProps26 = Object.defineProperties;
var __getOwnPropDescs26 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols31 = Object.getOwnPropertySymbols;
var __hasOwnProp31 = Object.prototype.hasOwnProperty;
var __propIsEnum31 = Object.prototype.propertyIsEnumerable;
var __defNormalProp31 = (obj, key2, value) => key2 in obj ? __defProp31(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues31 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp31.call(b2, prop))
      __defNormalProp31(a2, prop, b2[prop]);
  if (__getOwnPropSymbols31)
    for (var prop of __getOwnPropSymbols31(b2)) {
      if (__propIsEnum31.call(b2, prop))
        __defNormalProp31(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps26 = (a2, b2) => __defProps26(a2, __getOwnPropDescs26(b2));
function normalizeProps2(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => __spreadProps26(__spreadValues31({}, acc), { [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps2(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps2(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m2) => mergeProps2(to, m2, optionsType));
  const props = normalizeProps2(from[optionsType]);
  for (const key2 in props) {
    to[key2] = props[key2];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return __spreadValues31(__spreadValues31({}, component.__vccOpts), component.__b);
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  var _a, _b;
  const mixins = (_a = options.mixins) != null ? _a : [];
  const extendsOptions = (_b = options.extends) != null ? _b : [];
  const result = {};
  mergeProps2(result, extendsOptions, optionsType);
  for (let i2 = 0; i2 < mixins.length; i2++) {
    mergeProps2(result, mixins[i2], optionsType);
  }
  Object.assign(result, normalizeProps2(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};

// node_modules/vuestic-ui/dist/esm/src/utils/child-props.js
var filterComponentProps = (propsValues, childProps) => {
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = propsValues[propName];
      return acc;
    }, {});
  });
};
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/esm/src/composables/useClearable.js
init_vue_runtime_esm_bundler();
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "highlight_off" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "small"
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useFocusDeep.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useCurrentElement.js
init_vue_runtime_esm_bundler();
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  onUpdated(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  onBeforeUnmount(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  return currentEl;
};

// node_modules/vuestic-ui/dist/esm/src/composables/useFocusDeep.js
var useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  return computed({
    get() {
      var _a;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused = (_a = current.value) == null ? void 0 : _a.contains(focused.value);
      if (isFocused) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused;
    },
    set(value) {
      var _a;
      let target = previouslyFocusedElement != null ? previouslyFocusedElement : current.value;
      if (!((_a = current.value) == null ? void 0 : _a.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
};

// node_modules/vuestic-ui/dist/esm/src/composables/useForm.js
init_vue_runtime_esm_bundler();
var useFormProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useForm = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed(() => pick_1(props, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-input/hooks/useCleave.js
init_vue_runtime_esm_bundler();

// node_modules/cleave.js/dist/cleave-esm.js
var commonjsGlobal2 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var NumeralFormatter = function(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix2, signBeforePrefix, tailPrefix, delimiter) {
  var owner = this;
  owner.numeralDecimalMark = numeralDecimalMark || ".";
  owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
  owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
  owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
  owner.numeralPositiveOnly = !!numeralPositiveOnly;
  owner.stripLeadingZeroes = stripLeadingZeroes !== false;
  owner.prefix = prefix2 || prefix2 === "" ? prefix2 : "";
  owner.signBeforePrefix = !!signBeforePrefix;
  owner.tailPrefix = !!tailPrefix;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : ",";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
};
NumeralFormatter.groupStyle = {
  thousand: "thousand",
  lakh: "lakh",
  wan: "wan",
  none: "none"
};
NumeralFormatter.prototype = {
  getRawValue: function(value) {
    return value.replace(this.delimiterRE, "").replace(this.numeralDecimalMark, ".");
  },
  format: function(value) {
    var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = "";
    value = value.replace(/[A-Za-z]/g, "").replace(owner.numeralDecimalMark, "M").replace(/[^\dM-]/g, "").replace(/^\-/, "N").replace(/\-/g, "").replace("N", owner.numeralPositiveOnly ? "" : "-").replace("M", owner.numeralDecimalMark);
    if (owner.stripLeadingZeroes) {
      value = value.replace(/^(-)?0+(?=\d)/, "$1");
    }
    partSign = value.slice(0, 1) === "-" ? "-" : "";
    if (typeof owner.prefix != "undefined") {
      if (owner.signBeforePrefix) {
        partSignAndPrefix = partSign + owner.prefix;
      } else {
        partSignAndPrefix = owner.prefix + partSign;
      }
    } else {
      partSignAndPrefix = partSign;
    }
    partInteger = value;
    if (value.indexOf(owner.numeralDecimalMark) >= 0) {
      parts = value.split(owner.numeralDecimalMark);
      partInteger = parts[0];
      partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
    }
    if (partSign === "-") {
      partInteger = partInteger.slice(1);
    }
    if (owner.numeralIntegerScale > 0) {
      partInteger = partInteger.slice(0, owner.numeralIntegerScale);
    }
    switch (owner.numeralThousandsGroupStyle) {
      case NumeralFormatter.groupStyle.lakh:
        partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.wan:
        partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.thousand:
        partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, "$1" + owner.delimiter);
        break;
    }
    if (owner.tailPrefix) {
      return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "") + owner.prefix;
    }
    return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "");
  }
};
var NumeralFormatter_1 = NumeralFormatter;
var DateFormatter = function(datePattern, dateMin, dateMax) {
  var owner = this;
  owner.date = [];
  owner.blocks = [];
  owner.datePattern = datePattern;
  owner.dateMin = dateMin.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMin.length === 2)
    owner.dateMin.unshift(0);
  owner.dateMax = dateMax.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMax.length === 2)
    owner.dateMax.unshift(0);
  owner.initBlocks();
};
DateFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.datePattern.forEach(function(value) {
      if (value === "Y") {
        owner.blocks.push(4);
      } else {
        owner.blocks.push(2);
      }
    });
  },
  getISOFormatDate: function() {
    var owner = this, date = owner.date;
    return date[2] ? date[2] + "-" + owner.addLeadingZero(date[1]) + "-" + owner.addLeadingZero(date[0]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getValidatedDate: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.datePattern[index]) {
          case "d":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 3) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 31) {
              sub = "31";
            }
            break;
          case "m":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 1) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 12) {
              sub = "12";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedDateString(result);
  },
  getFixedDateString: function(value) {
    var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;
    if (value.length === 4 && datePattern[0].toLowerCase() !== "y" && datePattern[1].toLowerCase() !== "y") {
      dayStartIndex = datePattern[0] === "d" ? 0 : 2;
      monthStartIndex = 2 - dayStartIndex;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      date = this.getFixedDate(day, month, 0);
    }
    if (value.length === 8) {
      datePattern.forEach(function(type, index) {
        switch (type) {
          case "d":
            dayIndex = index;
            break;
          case "m":
            monthIndex = index;
            break;
          default:
            yearIndex = index;
            break;
        }
      });
      yearStartIndex = yearIndex * 2;
      dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;
      monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = this.getFixedDate(day, month, year);
    }
    if (value.length === 4 && (datePattern[0] === "y" || datePattern[1] === "y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 2;
      yearStartIndex = 2 - monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;
      date = [0, month, year];
    }
    if (value.length === 6 && (datePattern[0] === "Y" || datePattern[1] === "Y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 4;
      yearStartIndex = 2 - 0.5 * monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = [0, month, year];
    }
    date = owner.getRangeFixedDate(date);
    owner.date = date;
    var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {
      switch (current) {
        case "d":
          return previous + (date[0] === 0 ? "" : owner.addLeadingZero(date[0]));
        case "m":
          return previous + (date[1] === 0 ? "" : owner.addLeadingZero(date[1]));
        case "y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : "");
        case "Y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : "");
      }
    }, "");
    return result;
  },
  getRangeFixedDate: function(date) {
    var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];
    if (!date.length || dateMin.length < 3 && dateMax.length < 3)
      return date;
    if (datePattern.find(function(x2) {
      return x2.toLowerCase() === "y";
    }) && date[2] === 0)
      return date;
    if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0])))
      return dateMax;
    if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0])))
      return dateMin;
    return date;
  },
  getFixedDate: function(day, month, year) {
    day = Math.min(day, 31);
    month = Math.min(month, 12);
    year = parseInt(year || 0, 10);
    if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {
      day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);
    }
    return [day, month, year];
  },
  isLeapYear: function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  },
  addLeadingZeroForYear: function(number, fullYearMode) {
    if (fullYearMode) {
      return (number < 10 ? "000" : number < 100 ? "00" : number < 1e3 ? "0" : "") + number;
    }
    return (number < 10 ? "0" : "") + number;
  }
};
var DateFormatter_1 = DateFormatter;
var TimeFormatter = function(timePattern, timeFormat) {
  var owner = this;
  owner.time = [];
  owner.blocks = [];
  owner.timePattern = timePattern;
  owner.timeFormat = timeFormat;
  owner.initBlocks();
};
TimeFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.timePattern.forEach(function() {
      owner.blocks.push(2);
    });
  },
  getISOFormatTime: function() {
    var owner = this, time = owner.time;
    return time[2] ? owner.addLeadingZero(time[0]) + ":" + owner.addLeadingZero(time[1]) + ":" + owner.addLeadingZero(time[2]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getTimeFormatOptions: function() {
    var owner = this;
    if (String(owner.timeFormat) === "12") {
      return {
        maxHourFirstDigit: 1,
        maxHours: 12,
        maxMinutesFirstDigit: 5,
        maxMinutes: 60
      };
    }
    return {
      maxHourFirstDigit: 2,
      maxHours: 23,
      maxMinutesFirstDigit: 5,
      maxMinutes: 60
    };
  },
  getValidatedTime: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    var timeFormatOptions = owner.getTimeFormatOptions();
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.timePattern[index]) {
          case "h":
            if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {
              sub = timeFormatOptions.maxHours + "";
            }
            break;
          case "m":
          case "s":
            if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {
              sub = timeFormatOptions.maxMinutes + "";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedTimeString(result);
  },
  getFixedTimeString: function(value) {
    var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;
    if (value.length === 6) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "s":
            secondIndex = index * 2;
            break;
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      secondStartIndex = secondIndex;
      second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    if (value.length === 4 && owner.timePattern.indexOf("s") < 0) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      second = 0;
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    owner.time = time;
    return time.length === 0 ? value : timePattern.reduce(function(previous, current) {
      switch (current) {
        case "s":
          return previous + owner.addLeadingZero(time[2]);
        case "m":
          return previous + owner.addLeadingZero(time[1]);
        case "h":
          return previous + owner.addLeadingZero(time[0]);
      }
    }, "");
  },
  getFixedTime: function(hour, minute, second) {
    second = Math.min(parseInt(second || 0, 10), 60);
    minute = Math.min(minute, 60);
    hour = Math.min(hour, 60);
    return [hour, minute, second];
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  }
};
var TimeFormatter_1 = TimeFormatter;
var PhoneFormatter = function(formatter, delimiter) {
  var owner = this;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : " ";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
  owner.formatter = formatter;
};
PhoneFormatter.prototype = {
  setFormatter: function(formatter) {
    this.formatter = formatter;
  },
  format: function(phoneNumber) {
    var owner = this;
    owner.formatter.clear();
    phoneNumber = phoneNumber.replace(/[^\d+]/g, "");
    phoneNumber = phoneNumber.replace(/^\+/, "B").replace(/\+/g, "").replace("B", "+");
    phoneNumber = phoneNumber.replace(owner.delimiterRE, "");
    var result = "", current, validated = false;
    for (var i2 = 0, iMax = phoneNumber.length; i2 < iMax; i2++) {
      current = owner.formatter.inputDigit(phoneNumber.charAt(i2));
      if (/[\s()-]/g.test(current)) {
        result = current;
        validated = true;
      } else {
        if (!validated) {
          result = current;
        }
      }
    }
    result = result.replace(/[()]/g, "");
    result = result.replace(/[\s-]/g, owner.delimiter);
    return result;
  }
};
var PhoneFormatter_1 = PhoneFormatter;
var CreditCardDetector = {
  blocks: {
    uatp: [4, 5, 6],
    amex: [4, 6, 5],
    diners: [4, 6, 4],
    discover: [4, 4, 4, 4],
    mastercard: [4, 4, 4, 4],
    dankort: [4, 4, 4, 4],
    instapayment: [4, 4, 4, 4],
    jcb15: [4, 6, 5],
    jcb: [4, 4, 4, 4],
    maestro: [4, 4, 4, 4],
    visa: [4, 4, 4, 4],
    mir: [4, 4, 4, 4],
    unionPay: [4, 4, 4, 4],
    general: [4, 4, 4, 4]
  },
  re: {
    uatp: /^(?!1800)1\d{0,14}/,
    amex: /^3[47]\d{0,13}/,
    discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
    diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
    mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
    dankort: /^(5019|4175|4571)\d{0,12}/,
    instapayment: /^63[7-9]\d{0,13}/,
    jcb15: /^(?:2131|1800)\d{0,11}/,
    jcb: /^(?:35\d{0,2})\d{0,12}/,
    maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
    mir: /^220[0-4]\d{0,12}/,
    visa: /^4\d{0,15}/,
    unionPay: /^(62|81)\d{0,14}/
  },
  getStrictBlocks: function(block) {
    var total = block.reduce(function(prev, current) {
      return prev + current;
    }, 0);
    return block.concat(19 - total);
  },
  getInfo: function(value, strictMode) {
    var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;
    strictMode = !!strictMode;
    for (var key2 in re) {
      if (re[key2].test(value)) {
        var matchedBlocks = blocks[key2];
        return {
          type: key2,
          blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
        };
      }
    }
    return {
      type: "unknown",
      blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
    };
  }
};
var CreditCardDetector_1 = CreditCardDetector;
var Util = {
  noop: function() {
  },
  strip: function(value, re) {
    return value.replace(re, "");
  },
  getPostDelimiter: function(value, delimiter, delimiters) {
    if (delimiters.length === 0) {
      return value.slice(-delimiter.length) === delimiter ? delimiter : "";
    }
    var matchedDelimiter = "";
    delimiters.forEach(function(current) {
      if (value.slice(-current.length) === current) {
        matchedDelimiter = current;
      }
    });
    return matchedDelimiter;
  },
  getDelimiterREByDelimiter: function(delimiter) {
    return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "g");
  },
  getNextCursorPosition: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    if (oldValue.length === prevPos) {
      return newValue.length;
    }
    return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);
  },
  getPositionOffset: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    var oldRawValue, newRawValue, lengthOffset;
    oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
    newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
    lengthOffset = oldRawValue.length - newRawValue.length;
    return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;
  },
  stripDelimiters: function(value, delimiter, delimiters) {
    var owner = this;
    if (delimiters.length === 0) {
      var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : "";
      return value.replace(delimiterRE, "");
    }
    delimiters.forEach(function(current) {
      current.split("").forEach(function(letter) {
        value = value.replace(owner.getDelimiterREByDelimiter(letter), "");
      });
    });
    return value;
  },
  headStr: function(str, length) {
    return str.slice(0, length);
  },
  getMaxLength: function(blocks) {
    return blocks.reduce(function(previous, current) {
      return previous + current;
    }, 0);
  },
  getPrefixStrippedValue: function(value, prefix2, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {
    if (prefixLength === 0) {
      return value;
    }
    if (value === prefix2 && value !== "") {
      return "";
    }
    if (signBeforePrefix && value.slice(0, 1) == "-") {
      var prev = prevResult.slice(0, 1) == "-" ? prevResult.slice(1) : prevResult;
      return "-" + this.getPrefixStrippedValue(value.slice(1), prefix2, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);
    }
    if (prevResult.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    } else if (prevResult.slice(-prefixLength) !== prefix2 && tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    }
    var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);
    if (value.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      return prevValue.slice(prefixLength);
    } else if (value.slice(-prefixLength) !== prefix2 && tailPrefix) {
      return prevValue.slice(0, -prefixLength - 1);
    }
    return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);
  },
  getFirstDiffIndex: function(prev, current) {
    var index = 0;
    while (prev.charAt(index) === current.charAt(index)) {
      if (prev.charAt(index++) === "") {
        return -1;
      }
    }
    return index;
  },
  getFormattedValue: function(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
    var result = "", multipleDelimiters = delimiters.length > 0, currentDelimiter = "";
    if (blocksLength === 0) {
      return value;
    }
    blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), rest = value.slice(length);
        if (multipleDelimiters) {
          currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;
        } else {
          currentDelimiter = delimiter;
        }
        if (delimiterLazyShow) {
          if (index > 0) {
            result += currentDelimiter;
          }
          result += sub;
        } else {
          result += sub;
          if (sub.length === length && index < blocksLength - 1) {
            result += currentDelimiter;
          }
        }
        value = rest;
      }
    });
    return result;
  },
  fixPrefixCursor: function(el, prefix2, delimiter, delimiters) {
    if (!el) {
      return;
    }
    var val = el.value, appendix = delimiter || (delimiters[0] || " ");
    if (!el.setSelectionRange || !prefix2 || prefix2.length + appendix.length <= val.length) {
      return;
    }
    var len = val.length * 2;
    setTimeout(function() {
      el.setSelectionRange(len, len);
    }, 1);
  },
  checkFullSelection: function(value) {
    try {
      var selection = window.getSelection() || document.getSelection() || {};
      return selection.toString().length === value.length;
    } catch (ex) {
    }
    return false;
  },
  setSelection: function(element, position, doc) {
    if (element !== this.getActiveElement(doc)) {
      return;
    }
    if (element && element.value.length <= position) {
      return;
    }
    if (element.createTextRange) {
      var range = element.createTextRange();
      range.move("character", position);
      range.select();
    } else {
      try {
        element.setSelectionRange(position, position);
      } catch (e2) {
        console.warn("The input element type does not support selection");
      }
    }
  },
  getActiveElement: function(parent2) {
    var activeElement = parent2.activeElement;
    if (activeElement && activeElement.shadowRoot) {
      return this.getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  },
  isAndroid: function() {
    return navigator && /android/i.test(navigator.userAgent);
  },
  isAndroidBackspaceKeydown: function(lastInputValue, currentInputValue) {
    if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
      return false;
    }
    return currentInputValue === lastInputValue.slice(0, -1);
  }
};
var Util_1 = Util;
var DefaultProperties = {
  assign: function(target, opts) {
    target = target || {};
    opts = opts || {};
    target.creditCard = !!opts.creditCard;
    target.creditCardStrictMode = !!opts.creditCardStrictMode;
    target.creditCardType = "";
    target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {
    };
    target.phone = !!opts.phone;
    target.phoneRegionCode = opts.phoneRegionCode || "AU";
    target.phoneFormatter = {};
    target.time = !!opts.time;
    target.timePattern = opts.timePattern || ["h", "m", "s"];
    target.timeFormat = opts.timeFormat || "24";
    target.timeFormatter = {};
    target.date = !!opts.date;
    target.datePattern = opts.datePattern || ["d", "m", "Y"];
    target.dateMin = opts.dateMin || "";
    target.dateMax = opts.dateMax || "";
    target.dateFormatter = {};
    target.numeral = !!opts.numeral;
    target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
    target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
    target.numeralDecimalMark = opts.numeralDecimalMark || ".";
    target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || "thousand";
    target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
    target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
    target.signBeforePrefix = !!opts.signBeforePrefix;
    target.tailPrefix = !!opts.tailPrefix;
    target.swapHiddenInput = !!opts.swapHiddenInput;
    target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;
    target.uppercase = !!opts.uppercase;
    target.lowercase = !!opts.lowercase;
    target.prefix = target.creditCard || target.date ? "" : opts.prefix || "";
    target.noImmediatePrefix = !!opts.noImmediatePrefix;
    target.prefixLength = target.prefix.length;
    target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
    target.copyDelimiter = !!opts.copyDelimiter;
    target.initValue = opts.initValue !== void 0 && opts.initValue !== null ? opts.initValue.toString() : "";
    target.delimiter = opts.delimiter || opts.delimiter === "" ? opts.delimiter : opts.date ? "/" : opts.time ? ":" : opts.numeral ? "," : opts.phone ? " " : " ";
    target.delimiterLength = target.delimiter.length;
    target.delimiterLazyShow = !!opts.delimiterLazyShow;
    target.delimiters = opts.delimiters || [];
    target.blocks = opts.blocks || [];
    target.blocksLength = target.blocks.length;
    target.root = typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window;
    target.document = opts.document || target.root.document;
    target.maxLength = 0;
    target.backspace = false;
    target.result = "";
    target.onValueChanged = opts.onValueChanged || function() {
    };
    return target;
  }
};
var DefaultProperties_1 = DefaultProperties;
var Cleave = function(element, opts) {
  var owner = this;
  var hasMultipleElements = false;
  if (typeof element === "string") {
    owner.element = document.querySelector(element);
    hasMultipleElements = document.querySelectorAll(element).length > 1;
  } else {
    if (typeof element.length !== "undefined" && element.length > 0) {
      owner.element = element[0];
      hasMultipleElements = element.length > 1;
    } else {
      owner.element = element;
    }
  }
  if (!owner.element) {
    throw new Error("[cleave.js] Please check the element");
  }
  if (hasMultipleElements) {
    try {
      console.warn("[cleave.js] Multiple input fields matched, cleave.js will only take the first one.");
    } catch (e2) {
    }
  }
  opts.initValue = owner.element.value;
  owner.properties = Cleave.DefaultProperties.assign({}, opts);
  owner.init();
};
Cleave.prototype = {
  init: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
      owner.onInput(pps.initValue);
      return;
    }
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
    owner.isAndroid = Cleave.Util.isAndroid();
    owner.lastInputValue = "";
    owner.isBackward = "";
    owner.onChangeListener = owner.onChange.bind(owner);
    owner.onKeyDownListener = owner.onKeyDown.bind(owner);
    owner.onFocusListener = owner.onFocus.bind(owner);
    owner.onCutListener = owner.onCut.bind(owner);
    owner.onCopyListener = owner.onCopy.bind(owner);
    owner.initSwapHiddenInput();
    owner.element.addEventListener("input", owner.onChangeListener);
    owner.element.addEventListener("keydown", owner.onKeyDownListener);
    owner.element.addEventListener("focus", owner.onFocusListener);
    owner.element.addEventListener("cut", owner.onCutListener);
    owner.element.addEventListener("copy", owner.onCopyListener);
    owner.initPhoneFormatter();
    owner.initDateFormatter();
    owner.initTimeFormatter();
    owner.initNumeralFormatter();
    if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {
      owner.onInput(pps.initValue);
    }
  },
  initSwapHiddenInput: function() {
    var owner = this, pps = owner.properties;
    if (!pps.swapHiddenInput)
      return;
    var inputFormatter = owner.element.cloneNode(true);
    owner.element.parentNode.insertBefore(inputFormatter, owner.element);
    owner.elementSwapHidden = owner.element;
    owner.elementSwapHidden.type = "hidden";
    owner.element = inputFormatter;
    owner.element.id = "";
  },
  initNumeralFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral) {
      return;
    }
    pps.numeralFormatter = new Cleave.NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);
  },
  initTimeFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.time) {
      return;
    }
    pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);
    pps.blocks = pps.timeFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initDateFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.date) {
      return;
    }
    pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
    pps.blocks = pps.dateFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initPhoneFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.phone) {
      return;
    }
    try {
      pps.phoneFormatter = new Cleave.PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);
    } catch (ex) {
      throw new Error("[cleave.js] Please include phone-type-formatter.{country}.js lib");
    }
  },
  onKeyDown: function(event) {
    var owner = this, charCode = event.which || event.keyCode;
    owner.lastInputValue = owner.element.value;
    owner.isBackward = charCode === 8;
  },
  onChange: function(event) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    owner.isBackward = owner.isBackward || event.inputType === "deleteContentBackward";
    var postDelimiter = Util2.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);
    if (owner.isBackward && postDelimiter) {
      pps.postDelimiterBackspace = postDelimiter;
    } else {
      pps.postDelimiterBackspace = false;
    }
    this.onInput(this.element.value);
  },
  onFocus: function() {
    var owner = this, pps = owner.properties;
    owner.lastInputValue = owner.element.value;
    if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) {
      this.onInput(pps.prefix);
    }
    Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
  },
  onCut: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
    this.onInput("");
  },
  onCopy: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
  },
  copyClipboardData: function(e2) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, inputValue = owner.element.value, textToCopy = "";
    if (!pps.copyDelimiter) {
      textToCopy = Util2.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
    } else {
      textToCopy = inputValue;
    }
    try {
      if (e2.clipboardData) {
        e2.clipboardData.setData("Text", textToCopy);
      } else {
        window.clipboardData.setData("Text", textToCopy);
      }
      e2.preventDefault();
    } catch (ex) {
    }
  },
  onInput: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    var postDelimiterAfter = Util2.getPostDelimiter(value, pps.delimiter, pps.delimiters);
    if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {
      value = Util2.headStr(value, value.length - pps.postDelimiterBackspace.length);
    }
    if (pps.phone) {
      if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
        pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
      } else {
        pps.result = pps.phoneFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.numeral) {
      if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {
        pps.result = "";
      } else {
        pps.result = pps.numeralFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.date) {
      value = pps.dateFormatter.getValidatedDate(value);
    }
    if (pps.time) {
      value = pps.timeFormatter.getValidatedTime(value);
    }
    value = Util2.stripDelimiters(value, pps.delimiter, pps.delimiters);
    value = Util2.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    value = pps.numericOnly ? Util2.strip(value, /[^\d]/g) : value;
    value = pps.uppercase ? value.toUpperCase() : value;
    value = pps.lowercase ? value.toLowerCase() : value;
    if (pps.prefix) {
      if (pps.tailPrefix) {
        value = value + pps.prefix;
      } else {
        value = pps.prefix + value;
      }
      if (pps.blocksLength === 0) {
        pps.result = value;
        owner.updateValueState();
        return;
      }
    }
    if (pps.creditCard) {
      owner.updateCreditCardPropsByValue(value);
    }
    value = Util2.headStr(value, pps.maxLength);
    pps.result = Util2.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);
    owner.updateValueState();
  },
  updateCreditCardPropsByValue: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, creditCardInfo;
    if (Util2.headStr(pps.result, 4) === Util2.headStr(value, 4)) {
      return;
    }
    creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);
    pps.blocks = creditCardInfo.blocks;
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Util2.getMaxLength(pps.blocks);
    if (pps.creditCardType !== creditCardInfo.type) {
      pps.creditCardType = creditCardInfo.type;
      pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
    }
  },
  updateValueState: function() {
    var owner = this, Util2 = Cleave.Util, pps = owner.properties;
    if (!owner.element) {
      return;
    }
    var endPos = owner.element.selectionEnd;
    var oldValue = owner.element.value;
    var newValue = pps.result;
    endPos = Util2.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);
    if (owner.isAndroid) {
      window.setTimeout(function() {
        owner.element.value = newValue;
        Util2.setSelection(owner.element, endPos, pps.document, false);
        owner.callOnValueChanged();
      }, 1);
      return;
    }
    owner.element.value = newValue;
    if (pps.swapHiddenInput)
      owner.elementSwapHidden.value = owner.getRawValue();
    Util2.setSelection(owner.element, endPos, pps.document, false);
    owner.callOnValueChanged();
  },
  callOnValueChanged: function() {
    var owner = this, pps = owner.properties;
    pps.onValueChanged.call(owner, {
      target: {
        name: owner.element.name,
        value: pps.result,
        rawValue: owner.getRawValue()
      }
    });
  },
  setPhoneRegionCode: function(phoneRegionCode) {
    var owner = this, pps = owner.properties;
    pps.phoneRegionCode = phoneRegionCode;
    owner.initPhoneFormatter();
    owner.onChange();
  },
  setRawValue: function(value) {
    var owner = this, pps = owner.properties;
    value = value !== void 0 && value !== null ? value.toString() : "";
    if (pps.numeral) {
      value = value.replace(".", pps.numeralDecimalMark);
    }
    pps.postDelimiterBackspace = false;
    owner.element.value = value;
    owner.onInput(value);
  },
  getRawValue: function() {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, rawValue = owner.element.value;
    if (pps.rawValueTrimPrefix) {
      rawValue = Util2.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    }
    if (pps.numeral) {
      rawValue = pps.numeralFormatter.getRawValue(rawValue);
    } else {
      rawValue = Util2.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
    }
    return rawValue;
  },
  getISOFormatDate: function() {
    var owner = this, pps = owner.properties;
    return pps.date ? pps.dateFormatter.getISOFormatDate() : "";
  },
  getISOFormatTime: function() {
    var owner = this, pps = owner.properties;
    return pps.time ? pps.timeFormatter.getISOFormatTime() : "";
  },
  getFormattedValue: function() {
    return this.element.value;
  },
  destroy: function() {
    var owner = this;
    owner.element.removeEventListener("input", owner.onChangeListener);
    owner.element.removeEventListener("keydown", owner.onKeyDownListener);
    owner.element.removeEventListener("focus", owner.onFocusListener);
    owner.element.removeEventListener("cut", owner.onCutListener);
    owner.element.removeEventListener("copy", owner.onCopyListener);
  },
  toString: function() {
    return "[Cleave Object]";
  }
};
Cleave.NumeralFormatter = NumeralFormatter_1;
Cleave.DateFormatter = DateFormatter_1;
Cleave.TimeFormatter = TimeFormatter_1;
Cleave.PhoneFormatter = PhoneFormatter_1;
Cleave.CreditCardDetector = CreditCardDetector_1;
Cleave.Util = Util_1;
Cleave.DefaultProperties = DefaultProperties_1;
(typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window)["Cleave"] = Cleave;
var Cleave_1 = Cleave;
var cleave_esm_default = Cleave_1;

// node_modules/vuestic-ui/dist/esm/src/components/va-input/hooks/useCleave.js
var __defProp32 = Object.defineProperty;
var __getOwnPropSymbols32 = Object.getOwnPropertySymbols;
var __hasOwnProp32 = Object.prototype.hasOwnProperty;
var __propIsEnum32 = Object.prototype.propertyIsEnumerable;
var __defNormalProp32 = (obj, key2, value) => key2 in obj ? __defProp32(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues32 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp32.call(b2, prop))
      __defNormalProp32(a2, prop, b2[prop]);
  if (__getOwnPropSymbols32)
    for (var prop of __getOwnPropSymbols32(b2)) {
      if (__propIsEnum32.call(b2, prop))
        __defNormalProp32(a2, prop, b2[prop]);
    }
  return a2;
};
var DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
var useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true },
  modelValue: { type: String }
};
var useCleave = (element, props, emit) => {
  const cleave = ref();
  const getMask = (mask) => {
    if (typeof mask === "string") {
      return DEFAULT_MASK_TOKENS[mask] ? __spreadValues32({}, DEFAULT_MASK_TOKENS[mask]) : {};
    }
    return __spreadValues32({}, mask);
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const initCleave = () => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    cleave.value = new cleave_esm_default(element.value, getMask(props.mask));
  };
  onMounted(() => {
    initCleave();
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  watch(() => [element.value, props.mask], () => {
    initCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return props.modelValue;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (props.mask !== "string" && !Object.keys(props.mask).length) {
      emit("update:modelValue", value);
      return;
    }
    if (cleave.value) {
      cleave.value.setRawValue(value);
      if (props.returnRaw) {
        emit("update:modelValue", cleave.value.getRawValue());
        return;
      }
    }
    emit("update:modelValue", value);
  };
  return {
    cleave,
    computedValue,
    onInput
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaInputWrapper/VaInputWrapper.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useCSSVariables.js
init_vue_runtime_esm_bundler();
var useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).map(([key2, value]) => ({ [`--${prefix2}-${kebabCase_1(key2)}`]: value })));
};

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaMessageList/VaMessageList.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaMessageList/VaMessageList.css";
var _sfc_main27 = defineComponent({
  name: "VaMessageList",
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: Number, default: 1 },
    color: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      messages: computed(() => {
        if (!props.modelValue) {
          return [];
        }
        if (!Array.isArray(props.modelValue)) {
          return [props.modelValue];
        }
        return props.modelValue.slice(0, props.limit);
      }),
      computedStyle: computed(() => props.color ? { color: getColor(props.color) } : {})
    };
  }
});
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.messages.length ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-message-list",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.messages, (message, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: "va-message-list__message"
      }, toDisplayString(message), 1);
    }), 128))
  ], 4)) : createCommentVNode("", true);
}
var _VaMessageList = _export_sfc(_sfc_main27, [["render", _sfc_render26]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaMessageList/index.js
var VaMessageList = withConfigTransport(_VaMessageList);

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaInputWrapper/VaInputWrapper.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaInputWrapper/VaInputWrapper.css";
var __defProp33 = Object.defineProperty;
var __defProps27 = Object.defineProperties;
var __getOwnPropDescs27 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols33 = Object.getOwnPropertySymbols;
var __hasOwnProp33 = Object.prototype.hasOwnProperty;
var __propIsEnum33 = Object.prototype.propertyIsEnumerable;
var __defNormalProp33 = (obj, key2, value) => key2 in obj ? __defProp33(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues33 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp33.call(b2, prop))
      __defNormalProp33(a2, prop, b2[prop]);
  if (__getOwnPropSymbols33)
    for (var prop of __getOwnPropSymbols33(b2)) {
      if (__propIsEnum33.call(b2, prop))
        __defNormalProp33(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps27 = (a2, b2) => __defProps27(a2, __getOwnPropDescs27(b2));
var _sfc_main28 = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList, VaIcon: VaIcon2 },
  props: __spreadProps27(__spreadValues33(__spreadValues33({}, useFormProps), useValidationProps), {
    counterValue: { type: Number, default: void 0 },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    color: { type: String, default: "primary" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    error: { type: Boolean, default: false },
    success: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  }),
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner"
  ],
  setup(props) {
    const { getColor } = useColors();
    const wrapperClass = useBem("va-input-wrapper", () => __spreadProps27(__spreadValues33({}, pick_1(props, ["outline", "bordered", "success", "focused", "error", "disabled", "readonly"])), {
      labeled: !!props.label,
      solid: !props.outline && !props.bordered
    }));
    const wrapperStyle = useCSSVariables("va-input-wrapper", () => ({
      color: colorComputed.value
    }));
    const colorComputed = computed(() => getColor(props.color));
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const hasMessages = computed(() => {
      var _a;
      return Boolean(typeof messagesComputed.value === "string" ? messagesComputed.value : (_a = messagesComputed.value) == null ? void 0 : _a.length);
    });
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => props.counterValue !== void 0);
    const counterComputed = computed(() => props.maxLength !== void 0 ? `${props.counterValue}/${props.maxLength}` : props.counterValue);
    return {
      wrapperClass,
      wrapperStyle,
      isCounterVisible,
      counterComputed,
      colorComputed,
      messagesColor,
      messagesComputed,
      hasMessages,
      errorLimit
    };
  },
  methods: {
    focus() {
      this.$el.focus();
    },
    blur() {
      this.$el.blur();
    }
  }
});
var _hoisted_114 = { class: "va-input-wrapper__container" };
var _hoisted_29 = { class: "va-input-wrapper__field" };
var _hoisted_36 = { class: "va-input-wrapper__text" };
var _hoisted_45 = {
  key: 0,
  class: "va-input-wrapper__required-mark"
};
var _hoisted_55 = {
  key: 0,
  class: "va-input-wrapper__bottom"
};
var _hoisted_64 = { class: "va-input-wrapper__bottom-counter" };
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    style: normalizeStyle(_ctx.wrapperStyle),
    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click", $event))
  }, [
    createBaseVNode("div", _hoisted_114, [
      _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-input-wrapper__prepend-inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
      }, [
        renderSlot(_ctx.$slots, "prepend")
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_29, [
        _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-input-wrapper__prepend-inner",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "prependInner")
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_36, [
          _ctx.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            "aria-hidden": "true",
            class: "va-input-wrapper__label",
            style: normalizeStyle({ color: _ctx.colorComputed })
          }, [
            createTextVNode(toDisplayString(_ctx.label) + " ", 1),
            _ctx.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_45, " * ")) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          color: "success",
          name: "check_circle",
          size: "small"
        })) : createCommentVNode("", true),
        _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
          key: 2,
          color: "danger",
          name: "warning",
          size: "small"
        })) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "icon"),
        _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: "va-input-wrapper__append-inner",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click-append-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "appendInner")
        ])) : createCommentVNode("", true)
      ]),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-input-wrapper__append-inner",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append"))
      }, [
        renderSlot(_ctx.$slots, "append")
      ])) : createCommentVNode("", true)
    ]),
    _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", _hoisted_55, [
      renderSlot(_ctx.$slots, "counter", normalizeProps(guardReactiveProps({ valueLength: _ctx.$props.counterValue, maxLength: _ctx.$props.maxLength })), () => [
        createBaseVNode("div", _hoisted_64, toDisplayString(_ctx.counterComputed), 1)
      ])
    ])) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ messages: _ctx.messagesComputed, errorLimit: _ctx.errorLimit, color: _ctx.messagesColor })), () => [
      _ctx.hasMessages ? (openBlock(), createBlock(_component_va_message_list, {
        key: 0,
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit
      }, null, 8, ["color", "model-value", "limit"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var VaInputWrapper = _export_sfc(_sfc_main28, [["render", _sfc_render27]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaTextarea/VaTextarea.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaTextarea/useTextareaRowHeight.js
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important';
`;
var SIZING_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
var getNodeHeightStyles = (node) => {
  const style = window.getComputedStyle(node);
  return {
    boxSizing: style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing"),
    padding: parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top")),
    border: parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width")),
    styles: SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";") + ";",
    lineHeight: parseInt(style.getPropertyValue("line-height"))
  };
};
var textarea = null;
var createHiddenTextarea = (original, styles) => {
  if (!textarea) {
    textarea = document.createElement("textarea");
  }
  textarea.setAttribute("style", styles + HIDDEN_TEXTAREA_STYLE);
  textarea.value = original.value || original.placeholder || "";
  const wrap = original.getAttribute("wrap");
  if (wrap !== null) {
    textarea.setAttribute("wrap", wrap);
  } else {
    textarea.removeAttribute("wrap");
  }
  return textarea;
};
var useTextareaRowHeight = (textarea2) => {
  const calculateRowHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    return getNodeHeightStyles(textarea2.value).lineHeight;
  };
  const calculateHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    const { boxSizing, padding, border, styles } = getNodeHeightStyles(textarea2.value);
    const hiddenTextarea = createHiddenTextarea(textarea2.value, styles);
    document.body.appendChild(hiddenTextarea);
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += border;
    } else if (boxSizing === "content-box") {
      height -= padding;
    }
    document.body.removeChild(hiddenTextarea);
    return height;
  };
  return {
    calculateRowHeight,
    calculateHeight
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaTextarea/VaTextarea.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaTextarea/VaTextarea.css";
var __defProp34 = Object.defineProperty;
var __defProps28 = Object.defineProperties;
var __getOwnPropDescs28 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols34 = Object.getOwnPropertySymbols;
var __hasOwnProp34 = Object.prototype.hasOwnProperty;
var __propIsEnum34 = Object.prototype.propertyIsEnumerable;
var __defNormalProp34 = (obj, key2, value) => key2 in obj ? __defProp34(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues34 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp34.call(b2, prop))
      __defNormalProp34(a2, prop, b2[prop]);
  if (__getOwnPropSymbols34)
    for (var prop of __getOwnPropSymbols34(b2)) {
      if (__propIsEnum34.call(b2, prop))
        __defNormalProp34(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps28 = (a2, b2) => __defProps28(a2, __getOwnPropDescs28(b2));
var positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var _sfc_main29 = defineComponent({
  name: "VaTextarea",
  props: __spreadProps28(__spreadValues34({}, useFormProps), {
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    }
  }),
  emits: createEmits2(),
  setup(props, { emit }) {
    const textarea2 = shallowRef();
    const rowHeight = ref(-1);
    const height = ref(-1);
    const { calculateRowHeight, calculateHeight } = useTextareaRowHeight(textarea2);
    const isResizable = computed(() => {
      return Boolean((props.autosize || props.maxRows || props.minRows !== 1) && textarea2.value);
    });
    const updateRowHeight = () => {
      if (isResizable.value) {
        rowHeight.value = calculateRowHeight();
      }
    };
    const updateHeight = () => {
      if (isResizable.value) {
        height.value = calculateHeight();
      }
    };
    onMounted(() => {
      updateRowHeight();
      updateHeight();
    });
    watch(() => props.modelValue, () => {
      nextTick(updateHeight);
    });
    const computedStyle = computed(() => ({
      minHeight: rowHeight.value * props.minRows + "px",
      maxHeight: props.maxRows ? rowHeight.value * props.maxRows + "px" : void 0,
      height: height.value + "px",
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => __spreadValues34({}, pick_1(props, ["disabled", "readonly", "placeholder", "ariaLabel"])));
    const focus = () => {
      var _a;
      (_a = textarea2.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = textarea2.value) == null ? void 0 : _a.blur();
    };
    return {
      textarea: textarea2,
      computedStyle,
      listeners: createListeners2(emit),
      computedProps,
      focus,
      blur
    };
  }
});
var _hoisted_115 = ["value"];
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", mergeProps({
    ref: "textarea",
    class: "textarea",
    style: _ctx.computedStyle
  }, __spreadValues34(__spreadValues34({}, _ctx.computedProps), _ctx.listeners), { value: _ctx.modelValue }), null, 16, _hoisted_115);
}
var VaTextarea = _export_sfc(_sfc_main29, [["render", _sfc_render28]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-input/VaInput.js
var __defProp35 = Object.defineProperty;
var __defProps29 = Object.defineProperties;
var __getOwnPropDescs29 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols35 = Object.getOwnPropertySymbols;
var __hasOwnProp35 = Object.prototype.hasOwnProperty;
var __propIsEnum35 = Object.prototype.propertyIsEnumerable;
var __defNormalProp35 = (obj, key2, value) => key2 in obj ? __defProp35(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues35 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp35.call(b2, prop))
      __defNormalProp35(a2, prop, b2[prop]);
  if (__getOwnPropSymbols35)
    for (var prop of __getOwnPropSymbols35(b2)) {
      if (__propIsEnum35.call(b2, prop))
        __defNormalProp35(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps29 = (a2, b2) => __defProps29(a2, __getOwnPropDescs29(b2));
var VaTextareaProps = extractComponentProps(VaTextarea);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(["change", "keyup", "keypress", "keydown", "focus", "blur"]);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var _sfc_main30 = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaTextarea, VaIcon },
  props: __spreadProps29(__spreadValues35(__spreadValues35(__spreadValues35(__spreadValues35(__spreadValues35({}, useFormProps), useValidationProps), useClearableProps), useCleaveProps), VaTextareaProps), {
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    modelValue: { type: [String, Number], default: "" },
    label: { type: String, default: "" },
    type: { type: String, default: "text" },
    loading: { type: Boolean, default: false },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    ariaLabel: { type: String, default: void 0 },
    counter: { type: Boolean, default: false },
    maxLength: { type: Number, default: void 0 },
    color: { type: String, default: "primary" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  }),
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits()
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const isFocused = useFocusDeep();
    const reset = () => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
    };
    const focus = () => {
      var _a;
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = input.value) == null ? void 0 : _a.blur();
    };
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes
    } = useValidation(props, emit, reset, focus);
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const computedCleaveTarget = computed(() => props.type === "textarea" ? void 0 : input.value);
    const { computedValue, onInput } = useCleave(computedCleaveTarget, props, emit);
    const inputListeners = createInputListeners(emit);
    const onFocus = (e2) => {
      inputListeners.onFocus(e2);
      validationListeners.onFocus();
    };
    const onBlur = (e2) => {
      inputListeners.onBlur(e2);
      validationListeners.onBlur();
    };
    const inputEvents = __spreadProps29(__spreadValues35({}, inputListeners), {
      onFocus,
      onBlur,
      onInput
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => __spreadValues35(__spreadValues35({
      ariaLabel: props.ariaLabel || props.label,
      ariaRequired: props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      ariaDisabled: props.disabled,
      ariaReadonly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    const computedInputAttributes = computed(() => __spreadValues35(__spreadValues35({}, computedChildAttributes.value), pick_1(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode"])));
    const valueLengthComputed = computed(() => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0);
    return {
      input,
      inputEvents,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      textareaProps: filterComponentProps(props, VaTextareaProps),
      computedValue,
      tabIndexComputed,
      computedError,
      computedErrorMessages,
      isFocused,
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      reset,
      focus,
      blur
    };
  }
});
var _hoisted_116 = ["value"];
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaTextarea = resolveComponent("VaTextarea");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps(_ctx.fieldListeners, {
    class: ["va-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style,
    color: _ctx.$props.color,
    readonly: _ctx.$props.readonly,
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    label: _ctx.$props.label,
    bordered: _ctx.$props.bordered,
    outline: _ctx.$props.outline,
    requiredMark: _ctx.$props.requiredMark,
    focused: _ctx.isFocused,
    "counter-value": _ctx.valueLengthComputed,
    "max-length": _ctx.$props.maxLength,
    onClick: _ctx.focus
  }), createSlots({
    icon: withCtx((slotScope) => [
      _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
        key: 0,
        role: "button",
        "aria-hidden": "false",
        "aria-label": "reset",
        class: "va-input__icons__reset",
        tabindex: _ctx.tabIndexComputed
      }, _ctx.clearIconProps, {
        onClick: withModifiers(_ctx.reset, ["stop"]),
        onKeydown: [
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
        ]
      }), null, 16, ["tabindex", "onClick", "onKeydown"])) : createCommentVNode("", true),
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
        key: 1,
        color: _ctx.$props.color,
        size: "small",
        name: "loop",
        spin: "counter-clockwise"
      }, null, 8, ["color"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      _ctx.type === "textarea" && !_ctx.$slots.content ? (openBlock(), createBlock(_component_VaTextarea, mergeProps({
        key: 0,
        ref: "input"
      }, __spreadValues35(__spreadValues35(__spreadValues35({}, _ctx.computedChildAttributes), _ctx.textareaProps), _ctx.inputEvents), { class: "va-input__content__input" }), null, 16)) : !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "va-input__content__input"
      }, __spreadValues35(__spreadValues35({}, _ctx.computedInputAttributes), _ctx.inputEvents), { value: _ctx.computedValue }), null, 16, _hoisted_116)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      };
    })
  ]), 1040, ["class", "style", "color", "readonly", "disabled", "success", "messages", "error", "error-messages", "error-count", "label", "bordered", "outline", "requiredMark", "focused", "counter-value", "max-length", "onClick"]);
}
var _VaInput = _export_sfc(_sfc_main30, [["render", _sfc_render29]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaMessageListWrapper.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-input/components/VaMessageListWrapper.css";
var __defProp36 = Object.defineProperty;
var __getOwnPropSymbols36 = Object.getOwnPropertySymbols;
var __hasOwnProp36 = Object.prototype.hasOwnProperty;
var __propIsEnum36 = Object.prototype.propertyIsEnumerable;
var __defNormalProp36 = (obj, key2, value) => key2 in obj ? __defProp36(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues36 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp36.call(b2, prop))
      __defNormalProp36(a2, prop, b2[prop]);
  if (__getOwnPropSymbols36)
    for (var prop of __getOwnPropSymbols36(b2)) {
      if (__propIsEnum36.call(b2, prop))
        __defNormalProp36(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main31 = defineComponent({
  name: "VaMessageListWrapper",
  components: { VaMessageList },
  props: __spreadValues36({}, useValidationProps),
  setup(props) {
    return {
      messagesColor: computed(() => {
        if (props.error) {
          return "danger";
        }
        if (props.success) {
          return "success";
        }
        return "";
      }),
      messagesComputed: computed(() => props.error ? props.errorMessages : props.messages),
      errorLimit: computed(() => props.error ? Number(props.errorCount) : 99)
    };
  }
});
var _hoisted_117 = { class: "va-message-list-wrapper" };
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", _hoisted_117, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_va_message_list, {
      color: _ctx.messagesColor,
      limit: _ctx.errorLimit,
      "model-value": _ctx.messagesComputed
    }, null, 8, ["color", "limit", "model-value"])
  ]);
}
var VaMessageListWrapper = _export_sfc(_sfc_main31, [["render", _sfc_render30]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-input/index.js
var VaInput = withConfigTransport(_VaInput);

// node_modules/vuestic-ui/dist/esm/src/components/va-checkbox/VaCheckbox.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-checkbox/VaCheckbox.css";
var __defProp37 = Object.defineProperty;
var __defProps30 = Object.defineProperties;
var __getOwnPropDescs30 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols37 = Object.getOwnPropertySymbols;
var __hasOwnProp37 = Object.prototype.hasOwnProperty;
var __propIsEnum37 = Object.prototype.propertyIsEnumerable;
var __defNormalProp37 = (obj, key2, value) => key2 in obj ? __defProp37(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues37 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp37.call(b2, prop))
      __defNormalProp37(a2, prop, b2[prop]);
  if (__getOwnPropSymbols37)
    for (var prop of __getOwnPropSymbols37(b2)) {
      if (__propIsEnum37.call(b2, prop))
        __defNormalProp37(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps30 = (a2, b2) => __defProps30(a2, __getOwnPropDescs30(b2));
var VaCheckboxValueType = [Boolean, Array, String, Object];
var _sfc_main32 = defineComponent({
  name: "VaCheckbox",
  components: { VaMessageListWrapper, VaIcon: VaIcon2 },
  emits: useSelectableEmits,
  props: __spreadProps30(__spreadValues37({}, useSelectableProps), {
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 }
  }),
  setup(props, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor();
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : "",
        padding: !props.label ? "" : props.leftLabel ? "0 0.5rem 0 0" : "0 0 0 0.5rem"
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const computedIconName = computed(() => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon);
    const uniqueId = computed(generateUniqueId);
    const computedId = computed(() => props.id || uniqueId.value);
    const computedName = computed(() => props.name || uniqueId.value);
    const inputAttributesComputed = computed(() => __spreadValues37({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      ariaLabel: props.ariaLabel,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: isActive.value
    }, validationAriaAttributes.value));
    return {
      isActive,
      computedClass,
      labelStyle,
      inputStyle,
      computedIconName,
      textColorComputed,
      computedError,
      computedErrorMessages,
      keyboardFocusListeners,
      toggleSelection,
      onBlur,
      onFocus,
      inputAttributesComputed,
      computedId,
      computedName
    };
  }
});
var _hoisted_118 = ["id", "indeterminate", "value", "checked"];
var _hoisted_210 = ["for"];
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-checkbox", _ctx.computedClass]),
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-checkbox__input-container",
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-checkbox__square",
          style: normalizeStyle(_ctx.inputStyle),
          onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-checkbox__input",
            id: _ctx.computedId,
            indeterminate: _ctx.indeterminate,
            value: _ctx.label,
            checked: _ctx.isActive
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop", "prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]))
          }), null, 16, _hoisted_118),
          withDirectives(createVNode(_component_va_icon, {
            class: "va-checkbox__icon",
            size: "20px",
            name: _ctx.computedIconName,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"]), [
            [vShow, _ctx.isActive]
          ])
        ], 36),
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          ref: "label",
          class: "va-checkbox__label",
          for: _ctx.computedId,
          style: normalizeStyle(_ctx.labelStyle),
          onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 44, _hoisted_210)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaCheckbox = _export_sfc(_sfc_main32, [["render", _sfc_render31]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-checkbox/index.js
var VaCheckbox = withConfigTransport(_VaCheckbox);

// node_modules/vuestic-ui/dist/esm/src/components/va-chip/VaChip.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useHover.js
init_vue_runtime_esm_bundler();
var getEl = (el) => el.$el !== void 0 ? el.$el : el;
function useHover(el) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  if (el) {
    watch(el, (n2, o2) => {
      if (n2) {
        const newEl = getEl(n2);
        newEl.addEventListener("mouseenter", onMouseEnter);
        newEl.addEventListener("mouseleave", onMouseLeave);
      }
      if (o2) {
        const oldEl = getEl(o2);
        oldEl.removeEventListener("mouseenter", onMouseEnter);
        oldEl.removeEventListener("mouseleave", onMouseLeave);
      }
    });
  }
  return {
    isHovered,
    onMouseEnter,
    onMouseLeave
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-chip/VaChip.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-chip/VaChip.css";
var __defProp38 = Object.defineProperty;
var __defProps31 = Object.defineProperties;
var __getOwnPropDescs31 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols38 = Object.getOwnPropertySymbols;
var __hasOwnProp38 = Object.prototype.hasOwnProperty;
var __propIsEnum38 = Object.prototype.propertyIsEnumerable;
var __defNormalProp38 = (obj, key2, value) => key2 in obj ? __defProp38(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues38 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp38.call(b2, prop))
      __defNormalProp38(a2, prop, b2[prop]);
  if (__getOwnPropSymbols38)
    for (var prop of __getOwnPropSymbols38(b2)) {
      if (__propIsEnum38.call(b2, prop))
        __defNormalProp38(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps31 = (a2, b2) => __defProps31(a2, __getOwnPropDescs31(b2));
var _sfc_main33 = defineComponent({
  name: "VaChip",
  components: { VaIcon: VaIcon2 },
  emits: [...useStatefulEmits, "focus"],
  props: __spreadProps31(__spreadValues38(__spreadValues38(__spreadValues38({}, useRouterLinkProps), useColorProps), useStatefulProps), {
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    }
  }),
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
    const size2 = {
      small: "0.875rem",
      medium: "1rem",
      large: "1.25rem"
    };
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    return {
      keyboardFocusListeners,
      valueComputed,
      hrefComputed,
      tagComputed,
      onMouseEnter,
      onMouseLeave,
      isHovered,
      close: () => {
        if (!props.disabled) {
          valueComputed.value = false;
        }
      },
      iconSize: computed(() => size2[props.size]),
      tabIndexComputed: computed(() => props.disabled ? -1 : 0),
      computedClass: computed(() => ({
        "va-chip--small": props.size === "small",
        "va-chip--large": props.size === "large",
        "va-chip--square": props.square,
        "va-chip--disabled": props.disabled
      })),
      computedStyle: computed(() => {
        const result = {
          color: textColorComputed.value,
          borderColor: borderColor.value,
          background: "",
          boxShadow: shadowStyle.value
        };
        if (props.outline || props.flat) {
          if (hasKeyboardFocus.value) {
            result.background = getFocusColor(colorComputed.value);
          } else if (isHovered.value) {
            result.background = getHoverColor(colorComputed.value);
          }
        } else {
          result.background = colorComputed.value;
        }
        return result;
      })
    };
  }
});
var _hoisted_119 = { class: "va-chip__content" };
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    key: 0,
    class: normalizeClass(["va-chip", _ctx.computedClass]),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle)
  }, {
    default: withCtx(() => [
      createBaseVNode("span", mergeProps({ class: "va-chip__inner" }, toHandlers(_ctx.keyboardFocusListeners), {
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
      }), [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-chip__icon",
          name: _ctx.icon,
          size: _ctx.iconSize
        }, null, 8, ["name", "size"])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_119, [
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.closeable ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          class: "va-chip__close-icon",
          name: "close",
          role: "button",
          "aria-label": "close",
          "aria-hidden": "false",
          tabindex: _ctx.tabIndexComputed,
          size: _ctx.iconSize,
          onClick: withModifiers(_ctx.close, ["stop"]),
          onKeydown: [
            withKeys(withModifiers(_ctx.close, ["stop"]), ["enter"]),
            withKeys(withModifiers(_ctx.close, ["stop"]), ["space"])
          ]
        }, null, 8, ["tabindex", "size", "onClick", "onKeydown"])) : createCommentVNode("", true)
      ], 16)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("", true);
}
var _VaChip = _export_sfc(_sfc_main33, [["render", _sfc_render32]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-chip/index.js
var VaChip = withConfigTransport(_VaChip);

// node_modules/vuestic-ui/dist/esm/src/components/va-collapse/VaCollapse.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useResizeObserver.js
init_vue_runtime_esm_bundler();
var useResizeObserver = (elementsList, cb) => {
  const resizeObserver = ref();
  const observeAll = (elementsList2) => {
    elementsList2.forEach((element) => {
      var _a;
      const unrefedElement = unref(element);
      unrefedElement && ((_a = resizeObserver.value) == null ? void 0 : _a.observe(unrefedElement));
    });
  };
  watch(elementsList, (newValue) => {
    var _a;
    (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
    observeAll(newValue);
  });
  onMounted(() => {
    resizeObserver.value = new ResizeObserver(cb);
    observeAll(elementsList);
  });
  onBeforeUnmount(() => {
    var _a;
    return (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
  });
  return resizeObserver;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-collapse/VaCollapse.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-collapse/VaCollapse.css";
var __defProp39 = Object.defineProperty;
var __defProps32 = Object.defineProperties;
var __getOwnPropDescs32 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols39 = Object.getOwnPropertySymbols;
var __hasOwnProp39 = Object.prototype.hasOwnProperty;
var __propIsEnum39 = Object.prototype.propertyIsEnumerable;
var __defNormalProp39 = (obj, key2, value) => key2 in obj ? __defProp39(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues39 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp39.call(b2, prop))
      __defNormalProp39(a2, prop, b2[prop]);
  if (__getOwnPropSymbols39)
    for (var prop of __getOwnPropSymbols39(b2)) {
      if (__propIsEnum39.call(b2, prop))
        __defNormalProp39(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps32 = (a2, b2) => __defProps32(a2, __getOwnPropDescs32(b2));
var _sfc_main34 = defineComponent({
  name: "VaCollapse",
  components: {
    VaIcon: VaIcon2
  },
  props: {
    modelValue: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    solid: { type: Boolean, default: false },
    color: { type: String, default: "background" },
    textColor: { type: String, default: "" },
    colorAll: { type: Boolean, default: false }
  },
  emits: ["focus", "update:modelValue"],
  setup(props, { emit, slots }) {
    const body = shallowRef();
    const [computedModelValue] = useSyncProp("modelValue", props, emit, false);
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { accordionProps, toggle } = useAccordionItem(computedModelValue);
    const { textColorComputed } = useTextColor();
    const bodyHeight = ref();
    useResizeObserver([body], () => {
      var _a, _b;
      bodyHeight.value = (_b = (_a = body.value) == null ? void 0 : _a.clientHeight) != null ? _b : 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const getBackground = () => {
      return props.color && props.colorAll ? getHoverColor2(getColor(props.color)) : "";
    };
    const uniqueId = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId.value}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const computedClasses = useBem("va-collapse", () => __spreadProps32(__spreadValues39({}, pick_1(props, ["disabled", "solid"])), {
      expanded: computedModelValue.value,
      active: props.solid && computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value)
    }));
    return {
      body,
      height,
      toggle,
      computedModelValue,
      hasKeyboardFocus,
      keyboardFocusListeners,
      textColorComputed,
      headerIdComputed,
      headerAttributes,
      panelIdComputed,
      tabIndexComputed,
      computedClasses,
      headerStyle: computed(() => ({
        paddingLeft: props.icon && 0,
        color: textColorComputed.value,
        backgroundColor: props.color ? getColor(props.color) : ""
      })),
      contentStyle: computed(() => {
        var _a;
        const hasContent = computedModelValue.value && !!((_a = slots.default) == null ? void 0 : _a.call(slots)[0]);
        return {
          visibility: hasContent ? "visible" : "hidden",
          height: `${height.value}px`,
          transitionDuration: getTransition(),
          background: hasContent ? getBackground() : ""
        };
      })
    };
  }
});
var _hoisted_120 = { class: "va-collapse__header__text" };
var _hoisted_211 = ["id", "aria-labelledby"];
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-collapse", _ctx.computedClasses])
  }, [
    createBaseVNode("div", mergeProps({ class: "va-collapse__header-wrapper" }, toHandlers(_ctx.keyboardFocusListeners), {
      onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.toggle && _ctx.toggle(...args)),
      onKeydown: [
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["enter"])),
        _cache[3] || (_cache[3] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["space"]))
      ]
    }), [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({
        value: _ctx.computedModelValue,
        hasKeyboardFocus: _ctx.hasKeyboardFocus,
        bind: _ctx.headerAttributes,
        attributes: _ctx.headerAttributes
      })), () => [
        createBaseVNode("div", mergeProps(_ctx.headerAttributes, {
          class: "va-collapse__header",
          style: _ctx.headerStyle
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-collapse__header__icon",
            name: _ctx.icon,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_120, toDisplayString(_ctx.header), 1),
          createVNode(_component_va_icon, {
            class: "va-collapse__header__icon",
            name: _ctx.computedModelValue ? "expand_less" : "expand_more",
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])
        ], 16)
      ])
    ], 16),
    createBaseVNode("div", {
      class: "va-collapse__body-wrapper",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      createBaseVNode("div", {
        class: "va-collapse_body",
        ref: "body",
        role: "region",
        id: _ctx.panelIdComputed,
        "aria-labelledby": _ctx.headerIdComputed
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, _hoisted_211)
    ], 4)
  ], 2);
}
var _VaCollapse = _export_sfc(_sfc_main34, [["render", _sfc_render33]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-collapse/index.js
var VaCollapse = withConfigTransport(_VaCollapse);

// node_modules/vuestic-ui/dist/esm/src/components/va-color-indicator/VaColorIndicator.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-color-indicator/VaColorIndicator.css";
var __defProp40 = Object.defineProperty;
var __defProps33 = Object.defineProperties;
var __getOwnPropDescs33 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols40 = Object.getOwnPropertySymbols;
var __hasOwnProp40 = Object.prototype.hasOwnProperty;
var __propIsEnum40 = Object.prototype.propertyIsEnumerable;
var __defNormalProp40 = (obj, key2, value) => key2 in obj ? __defProp40(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues40 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp40.call(b2, prop))
      __defNormalProp40(a2, prop, b2[prop]);
  if (__getOwnPropSymbols40)
    for (var prop of __getOwnPropSymbols40(b2)) {
      if (__propIsEnum40.call(b2, prop))
        __defNormalProp40(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps33 = (a2, b2) => __defProps33(a2, __getOwnPropDescs33(b2));
var _sfc_main35 = defineComponent({
  name: "VaColorIndicator",
  emits: useStatefulEmits,
  props: __spreadProps33(__spreadValues40({}, useStatefulProps), {
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      borderRadius: props.square ? "0px" : "50%",
      backgroundColor: colorComputed.value
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--hoverable": valueComputed.value !== void 0
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return {
      valueComputed,
      computedStyle,
      computedClass,
      toggleModelValue
    };
  }
});
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-color-indicator", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args)),
    onKeydown: [
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["enter"])),
      _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["space"]))
    ]
  }, [
    createBaseVNode("div", {
      class: "va-color-indicator__core",
      style: normalizeStyle(_ctx.computedStyle)
    }, null, 4)
  ], 38);
}
var _VaColorIndicatort = _export_sfc(_sfc_main35, [["render", _sfc_render34]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-color-indicator/index.js
var VaColorIndicator = withConfigTransport(_VaColorIndicatort);

// node_modules/vuestic-ui/dist/esm/src/components/va-color-input/VaColorInput.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-color-input/VaColorInput.css";
var __defProp41 = Object.defineProperty;
var __defProps34 = Object.defineProperties;
var __getOwnPropDescs34 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols41 = Object.getOwnPropertySymbols;
var __hasOwnProp41 = Object.prototype.hasOwnProperty;
var __propIsEnum41 = Object.prototype.propertyIsEnumerable;
var __defNormalProp41 = (obj, key2, value) => key2 in obj ? __defProp41(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues41 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp41.call(b2, prop))
      __defNormalProp41(a2, prop, b2[prop]);
  if (__getOwnPropSymbols41)
    for (var prop of __getOwnPropSymbols41(b2)) {
      if (__propIsEnum41.call(b2, prop))
        __defNormalProp41(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps34 = (a2, b2) => __defProps34(a2, __getOwnPropDescs34(b2));
var _sfc_main36 = defineComponent({
  name: "VaColorInput",
  components: {
    VaInput,
    VaColorIndicator
  },
  emits: useStatefulEmits,
  props: __spreadProps34(__spreadValues41({}, useStatefulProps), {
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  }),
  setup: (props, { emit }) => {
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const callPickerDialog = () => {
      var _a;
      return !props.disabled && ((_a = colorPicker.value) == null ? void 0 : _a.click());
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    return {
      valueComputed,
      callPickerDialog,
      colorPicker,
      tabIndexComputed
    };
  }
});
var _hoisted_121 = { class: "va-color-input" };
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  const _component_va_input = resolveComponent("va-input");
  return openBlock(), createElementBlock("div", _hoisted_121, [
    createVNode(_component_va_color_indicator, {
      class: "va-color-input__dot",
      role: "button",
      "aria-label": "open color picker",
      "aria-disabled": _ctx.$props.disabled,
      tabindex: _ctx.tabIndexComputed,
      color: _ctx.valueComputed,
      indicator: _ctx.$props.indicator,
      onClick: _ctx.callPickerDialog,
      onKeydown: [
        withKeys(_ctx.callPickerDialog, ["space"]),
        withKeys(_ctx.callPickerDialog, ["enter"])
      ]
    }, null, 8, ["aria-disabled", "tabindex", "color", "indicator", "onClick", "onKeydown"]),
    createVNode(_component_va_input, {
      class: "va-color-input__input",
      placeholder: "input color",
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      tabindex: _ctx.tabIndexComputed,
      disabled: _ctx.$props.disabled
    }, null, 8, ["modelValue", "tabindex", "disabled"]),
    withDirectives(createBaseVNode("input", {
      ref: "colorPicker",
      type: "color",
      class: "visually-hidden",
      "aria-hidden": "true",
      tabindex: "-1",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
    }, null, 512), [
      [vModelText, _ctx.valueComputed]
    ])
  ]);
}
var _VaColorInput = _export_sfc(_sfc_main36, [["render", _sfc_render35]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-color-input/index.js
var VaColorInput = withConfigTransport(_VaColorInput);

// node_modules/vuestic-ui/dist/esm/src/components/va-color-palette/VaColorPalette.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-color-palette/VaColorPalette.css";
var __defProp42 = Object.defineProperty;
var __defProps35 = Object.defineProperties;
var __getOwnPropDescs35 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols42 = Object.getOwnPropertySymbols;
var __hasOwnProp42 = Object.prototype.hasOwnProperty;
var __propIsEnum42 = Object.prototype.propertyIsEnumerable;
var __defNormalProp42 = (obj, key2, value) => key2 in obj ? __defProp42(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues42 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp42.call(b2, prop))
      __defNormalProp42(a2, prop, b2[prop]);
  if (__getOwnPropSymbols42)
    for (var prop of __getOwnPropSymbols42(b2)) {
      if (__propIsEnum42.call(b2, prop))
        __defNormalProp42(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps35 = (a2, b2) => __defProps35(a2, __getOwnPropDescs35(b2));
var _sfc_main37 = defineComponent({
  name: "VaColorPalette",
  components: { VaColorIndicator },
  emits: useStatefulEmits,
  props: __spreadProps35(__spreadValues42({}, useStatefulProps), {
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    return {
      valueComputed,
      isSelected: (color) => valueComputed.value === color
    };
  }
});
var _hoisted_122 = { class: "va-color-palette" };
var _hoisted_212 = {
  class: "va-color-palette__colors",
  role: "listbox",
  "aria-label": "color selection"
};
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  return openBlock(), createElementBlock("div", _hoisted_122, [
    createBaseVNode("ul", _hoisted_212, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palette, (color, index) => {
        return openBlock(), createBlock(_component_va_color_indicator, {
          key: index,
          role: "option",
          "aria-label": `color ${color}`,
          "aria-selected": _ctx.isSelected(color),
          tabindex: "0",
          modelValue: _ctx.isSelected(color),
          color,
          square: _ctx.indicator === "square",
          "onUpdate:modelValue": ($event) => _ctx.valueComputed = color
        }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
      }), 128))
    ])
  ]);
}
var _VaColorPalette = _export_sfc(_sfc_main37, [["render", _sfc_render36]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-color-palette/index.js
var VaColorPalette = withConfigTransport(_VaColorPalette);

// node_modules/vuestic-ui/dist/esm/src/components/va-content/VaContent.js
init_vue_runtime_esm_bundler();
var _sfc_main38 = {
  name: "VaContent"
};
var _hoisted_123 = { class: "va-typography-block" };
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_123, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaContent = _export_sfc(_sfc_main38, [["render", _sfc_render37]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-content/index.js
var VaContent = withConfigTransport(_VaContent);

// node_modules/vuestic-ui/dist/esm/src/components/va-counter/VaCounter.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/utils/css-utils.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/esm/src/components/va-counter/VaCounter.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-counter/VaCounter.css";
var __defProp43 = Object.defineProperty;
var __defProps36 = Object.defineProperties;
var __getOwnPropDescs36 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols43 = Object.getOwnPropertySymbols;
var __hasOwnProp43 = Object.prototype.hasOwnProperty;
var __propIsEnum43 = Object.prototype.propertyIsEnumerable;
var __defNormalProp43 = (obj, key2, value) => key2 in obj ? __defProp43(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues43 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp43.call(b2, prop))
      __defNormalProp43(a2, prop, b2[prop]);
  if (__getOwnPropSymbols43)
    for (var prop of __getOwnPropSymbols43(b2)) {
      if (__propIsEnum43.call(b2, prop))
        __defNormalProp43(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps36 = (a2, b2) => __defProps36(a2, __getOwnPropDescs36(b2));
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(["change"]);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var _sfc_main39 = defineComponent({
  name: "VaCounter",
  components: { VaInputWrapper, VaIcon, VaButton },
  props: __spreadProps36(__spreadValues43(__spreadValues43({}, useFormProps), useStatefulProps), {
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false },
    min: { type: Number, default: void 0 },
    max: { type: Number, default: void 0 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    messages: { type: [Array, String], default: () => [] },
    width: { type: [String, Number], default: "160px" },
    color: { type: String, default: "primary" },
    outline: { type: Boolean },
    bordered: { type: Boolean },
    increaseIcon: { type: String, default: "add" },
    decreaseIcon: { type: String, default: "remove" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    textColor: { type: String, default: void 0 }
  }),
  emits: [
    "update:modelValue",
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs }) {
    const input = shallowRef();
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit);
    const { valueComputed } = useStateful(props, emit);
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (!props.min || !props.step) {
        return value;
      }
      return props.min + props.step * Math.floor((value - props.min) / props.step);
    };
    const calculateCounterValue = (counterValue) => {
      if (props.min && counterValue < props.min) {
        valueComputed.value = props.min;
        return;
      }
      if (props.max && counterValue > props.max) {
        valueComputed.value = getRoundDownWithStep(props.max);
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (!props.min) {
        return false;
      }
      return Number(valueComputed.value) <= props.min;
    });
    const isMaxReached = computed(() => {
      if (!props.max) {
        return false;
      }
      return props.step ? Number(valueComputed.value) > props.max - props.step : Number(valueComputed.value) >= props.max;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props.readonly || props.disabled);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props.readonly || props.disabled);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - props.step);
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + props.step);
    };
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const decreaseIconProps = computed(() => __spreadValues43({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      name: props.decreaseIcon
    }, !isDecreaseActionDisabled.value && { onClick: decreaseCount }));
    const increaseIconProps = computed(() => __spreadValues43({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      name: props.increaseIcon
    }, !isIncreaseActionDisabled.value && { onClick: increaseCount }));
    const isSquareCorners = computed(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonProps = computed(() => __spreadProps36(__spreadValues43({}, pick_1(props, ["rounded", "color", "textColor"])), {
      flat: props.flat && !props.outline,
      outline: props.flat && props.outline
    }));
    const decreaseButtonProps = computed(() => __spreadProps36(__spreadValues43({}, buttonProps.value), {
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value
    }));
    const increaseButtonProps = computed(() => __spreadProps36(__spreadValues43({}, buttonProps.value), {
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value
    }));
    const inputAttributesComputed = computed(() => __spreadProps36(__spreadValues43(__spreadValues43({
      tabindex: tabIndexComputed.value,
      ariaLabel: props.label || "counter value",
      ariaValuemin: props.min,
      ariaValuemax: props.max
    }, omit_1(attrs, ["class", "style"])), pick_1(props, ["disabled", "min", "max", "step"])), {
      readonly: props.readonly || !props.manualInput
    }));
    const inputWrapperPropsComputed = computed(() => __spreadValues43({}, pick_1(props, ["color", "readonly", "disabled", "messages", "label", "bordered", "outline"])));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value }
    ]);
    const styleComputed = computed(() => __spreadValues43({
      width: safeCSSLength(props.width)
    }, attrs.style || {}));
    const marginComputed = computed(() => safeCSSLength(props.margins));
    return {
      input,
      valueComputed,
      isFocused,
      fieldListeners: createFieldListeners2(emit),
      inputListeners: createInputListeners2(emit),
      inputAttributesComputed,
      inputWrapperPropsComputed,
      setCountInput,
      setCountChange,
      decreaseCount,
      increaseCount,
      decreaseIconProps,
      increaseIconProps,
      decreaseButtonProps,
      increaseButtonProps,
      colorComputed,
      classComputed,
      styleComputed,
      marginComputed,
      focus,
      blur
    };
  }
});
var _hoisted_124 = {
  ref: "input",
  tabindex: "0"
};
var _hoisted_213 = ["value"];
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps({ class: "va-counter" }, __spreadValues43(__spreadValues43({}, _ctx.fieldListeners), _ctx.inputWrapperPropsComputed), {
    class: _ctx.classComputed,
    style: _ctx.styleComputed,
    focused: _ctx.isFocused,
    onKeydown: [
      _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.increaseCount(), ["prevent"]), ["up"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.decreaseCount(), ["prevent"]), ["down"]))
    ]
  }), createSlots({
    default: withCtx(() => [
      !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 0,
        ref: "input",
        class: "va-input__content__input",
        type: "number",
        inputmode: "decimal"
      }, __spreadValues43(__spreadValues43({}, _ctx.inputAttributesComputed), _ctx.inputListeners), {
        value: _ctx.valueComputed,
        onInput: _cache[6] || (_cache[6] = (...args) => _ctx.setCountInput && _ctx.setCountInput(...args)),
        onChange: _cache[7] || (_cache[7] = (...args) => _ctx.setCountChange && _ctx.setCountChange(...args))
      }), null, 16, _hoisted_213)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    _ctx.$props.buttons ? {
      name: "prepend",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__prepend-wrapper",
          style: normalizeStyle({ marginRight: _ctx.marginComputed }),
          onMousedown: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps(__spreadProps36(__spreadValues43({}, slotScope), { decreaseCount: _ctx.decreaseCount }))), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-decrease",
              "aria-label": "decrease counter"
            }, _ctx.decreaseButtonProps, {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.decreaseCount())
            }), null, 16)
          ])
        ], 36)
      ])
    } : {
      name: "prependInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps(__spreadProps36(__spreadValues43({}, slotScope), { decreaseCount: _ctx.decreaseCount }))), () => [
            createVNode(_component_va_icon, mergeProps({ class: "va-counter__icon-decrease" }, _ctx.decreaseIconProps), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$props.buttons ? {
      name: "append",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__append-wrapper",
          style: normalizeStyle({ marginLeft: _ctx.marginComputed }),
          onMousedown: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps(__spreadProps36(__spreadValues43({}, slotScope), { increaseCount: _ctx.increaseCount }))), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-increase",
              "aria-label": "increase counter"
            }, _ctx.increaseButtonProps, {
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.increaseCount())
            }), null, 16)
          ])
        ], 36)
      ])
    } : {
      name: "appendInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.focus(), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps(__spreadProps36(__spreadValues43({}, slotScope), { increaseCount: _ctx.increaseCount }))), () => [
            createVNode(_component_va_icon, mergeProps({ class: "va-counter__icon-increase" }, _ctx.increaseIconProps), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$slots.content ? {
      name: "default",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", _hoisted_124, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(__spreadProps36(__spreadValues43({}, slotScope), { value: Number(_ctx.valueComputed) }))))
        ], 512)
      ])
    } : void 0
  ]), 1040, ["class", "style", "focused"]);
}
var _VaCounter = _export_sfc(_sfc_main39, [["render", _sfc_render38]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-counter/index.js
var VaCounter = withConfigTransport(_VaCounter);

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/VaDataTable.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useColumns.js
init_vue_runtime_esm_bundler();
var sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
var buildTableColumn = (source, initialIndex, props) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase_1(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase_1(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (props) => {
  return Object.keys(merge_1({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));
};
var buildNormalizedColumns = (props) => {
  return props.columns.map((item, index) => buildTableColumn(item, index, props));
};
function useColumns(props) {
  const columnsComputed = computed(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props);
    } else {
      return buildNormalizedColumns(props);
    }
  });
  return {
    columnsComputed
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useRows.js
init_vue_runtime_esm_bundler();
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a = source == null ? void 0 : source.toString) == null ? void 0 : _a.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column))
  };
};
function useRows(columns, props) {
  const rowsComputed = computed(() => props.items.map((rawItem, index) => buildTableRow(rawItem, index, props.itemsTrackBy, columns.value)));
  return {
    rowsComputed
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useFilterable.js
init_vue_runtime_esm_bundler();
function useFilterable(rawRows, props, emit) {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter((row) => row.cells.some((cell) => {
      return typeof props.filterMethod === "function" ? props.filterMethod(cell.source) : cell.value.toLowerCase().includes(props.filter.toLowerCase());
    }));
  });
  watch(filteredRows, () => {
    emit("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  });
  return {
    filteredRows
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useSortable.js
init_vue_runtime_esm_bundler();
function useSortable(columns, filteredRows, props, emit) {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const column = columns.value.find((column2) => column2.name === sortBySync.value);
    if (!column || !column.sortable) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.indexOf(column);
    return [...filteredRows.value].sort((a2, b2) => {
      const firstValue = a2.cells[columnIndex].value;
      const secondValue = b2.cells[columnIndex].value;
      const firstSource = a2.cells[columnIndex].source;
      const secondSource = b2.cells[columnIndex].source;
      if (sortingOrderSync.value === null) {
        return a2.initialIndex - b2.initialIndex;
      } else {
        const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    if (column.name === sortBySync.value) {
      sortingOrderSync.value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      sortingOrderSync.value = column.sortingOptions[0];
    }
  }
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "expand_less" : sortingOrderSync.value === "desc" ? "expand_more" : "unfold_more";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting,
    sortedRows,
    sortingOrderIconName
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/usePaginatedRows.js
init_vue_runtime_esm_bundler();
function usePaginatedRows(sortedRows, props) {
  const paginatedRows = computed(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  return {
    paginatedRows
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useSelectableRow.js
init_vue_runtime_esm_bundler();
function useSelectableRow(paginatedRows, props, emit) {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useStylable.js
init_vue_runtime_esm_bundler();
var prefix = "--va-data-table";
var isFunction2 = (val) => typeof val === "function";
var getClass = (classes) => isFunction2(classes) ? classes() : classes;
var getStyle = (styles) => isFunction2(styles) ? styles() : styles;
function useStyleable(props) {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2, shiftHSLAColor: shiftHSLAColor2 } = useColors();
  const color = computed(() => getColor(props.selectedColor));
  const rowCSSVariables = computed(() => ({
    [`${prefix}-hover-color`]: getHoverColor2(color.value),
    [`${prefix}-selected-color`]: props.selectable ? getFocusColor2(color.value) : void 0
  }));
  const stickyCSSVariables = computed(() => ({
    [`${prefix}-scroll-table-color`]: (props.height || props.stickyHeader || props.stickyFooter) && shiftHSLAColor2(color.value, { l: 40 }),
    [`${prefix}-scroll-table-height`]: props.height ? safeCSSLength(props.height) : void 0
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    rowCSSVariables,
    stickyCSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useBinding.js
var isFunction3 = (val) => typeof val === "function";
var isObject2 = (val) => val !== null && typeof val === "object";
function useBinding(props) {
  const getRowBind = (row) => isFunction3(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject2(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction3(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject2(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/hooks/useAnimationName.js
init_vue_runtime_esm_bundler();
function usePaginatedRows2(props, rows) {
  const animationName = ref("table-transition-shuffle");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows) => {
    const animationType = isDifferentRowLength.value || newRows.length > 50 ? "fade" : "shuffle";
    animationName.value = props.animated ? `table-transition-${animationType}` : "";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationName.value = props.animated ? "table-transition-shuffle" : "";
    }
  });
  return animationName;
}

// node_modules/vuestic-ui/dist/esm/src/components/va-inner-loading/VaInnerLoading.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-inner-loading/VaInnerLoading.css";
var __defProp44 = Object.defineProperty;
var __defProps37 = Object.defineProperties;
var __getOwnPropDescs37 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols44 = Object.getOwnPropertySymbols;
var __hasOwnProp44 = Object.prototype.hasOwnProperty;
var __propIsEnum44 = Object.prototype.propertyIsEnumerable;
var __defNormalProp44 = (obj, key2, value) => key2 in obj ? __defProp44(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues44 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp44.call(b2, prop))
      __defNormalProp44(a2, prop, b2[prop]);
  if (__getOwnPropSymbols44)
    for (var prop of __getOwnPropSymbols44(b2)) {
      if (__propIsEnum44.call(b2, prop))
        __defNormalProp44(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps37 = (a2, b2) => __defProps37(a2, __getOwnPropDescs37(b2));
var _sfc_main40 = defineComponent({
  name: "VaInnerLoading",
  components: { VaIcon: VaIcon2 },
  props: __spreadProps37(__spreadValues44({}, useLoadingProps), {
    color: { type: String },
    icon: { type: String, default: "autorenew" },
    size: { type: Number, default: 30 }
  }),
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return { colorComputed };
  }
});
var _hoisted_125 = { class: "inner-loading" };
var _hoisted_214 = {
  key: 0,
  class: "inner-loading__overlay",
  "aria-hidden": "true"
};
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", _hoisted_125, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_214, [
      createVNode(_component_va_icon, {
        class: "inner-loading__spinner",
        spin: "",
        color: _ctx.colorComputed,
        size: _ctx.$props.size,
        name: _ctx.$props.icon
      }, null, 8, ["color", "size", "name"])
    ])) : createCommentVNode("", true)
  ]);
}
var _VaInnerLoading = _export_sfc(_sfc_main40, [["render", _sfc_render39]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-inner-loading/index.js
var VaInnerLoading = withConfigTransport(_VaInnerLoading);

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/VaDataTable.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-data-table/VaDataTable.css";
var __defProp45 = Object.defineProperty;
var __defProps38 = Object.defineProperties;
var __getOwnPropDescs38 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols45 = Object.getOwnPropertySymbols;
var __hasOwnProp45 = Object.prototype.hasOwnProperty;
var __propIsEnum45 = Object.prototype.propertyIsEnumerable;
var __defNormalProp45 = (obj, key2, value) => key2 in obj ? __defProp45(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues45 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp45.call(b2, prop))
      __defNormalProp45(a2, prop, b2[prop]);
  if (__getOwnPropSymbols45)
    for (var prop of __getOwnPropSymbols45(b2)) {
      if (__propIsEnum45.call(b2, prop))
        __defNormalProp45(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps38 = (a2, b2) => __defProps38(a2, __getOwnPropDescs38(b2));
var _sfc_main41 = defineComponent({
  name: "VaDataTable",
  components: {
    VaInnerLoading,
    VaCheckbox,
    VaIcon: VaIcon2
  },
  inheritAttrs: false,
  props: {
    columns: { type: Array, default: () => [] },
    items: { type: Array, default: () => [] },
    itemsTrackBy: { type: [String, Function], default: "" },
    modelValue: { type: Array },
    sortingOrder: { type: String },
    sortBy: { type: String },
    sortingOptions: {
      type: Array,
      default: () => ["asc", "desc", null],
      validator: sortingOptionsValidator
    },
    filter: { type: String, default: "" },
    filterMethod: { type: Function },
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    animated: { type: Boolean, default: true },
    selectable: { type: Boolean, default: false },
    selectMode: { type: String, default: "multiple" },
    selectedColor: { type: String, default: "primary" },
    perPage: { type: Number },
    currentPage: { type: Number },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    allowFooterSorting: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    stickyHeader: { type: Boolean, default: false },
    stickyFooter: { type: Boolean, default: false },
    height: { type: [String, Number] },
    rowBind: { type: null },
    cellBind: { type: null }
  },
  emits: [
    "update:modelValue",
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu"
  ],
  setup(props, { attrs, emit }) {
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props, emit);
    const { paginatedRows } = usePaginatedRows(sortedRows, props);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected
    } = useSelectableRow(paginatedRows, props, emit);
    const {
      rowCSSVariables,
      stickyCSSVariables,
      getHeaderCSSVariables,
      getCellCSSVariables,
      getFooterCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStyleable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = usePaginatedRows2(props, paginatedRows);
    const showNoDataHtml = computed(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      if (props.clickable) {
        emit(name, {
          event,
          item: row.source,
          itemIndex: row.initialIndex
        });
      }
    };
    const computedAttributes = computed(() => ({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        attrs.class
      ],
      style: [stickyCSSVariables.value, attrs.style]
    }));
    const computedTableAttributes = computed(() => __spreadProps38(__spreadValues45({}, omit_1(attrs, ["class", "style"])), {
      class: pick_1(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const getColumnAriaSortOrder = (columnName) => sortingOrderSync.value && sortBySync.value === columnName ? sortingOrderSync.value === "asc" ? "ascending" : "descending" : "none";
    return {
      columnsComputed,
      rows: paginatedRows,
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortingOrderIconName,
      rowCSSVariables,
      getHeaderCSSVariables,
      getCellCSSVariables,
      getFooterCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2,
      showNoDataHtml,
      showNoDataFilteredHtml,
      onRowClickHandler,
      computedAttributes,
      computedTableAttributes,
      animationName,
      getColumnAriaSortOrder,
      getRowBind,
      getCellBind
    };
  }
});
var _hoisted_126 = { key: 0 };
var _hoisted_215 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var _hoisted_37 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_46 = ["aria-sort", "aria-label", "title", "onClick", "onKeydown"];
var _hoisted_56 = ["tabindex"];
var _hoisted_65 = { key: 0 };
var _hoisted_73 = { key: "showNoDataHtml" };
var _hoisted_82 = ["colspan", "innerHTML"];
var _hoisted_92 = { key: "showNoDataFilteredHtml" };
var _hoisted_10 = ["colspan", "innerHTML"];
var _hoisted_11 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_127 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var _hoisted_132 = {
  key: 0,
  class: "va-data-table__table-th"
};
var _hoisted_142 = ["title", "aria-label", "onClick", "onKeydown"];
var _hoisted_152 = ["tabindex"];
var _hoisted_162 = { key: 0 };
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_inner_loading = resolveComponent("va-inner-loading");
  return openBlock(), createBlock(_component_va_inner_loading, mergeProps({
    class: "va-data-table",
    "aria-live": "polite"
  }, _ctx.computedAttributes, {
    loading: _ctx.loading,
    color: _ctx.loadingColor
  }), {
    default: withCtx(() => [
      createBaseVNode("table", mergeProps({ class: "va-data-table__table" }, _ctx.computedTableAttributes), [
        "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_126, [
          renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(_ctx.columnsComputed)))
        ])) : createCommentVNode("", true),
        createBaseVNode("thead", {
          class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }])
        }, [
          renderSlot(_ctx.$slots, "headerPrepend"),
          !_ctx.hideDefaultHeader ? (openBlock(), createElementBlock("tr", _hoisted_215, [
            _ctx.selectable ? (openBlock(), createElementBlock("th", _hoisted_37, [
              _ctx.selectMode === "multiple" ? (openBlock(), createBlock(_component_va_checkbox, {
                key: 0,
                "aria-label": "select all rows",
                "model-value": _ctx.severalRowsSelected ? "idl" : _ctx.allRowsSelected,
                "true-value": true,
                "false-value": false,
                color: _ctx.selectedColor,
                "indeterminate-value": "idl",
                indeterminate: "",
                "onUpdate:modelValue": _ctx.toggleBulkSelection
              }, null, 8, ["model-value", "color", "onUpdate:modelValue"])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
              return openBlock(), createElementBlock("th", {
                key: column.name,
                scope: "col",
                "aria-sort": _ctx.getColumnAriaSortOrder(column.name),
                "aria-label": column.sortable ? `sort column by ${column.label}` : void 0,
                title: column.thTitle,
                class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                style: normalizeStyle([_ctx.getHeaderCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                onClick: withModifiers(($event) => column.sortable && _ctx.toggleSorting(column), ["exact"]),
                onKeydown: withKeys(withModifiers(($event) => column.sortable && _ctx.toggleSorting(column), ["stop"]), ["enter"])
              }, [
                createBaseVNode("div", {
                  class: "va-data-table__table-th-wrapper",
                  tabindex: column.sortable ? 0 : -1
                }, [
                  `header(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_65, [
                    renderSlot(_ctx.$slots, `header(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                  ])) : renderSlot(_ctx.$slots, "header", normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
                    createBaseVNode("span", null, toDisplayString(column.label), 1)
                  ]),
                  column.sortable ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: "va-data-table__table-th-sorting",
                    "aria-hidden": "true",
                    onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                    }, ["prevent"]))
                  }, [
                    createVNode(_component_va_icon, {
                      name: _ctx.sortingOrderIconName,
                      size: "small",
                      class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                    }, null, 8, ["name", "class"])
                  ], 32)) : createCommentVNode("", true)
                ], 8, _hoisted_56)
              ], 46, _hoisted_46);
            }), 128))
          ])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "headerAppend")
        ], 2),
        createBaseVNode("tbody", {
          class: "va-data-table__table-tbody",
          style: normalizeStyle(_ctx.rowCSSVariables)
        }, [
          renderSlot(_ctx.$slots, "bodyPrepend"),
          createVNode(TransitionGroup, {
            name: _ctx.animationName,
            appear: ""
          }, {
            default: withCtx(() => [
              _ctx.showNoDataHtml ? (openBlock(), createElementBlock("tr", _hoisted_73, [
                createBaseVNode("td", {
                  colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                  innerHTML: _ctx.noDataHtml,
                  class: "no-data"
                }, null, 8, _hoisted_82)
              ])) : _ctx.showNoDataFilteredHtml ? (openBlock(), createElementBlock("tr", _hoisted_92, [
                createBaseVNode("td", {
                  colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                  innerHTML: _ctx.noDataFilteredHtml,
                  class: "no-data"
                }, null, 8, _hoisted_10)
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row) => {
                return openBlock(), createElementBlock("tr", mergeProps({
                  key: `table-row_${row.initialIndex}`,
                  class: ["va-data-table__table-tr", [{ selected: _ctx.isRowSelected(row) }]]
                }, _ctx.getRowBind(row), {
                  onClick: ($event) => _ctx.onRowClickHandler("row:click", $event, row),
                  onDblclick: ($event) => _ctx.onRowClickHandler("row:dblclick", $event, row),
                  onContextmenu: ($event) => _ctx.onRowClickHandler("row:contextmenu", $event, row)
                }), [
                  _ctx.selectable ? (openBlock(), createElementBlock("td", {
                    class: "va-data-table__table-td va-data-table__table-cell-select",
                    key: `selectable_${row.initialIndex}`,
                    onSelectstart: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["prevent"]))
                  }, [
                    createVNode(_component_va_checkbox, {
                      "model-value": _ctx.isRowSelected(row),
                      color: _ctx.selectedColor,
                      "aria-label": `select row ${row.initialIndex}`,
                      onClick: [
                        withModifiers(($event) => _ctx.shiftSelectRows(row), ["shift", "exact", "stop"]),
                        withModifiers(($event) => _ctx.ctrlSelectRow(row), ["ctrl", "exact", "stop"]),
                        withModifiers(($event) => _ctx.ctrlSelectRow(row), ["exact", "stop"])
                      ]
                    }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                  ], 32)) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell) => {
                    return openBlock(), createElementBlock("td", mergeProps({
                      key: `table-cell_${cell.column.name + cell.rowIndex}`,
                      class: ["va-data-table__table-td", _ctx.getClass(cell.column.tdClass)],
                      style: [_ctx.getCellCSSVariables(cell), _ctx.getStyle(cell.column.tdStyle)]
                    }, _ctx.getCellBind(cell, row)), [
                      `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, cell))) : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, cell)), () => [
                        createTextVNode(toDisplayString(cell.value), 1)
                      ])
                    ], 16);
                  }), 128))
                ], 16, _hoisted_11);
              }), 128))
            ]),
            _: 3
          }, 8, ["name"]),
          renderSlot(_ctx.$slots, "bodyAppend")
        ], 4),
        _ctx.footerClone ? (openBlock(), createElementBlock("tfoot", {
          key: 1,
          class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }])
        }, [
          renderSlot(_ctx.$slots, "footerPrepend"),
          !_ctx.hideDefaultHeader ? (openBlock(), createElementBlock("tr", _hoisted_127, [
            _ctx.selectable ? (openBlock(), createElementBlock("th", _hoisted_132, [
              _ctx.selectMode === "multiple" ? (openBlock(), createBlock(_component_va_checkbox, {
                key: 0,
                "aria-label": "select all rows",
                "model-value": _ctx.severalRowsSelected ? "idl" : _ctx.allRowsSelected,
                "true-value": true,
                "false-value": false,
                color: _ctx.selectedColor,
                "indeterminate-value": "idl",
                indeterminate: "",
                "onUpdate:modelValue": _ctx.toggleBulkSelection
              }, null, 8, ["model-value", "color", "onUpdate:modelValue"])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
              return openBlock(), createElementBlock("th", {
                key: column.name,
                title: column.thTitle,
                "aria-label": _ctx.allowFooterSorting && column.sortable ? `sort column by ${column.label}` : void 0,
                class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                style: normalizeStyle([_ctx.getFooterCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                onClick: withModifiers(($event) => _ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column), ["exact"]),
                onKeydown: withKeys(withModifiers(($event) => _ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column), ["stop"]), ["enter"])
              }, [
                createBaseVNode("div", {
                  class: "va-data-table__table-th-wrapper",
                  tabindex: _ctx.allowFooterSorting && column.sortable ? 0 : -1
                }, [
                  `footer(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_162, [
                    renderSlot(_ctx.$slots, `footer(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                  ])) : renderSlot(_ctx.$slots, "footer", normalizeProps(mergeProps({ key: 1 }, column)), () => [
                    createBaseVNode("span", null, toDisplayString(column.label), 1)
                  ]),
                  _ctx.allowFooterSorting && column.sortable ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: "va-data-table__table-th-sorting",
                    onSelectstart: _cache[2] || (_cache[2] = withModifiers(() => {
                    }, ["prevent"]))
                  }, [
                    createVNode(_component_va_icon, {
                      name: _ctx.sortingOrderIconName,
                      size: "small",
                      class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                    }, null, 8, ["name", "class"])
                  ], 32)) : createCommentVNode("", true)
                ], 8, _hoisted_152)
              ], 46, _hoisted_142);
            }), 128))
          ])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "footerAppend")
        ], 2)) : createCommentVNode("", true)
      ], 16)
    ]),
    _: 3
  }, 16, ["loading", "color"]);
}
var _VaDataTable = _export_sfc(_sfc_main41, [["render", _sfc_render40]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-data-table/index.js
var VaDataTable = withConfigTransport(_VaDataTable);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/VaDateInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useParsable.js
init_vue_runtime_esm_bundler();
var useParsable = (parsable, parse2, format) => {
  const text = computed({
    get() {
      const value2 = parsable.value;
      if (typeof value2 === "string") {
        return value2;
      }
      return format(value2);
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = v2;
      } else {
        parsable.value = parse2(v2);
      }
    }
  });
  const value = computed({
    get() {
      if (typeof parsable.value === "string") {
        return parse2(parsable.value);
      }
      return parsable.value;
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = format(v2);
      } else {
        parsable.value = v2;
      }
    }
  });
  return {
    text,
    value
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/hooks/sync-prop.js
init_vue_runtime_esm_bundler();
function useSyncProp2(propRef, propName, emit, defaultValue) {
  if (defaultValue === void 0) {
    return {
      syncProp: computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return propRef.value;
        }
      })
    };
  }
  const statefulValue = ref(defaultValue);
  return {
    syncProp: computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return (propRef == null ? void 0 : propRef.value) === void 0 ? statefulValue.value : propRef.value;
      }
    })
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/hooks/range-model-value-guard.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/hooks/input-text-parser.js
init_vue_runtime_esm_bundler();
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d2) => isDate_1(d2) && !isNaN(d2.getTime());
var useDateParser = (props) => {
  const isMultipleDates = (text) => text.includes(props.delimiter);
  const isRange3 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props.parseDate || defaultParseDateFunction)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange3(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/hooks/model-value-parser.js
var isRange = (date) => {
  return typeof date === "object" && ("start" in date || "end" in date);
};
var parseSingleDate = (date) => typeof date === "string" ? defaultParseDateFunction(date) : new Date(date);
var parseModelValue = (date) => {
  if (Array.isArray(date)) {
    return date.map(parseSingleDate);
  }
  if (isRange(date)) {
    return {
      start: isNil_1(date.start) ? date.start : parseSingleDate(date.start),
      end: isNil_1(date.end) ? date.end : parseSingleDate(date.end)
    };
  }
  return parseSingleDate(date);
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/hooks/range-model-value-guard.js
var useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {
  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange(bufferValue.value)) {
      bufferValue.value = modelValue.value && parseValue(modelValue.value);
    }
  };
  return {
    valueComputed,
    reset
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/utils/date-utils.js
var isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = new Date();
  date.setFullYear(year);
  return date;
};
var isRange2 = (value) => {
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate = (value) => isDate_1(value);
var isDates = (value) => Array.isArray(value);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/VaDatePicker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/hooks/view.js
init_vue_runtime_esm_bundler();
var __defProp46 = Object.defineProperty;
var __defProps39 = Object.defineProperties;
var __getOwnPropDescs39 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols46 = Object.getOwnPropertySymbols;
var __hasOwnProp46 = Object.prototype.hasOwnProperty;
var __propIsEnum46 = Object.prototype.propertyIsEnumerable;
var __defNormalProp46 = (obj, key2, value) => key2 in obj ? __defProp46(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues46 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp46.call(b2, prop))
      __defNormalProp46(a2, prop, b2[prop]);
  if (__getOwnPropSymbols46)
    for (var prop of __getOwnPropSymbols46(b2)) {
      if (__propIsEnum46.call(b2, prop))
        __defNormalProp46(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps39 = (a2, b2) => __defProps39(a2, __getOwnPropDescs39(b2));
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return __spreadProps39(__spreadValues46({}, view), { year: view.year + 1, month: JANUARY_MONTH_INDEX });
  } else {
    return __spreadProps39(__spreadValues46({}, view), { month: view.month + 1 });
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return __spreadProps39(__spreadValues46({}, view), { year: view.year - 1, month: DECEMBER_MONTH_INDEX });
  } else {
    return __spreadProps39(__spreadValues46({}, view), { month: view.month - 1 });
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate_1(modelValue)) {
    return modelValue;
  }
  if (isDate_1(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate_1(modelValue[0])) {
    return modelValue[0];
  }
  return new Date();
};
var useView = (props, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = __spreadValues46({
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth()
  }, defaultOverride);
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return __spreadValues46(__spreadValues46({}, statefulView.value), props.view);
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = __spreadProps39(__spreadValues46({}, syncView.value), { year: syncView.value.year + 1 });
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = __spreadProps39(__spreadValues46({}, syncView.value), { year: syncView.value.year - 1 });
    }
  };
  return {
    syncView,
    next,
    prev
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/hooks/grid-keyboard-navigation.js
init_vue_runtime_esm_bundler();
function isUndefined(t2) {
  return t2 === void 0;
}
var useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked = false;
  const onMousedown = () => {
    previouslyClicked = true;
  };
  const onFocus = () => {
    if (previouslyClicked) {
      return;
    }
    previouslyClicked = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e2) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e2.key)) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    if (e2.key === "Enter" || e2.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e2.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e2.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e2.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e2.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/hooks/use-picker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/hooks/model-value-helper.js
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate(modelValue)) {
    return "single";
  } else if (isRange2(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange2(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d2) => dateEqual(d2, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props.modelValue.filter((d2) => !dateEqual(d2, date)));
      } else {
        emit("update:modelValue", [...props.modelValue, date].sort((a2, b2) => a2.getTime() - b2.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/hooks/use-picker.js
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(props, emit, datesEqual);
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d2) => datesEqual(d2, date));
    } else if (isRange2(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange2(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDayPicker/va-date-picker-calendar-hook.js
init_vue_runtime_esm_bundler();
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k2) => k2 + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a;
    if (options && ((_a = options.firstWeekday) == null ? void 0 : _a.value) === "Monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d2) => new Date(view.value.year, view.value.month - 1, d2));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d2) => new Date(view.value.year, view.value.month, d2));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d2) => new Date(view.value.year, view.value.month + 1, d2))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDatePickerCell.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDatePickerCell.css";
var _sfc_main42 = defineComponent({
  name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const onClick = () => {
      if (!props.disabled) {
        emit("click");
      }
    };
    return {
      onClick
    };
  }
});
var _hoisted_128 = {
  key: 0,
  class: "va-date-picker-cell va-date-picker-cell_clear"
};
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.hidden ? (openBlock(), createElementBlock("div", _hoisted_128)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["va-date-picker-cell", {
      "va-date-picker-cell_other-month": _ctx.otherMonth,
      "va-date-picker-cell_today": _ctx.highlightToday && _ctx.today,
      "va-date-picker-cell_in-range": _ctx.inRange,
      "va-date-picker-cell_disabled": _ctx.disabled,
      "va-date-picker-cell_highlighted-weekend": _ctx.highlightWeekend && _ctx.weekend,
      "va-date-picker-cell_selected": _ctx.selected,
      "va-date-picker-cell_focused": _ctx.focused,
      "va-date-picker-cell_readonly": _ctx.readonly
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
    onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["prevent", "stop"]), ["space", "enter"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34));
}
var VaDatePickerCell = _export_sfc(_sfc_main42, [["render", _sfc_render41]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.css";
var __defProp47 = Object.defineProperty;
var __defProps40 = Object.defineProperties;
var __getOwnPropDescs40 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols47 = Object.getOwnPropertySymbols;
var __hasOwnProp47 = Object.prototype.hasOwnProperty;
var __propIsEnum47 = Object.prototype.propertyIsEnumerable;
var __defNormalProp47 = (obj, key2, value) => key2 in obj ? __defProp47(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues47 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp47.call(b2, prop))
      __defNormalProp47(a2, prop, b2[prop]);
  if (__getOwnPropSymbols47)
    for (var prop of __getOwnPropSymbols47(b2)) {
      if (__propIsEnum47.call(b2, prop))
        __defNormalProp47(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps40 = (a2, b2) => __defProps40(a2, __getOwnPropDescs40(b2));
var VaDatePickerCellProps = extractComponentProps(VaDatePickerCell, ["date", "selectedValue", "focusedDate", "focused"]);
var _sfc_main43 = defineComponent({
  name: "VaDayPicker",
  components: { VaDatePickerCell },
  props: __spreadProps40(__spreadValues47({}, VaDatePickerCellProps), {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false }
  }),
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(props, { emit }) {
    const { firstWeekday, weekdayNames, view } = toRefs(props);
    const VaDayPickerCellPropValues = filterComponentProps(props, VaDatePickerCellProps);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value === "Sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props, emit);
    const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return {
      hoveredIndex,
      calendarDates,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isOtherMonth,
      isDateDisabled,
      isDateWeekend,
      containerAttributes,
      weekdayNamesComputed,
      VaDayPickerCellPropValues,
      focusedCellIndex
    };
  }
});
var _hoisted_129 = ["onMouseenter"];
var _hoisted_216 = { class: "va-date-picker-cell__day" };
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, _ctx.containerAttributes), [
    !_ctx.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.weekdayNamesComputed, (weekday) => {
      return openBlock(), createElementBlock("div", {
        key: weekday,
        class: "va-day-picker__weekday"
      }, [
        renderSlot(_ctx.$slots, "weekday", {}, () => [
          createTextVNode(toDisplayString(weekday), 1)
        ])
      ]);
    }), 128)) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.calendarDates, (date, index) => {
      return openBlock(), createElementBlock("div", {
        class: "va-day-picker__calendar__day-wrapper",
        key: index,
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          hidden: _ctx.isOtherMonth(date) && !_ctx.showOtherMonths,
          today: _ctx.isToday(date),
          selected: _ctx.isSelected(date),
          "in-range": _ctx.isInRange(date),
          "other-month": _ctx.isOtherMonth(date),
          weekend: _ctx.isDateWeekend(date),
          disabled: _ctx.isDateDisabled(date),
          focused: _ctx.hoveredIndex === index,
          "highlight-today": _ctx.highlightToday,
          "highlight-weekend": _ctx.highlightWeekend,
          readonly: _ctx.readonly,
          onClick: ($event) => {
            _ctx.onClick(date);
            _ctx.focusedCellIndex = index;
          }
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_216, [
              renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                createTextVNode(toDisplayString(date.getDate()), 1)
              ])
            ])
          ]),
          _: 2
        }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "onClick"])
      ], 40, _hoisted_129);
    }), 128))
  ], 16);
}
var VaDayPicker = _export_sfc(_sfc_main43, [["render", _sfc_render42]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.css";
var __defProp48 = Object.defineProperty;
var __defProps41 = Object.defineProperties;
var __getOwnPropDescs41 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols48 = Object.getOwnPropertySymbols;
var __hasOwnProp48 = Object.prototype.hasOwnProperty;
var __propIsEnum48 = Object.prototype.propertyIsEnumerable;
var __defNormalProp48 = (obj, key2, value) => key2 in obj ? __defProp48(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues48 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp48.call(b2, prop))
      __defNormalProp48(a2, prop, b2[prop]);
  if (__getOwnPropSymbols48)
    for (var prop of __getOwnPropSymbols48(b2)) {
      if (__propIsEnum48.call(b2, prop))
        __defNormalProp48(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps41 = (a2, b2) => __defProps41(a2, __getOwnPropDescs41(b2));
var _sfc_main44 = defineComponent({
  name: "VaDatePickerHeader",
  components: { VaButton: VaButton2 },
  emits: ["update:view"],
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String, default: void 0 },
    disabled: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { syncView, prev, next } = useView(props, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = __spreadProps41(__spreadValues48({}, syncView.value), { type: "month" });
      } else if (syncView.value.type === "month") {
        syncView.value = __spreadProps41(__spreadValues48({}, syncView.value), { type: "year" });
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    return { prev, next, changeView, switchView, syncView };
  }
});
var _hoisted_130 = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
var _hoisted_217 = { class: "va-date-picker__header__text" };
var _hoisted_38 = { class: "ml-1" };
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.syncView.type !== "year" ? (openBlock(), createElementBlock("div", _hoisted_130, [
    renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: _ctx.prev })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "chevron_left",
        flat: "",
        size: "small",
        color: _ctx.color,
        textColor: "dark",
        "aria-label": "next period",
        onClick: _ctx.prev
      }, null, 8, ["disabled", "color", "onClick"])
    ]),
    createBaseVNode("div", _hoisted_217, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year, month: _ctx.syncView.month, monthNames: _ctx.monthNames, view: _ctx.syncView, changeView: _ctx.changeView, switchView: _ctx.switchView })), () => [
        createVNode(_component_va_button, {
          disabled: _ctx.$props.disabled,
          flat: "",
          size: "small",
          rounded: false,
          color: _ctx.color,
          textColor: "dark",
          "aria-label": "switch view",
          onClick: _ctx.switchView
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year })), () => [
              createTextVNode(toDisplayString(_ctx.syncView.year), 1)
            ]),
            _ctx.syncView.type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: _ctx.syncView.month })), () => [
              createBaseVNode("span", _hoisted_38, toDisplayString(_ctx.monthNames[_ctx.syncView.month]), 1)
            ]) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["disabled", "color", "onClick"])
      ])
    ]),
    renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: _ctx.next })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "chevron_right",
        flat: "",
        size: "small",
        color: _ctx.color,
        textColor: "dark",
        "aria-label": "previous period",
        onClick: _ctx.next
      }, null, 8, ["disabled", "color", "onClick"])
    ])
  ])) : createCommentVNode("", true);
}
var VaDatePickerHeader = _export_sfc(_sfc_main44, [["render", _sfc_render43]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.css";
var _sfc_main45 = defineComponent({
  name: "VaMonthPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(props, { emit }) {
    const { view } = toRefs(props);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props, emit);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      months,
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isDisabled,
      containerAttributes,
      focusedCellIndex
    };
  }
});
var _hoisted_131 = ["onMouseenter"];
function _sfc_render44(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, _ctx.containerAttributes), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.months, (month, monthIndex) => {
      return openBlock(), createElementBlock("div", {
        key: monthIndex,
        class: "va-month-picker__month-wrapper",
        onMouseenter: ($event) => _ctx.hoveredIndex = monthIndex,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          "in-range": !!_ctx.isInRange(month),
          selected: !!_ctx.isSelected(month),
          disabled: !!_ctx.isDisabled(month),
          today: !!_ctx.isToday(month),
          focused: _ctx.hoveredIndex === monthIndex,
          "highlight-today": _ctx.highlightToday,
          readonly: _ctx.readonly,
          onClick: ($event) => {
            _ctx.onClick(month);
            _ctx.focusedCellIndex = monthIndex;
          }
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: _ctx.monthNames[monthIndex] })), () => [
              createTextVNode(toDisplayString(_ctx.monthNames[monthIndex]), 1)
            ])
          ]),
          _: 2
        }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "onClick"])
      ], 40, _hoisted_131);
    }), 128))
  ], 16);
}
var VaMonthPicker = _export_sfc(_sfc_main45, [["render", _sfc_render44]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.css";
var _sfc_main46 = defineComponent({
  name: "VaYearPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: Number, default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: Number, default: () => new Date().getFullYear() + 50 },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(props, { emit }) {
    const rootNode = shallowRef();
    const { view } = toRefs(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i2) => createYearDate(start + i2));
    };
    const years = computed(() => generateYearsArray(props.startYear, props.endYear));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props, emit);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      hoveredIndex,
      years,
      rootNode,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isYearDisabled,
      focusedCellIndex,
      containerAttributes
    };
  }
});
function _sfc_render45(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "rootNode",
    class: "va-year-picker"
  }, _ctx.containerAttributes, {
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
    }, ["prevent"]), ["space"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
      return openBlock(), createBlock(_component_va_date_picker_cell, {
        key: year.toString(),
        "in-range": _ctx.isInRange(year),
        selected: _ctx.isSelected(year),
        disabled: _ctx.isYearDisabled(year),
        today: _ctx.isToday(year),
        focused: _ctx.focusedCellIndex === index,
        "highlight-today": _ctx.highlightToday,
        readonly: _ctx.readonly,
        onClick: ($event) => {
          _ctx.onClick(year);
          _ctx.focusedCellIndex = index;
        },
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(year.getFullYear()), 1)
        ]),
        _: 2
      }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "onClick", "onMouseenter"]);
    }), 128))
  ], 16);
}
var VaYearPicker = _export_sfc(_sfc_main46, [["render", _sfc_render45]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/VaDatePicker.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/VaDatePicker.css";
var __defProp49 = Object.defineProperty;
var __defProps42 = Object.defineProperties;
var __getOwnPropDescs42 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols49 = Object.getOwnPropertySymbols;
var __hasOwnProp49 = Object.prototype.hasOwnProperty;
var __propIsEnum49 = Object.prototype.propertyIsEnumerable;
var __defNormalProp49 = (obj, key2, value) => key2 in obj ? __defProp49(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues49 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp49.call(b2, prop))
      __defNormalProp49(a2, prop, b2[prop]);
  if (__getOwnPropSymbols49)
    for (var prop of __getOwnPropSymbols49(b2)) {
      if (__propIsEnum49.call(b2, prop))
        __defNormalProp49(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps42 = (a2, b2) => __defProps42(a2, __getOwnPropDescs42(b2));
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var _sfc_main47 = defineComponent({
  name: "VaDatePicker",
  components: { VaDayPicker, VaDatePickerHeader, VaMonthPicker, VaYearPicker },
  props: __spreadProps42(__spreadValues49(__spreadValues49(__spreadValues49(__spreadValues49(__spreadValues49({}, useStatefulProps), extractComponentProps(VaDatePickerHeader)), extractComponentProps(VaDayPicker)), extractComponentProps(VaMonthPicker)), extractComponentProps(VaYearPicker)), {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  }),
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(VaDatePickerHeader),
    ...extractComponentEmits(VaYearPicker),
    ...extractComponentEmits(VaDayPicker),
    ...extractComponentEmits(VaMonthPicker)
  ],
  setup(props, { emit }) {
    const currentPicker = ref();
    const { valueComputed } = useStateful(props, emit);
    const { syncView } = useView(props, emit, { type: props.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const colorsStyle = colorsToCSSVariable({
      color: props.color,
      "weekends-color": props.weekendsColor
    }, "va-date-picker");
    const focusCurrentPicker = () => {
      var _a;
      return (_a = currentPicker.value) == null ? void 0 : _a.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    return {
      dayPickerProps: filterComponentProps(props, extractComponentProps(VaDayPicker)),
      headerProps: filterComponentProps(props, extractComponentProps(VaDatePickerHeader)),
      monthPickerProps: filterComponentProps(props, extractComponentProps(VaMonthPicker)),
      yearPickerProps: filterComponentProps(props, extractComponentProps(VaYearPicker)),
      syncView,
      classComputed,
      valueComputed,
      onDayModelValueUpdate,
      onMonthClick,
      onMonthModelValueUpdate,
      onYearClick,
      onYearModelValueUpdate,
      colorsStyle,
      currentPicker,
      focusCurrentPicker,
      isPickerReadonly
    };
  }
});
var _hoisted_133 = { class: "va-date-picker__picker-wrapper" };
function _sfc_render46(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_header = resolveComponent("va-date-picker-header");
  const _component_va_day_picker = resolveComponent("va-day-picker");
  const _component_va_month_picker = resolveComponent("va-month-picker");
  const _component_va_year_picker = resolveComponent("va-year-picker");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-date-picker", _ctx.classComputed]),
    style: normalizeStyle(_ctx.colorsStyle)
  }, [
    createVNode(_component_va_date_picker_header, mergeProps(_ctx.headerProps, {
      view: _ctx.syncView,
      "onUpdate:view": _cache[0] || (_cache[0] = ($event) => _ctx.syncView = $event)
    }), createSlots({ _: 2 }, [
      renderList(_ctx.$slots, (_2, name) => {
        return {
          name,
          fn: withCtx((bind) => [
            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
          ])
        };
      })
    ]), 1040, ["view"]),
    createBaseVNode("div", _hoisted_133, [
      _ctx.syncView.type === "day" ? (openBlock(), createBlock(_component_va_day_picker, mergeProps({
        key: 0,
        ref: "currentPicker"
      }, _ctx.dayPickerProps, {
        "model-value": _ctx.valueComputed,
        view: _ctx.syncView,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("day"),
        "onUpdate:modelValue": _ctx.onDayModelValueUpdate,
        "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
        "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["model-value", "view", "readonly", "onUpdate:modelValue"])) : createCommentVNode("", true),
      _ctx.syncView.type === "month" ? (openBlock(), createBlock(_component_va_month_picker, mergeProps({
        key: 1,
        ref: "currentPicker"
      }, _ctx.monthPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("month"),
        "onUpdate:modelValue": _ctx.onMonthModelValueUpdate,
        "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
        "onClick:month": _ctx.onMonthClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:month"])) : createCommentVNode("", true),
      _ctx.syncView.type === "year" ? (openBlock(), createBlock(_component_va_year_picker, mergeProps({
        key: 2,
        ref: "currentPicker"
      }, _ctx.yearPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("year"),
        "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
        "onUpdate:modelValue": _ctx.onYearModelValueUpdate,
        "onClick:year": _ctx.onYearClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:year"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var _VaDatePicker = _export_sfc(_sfc_main47, [["render", _sfc_render46]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/VaDateInput.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-date-input/VaDateInput.css";
var __defProp50 = Object.defineProperty;
var __defProps43 = Object.defineProperties;
var __getOwnPropDescs43 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols50 = Object.getOwnPropertySymbols;
var __hasOwnProp50 = Object.prototype.hasOwnProperty;
var __propIsEnum50 = Object.prototype.propertyIsEnumerable;
var __defNormalProp50 = (obj, key2, value) => key2 in obj ? __defProp50(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues50 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp50.call(b2, prop))
      __defNormalProp50(a2, prop, b2[prop]);
  if (__getOwnPropSymbols50)
    for (var prop of __getOwnPropSymbols50(b2)) {
      if (__propIsEnum50.call(b2, prop))
        __defNormalProp50(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps43 = (a2, b2) => __defProps43(a2, __getOwnPropDescs43(b2));
var VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var VaDatePickerProps = extractComponentProps(_VaDatePicker);
var _sfc_main48 = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon: VaIcon2
  },
  props: __spreadProps43(__spreadValues50(__spreadValues50(__spreadValues50(__spreadValues50({}, useClearableProps), VaInputWrapperProps), VaDatePickerProps), useValidationProps), {
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d2) => d2.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "calendar_today" }
  }),
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp2(isOpen, "is-open", emit, false);
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d2) => props.formatDate(d2)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange2(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => {
      statefulValue.value = props.clearValue;
      emit("clear");
    };
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e2) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e2 == null ? void 0 : e2.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const { computedError, computedErrorMessages, listeners, validationAriaAttributes } = useValidation(props, emit, reset, focus);
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const iconProps = computed(() => ({
      name: props.icon,
      color: props.color,
      size: "small",
      class: "va-date-input__icon"
    }));
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const computedInputWrapperProps = computed(() => __spreadProps43(__spreadValues50({}, filterComponentProps(props, VaInputWrapperProps).value), {
      focused: isFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const inputAttributesComputed = computed(() => __spreadValues50(__spreadValues50({
      readonly: props.readonly || !props.manualInput,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || "selected date",
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    return {
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      isFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(props, VaDatePickerProps),
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur,
      iconTabindexComputed
    };
  }
});
function _sfc_render47(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.isOpenSync = $event),
    class: normalizeClass(["va-date-input", _ctx.$attrs.class]),
    "inner-anchor-selector": ".va-input-wrapper__field",
    style: normalizeStyle(_ctx.$attrs.style),
    offset: [2, 0],
    "close-on-content-click": false,
    stateful: false,
    disabled: _ctx.$props.disabled,
    "keyboard-navigation": "",
    onOpen: _ctx.focusDatePicker,
    onClose: _ctx.focus
  }, {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputAttributes: _ctx.inputAttributesComputed, inputWrapperProps: _ctx.inputWrapperProps, inputListeners: _ctx.inputListeners })), () => [
        createVNode(_component_va_input_wrapper, mergeProps(_ctx.inputWrapperProps, { class: "va-date-input__anchor" }), createSlots({
          default: withCtx(() => [
            createBaseVNode("input", mergeProps({
              ref: "input",
              class: "va-date-input__input"
            }, _ctx.inputAttributesComputed, toHandlers(_ctx.inputListeners), {
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
            }), null, 16)
          ]),
          prependInner: withCtx((slotScope) => [
            renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, normalizeProps(mergeProps({ key: 0 }, _ctx.iconProps)), null, 16)) : createCommentVNode("", true)
          ]),
          icon: withCtx(() => [
            _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              class: "va-date-input__clear-icon",
              role: "button",
              "aria-label": "reset date",
              "aria-hiden": "false",
              tabindex: _ctx.iconTabindexComputed
            }, _ctx.clearIconProps, {
              onClick: withModifiers(_ctx.reset, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
              ]
            }), null, 16, ["tabindex", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 1,
              tabindex: _ctx.iconTabindexComputed
            }, _ctx.iconProps), null, 16, ["tabindex"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.filterSlots, (name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          })
        ]), 1040)
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, { class: "va-date-input__dropdown-content" }, {
        default: withCtx(() => [
          createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
            modelValue: _ctx.valueWithoutText,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueWithoutText = $event),
            "onClick:day": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:day", $event)),
            "onClick:month": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:month", $event)),
            "onClick:year": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:year", $event)),
            "onHover:day": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:day", $event)),
            "onHover:month": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:month", $event)),
            "onHover:year": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("hover:year", $event)),
            "onUpdate:view": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:view", $event))
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_2, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["modelValue"])
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 8, ["modelValue", "class", "style", "disabled", "onOpen", "onClose"]);
}
var _VaDateInput = _export_sfc(_sfc_main48, [["render", _sfc_render47]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-input/index.js
var VaDateInput = withConfigTransport(_VaDateInput);

// node_modules/vuestic-ui/dist/esm/src/components/va-date-picker/index.js
var VaDatePicker = withConfigTransport(_VaDatePicker);

// node_modules/vuestic-ui/dist/esm/src/components/va-divider/VaDivider.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-divider/VaDivider.css";
var prefixClass = "va-divider";
var _sfc_main49 = defineComponent({
  name: "VaDivider",
  props: {
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    }
  },
  setup: (props, { slots }) => ({
    hasSlot: computed(() => !!slots.default),
    classComputed: computed(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }))
  })
});
var _hoisted_134 = ["aria-orientation"];
var _hoisted_218 = {
  key: 0,
  class: "va-divider__text"
};
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "separator",
    class: normalizeClass(["va-divider", _ctx.classComputed]),
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal"
  }, [
    _ctx.hasSlot && !_ctx.vertical ? (openBlock(), createElementBlock("div", _hoisted_218, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true)
  ], 10, _hoisted_134);
}
var _VaDivider = _export_sfc(_sfc_main49, [["render", _sfc_render48]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-divider/index.js
var VaDivider = withConfigTransport(_VaDivider);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUpload.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/types.js
var VaFileUploadKey = Symbol("VaFileUpload");

// node_modules/vuestic-ui/dist/esm/src/components/va-form/VaForm.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-form/VaForm.css";
var isVaForm = (value) => !!value.focusInvalid;
var _sfc_main50 = defineComponent({
  name: "VaForm",
  emits: ["validation"],
  props: {
    autofocus: { type: Boolean, default: false },
    tag: { type: String, default: "div" }
  },
  setup(props, { emit }) {
    const nestedFormElements = ref([]);
    const parentFormProvider = () => inject(FormServiceKey, void 0);
    provide(FormServiceKey, {
      onChildMounted: (child) => childMountedHandler(child),
      onChildUnmounted: (removableChild) => childUnmountedHandler(removableChild)
    });
    const childMountedHandler = (child) => {
      nestedFormElements.value.push(child);
    };
    const childUnmountedHandler = (removableChild) => {
      nestedFormElements.value = nestedFormElements.value.filter((child) => child !== removableChild);
    };
    const reset = () => {
      nestedFormElements.value.filter(({ reset: reset2 }) => reset2).forEach((item) => {
        item.reset();
      });
    };
    const resetValidation = () => {
      nestedFormElements.value.filter(({ resetValidation: resetValidation2 }) => resetValidation2).forEach((item) => {
        item.resetValidation();
      });
    };
    const focus = () => {
      var _a;
      (_a = nestedFormElements.value.find(({ focus: focus2 }) => focus2)) == null ? void 0 : _a.focus();
    };
    const focusInvalid = () => {
      const invalidComponent = nestedFormElements.value.find((item) => !isVaForm(item) && item.hasError());
      if (invalidComponent) {
        invalidComponent.focus();
      } else {
        nestedFormElements.value.forEach((item) => isVaForm(item) && item.focusInvalid());
      }
    };
    const validate = () => {
      const formValid = nestedFormElements.value.filter(({ validate: validate2 }) => validate2).map((child) => child.validate()).every((isValid) => isValid);
      emit("validation", formValid);
      return formValid;
    };
    const publicMethods = {
      reset,
      resetValidation,
      focus,
      focusInvalid,
      validate
    };
    onMounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildMounted) == null ? void 0 : _b.call(_a, publicMethods);
      if (props.autofocus) {
        nextTick(focus);
      }
    });
    onUnmounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildUnmounted) == null ? void 0 : _b.call(_a, publicMethods);
    });
    return publicMethods;
  }
});
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), { class: "va-form" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
var _VaForm = _export_sfc(_sfc_main50, [["render", _sfc_render49]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-form/index.js
var VaForm = withConfigTransport(_VaForm);

// node_modules/vuestic-ui/dist/esm/src/components/va-infinite-scroll/VaInfiniteScroll.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-infinite-scroll/hooks/useScroll.js
init_vue_runtime_esm_bundler();
var useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a;
    (_a = element.value) == null ? void 0 : _a.addEventListener("scroll", handler.value, { passive: true });
  };
  const removeScrollListener = () => {
    var _a;
    (_a = element.value) == null ? void 0 : _a.removeEventListener("scroll", handler.value);
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-infinite-scroll/VaInfiniteScroll.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-infinite-scroll/VaInfiniteScroll.css";
var _sfc_main51 = defineComponent({
  name: "VaInfiniteScroll",
  components: { VaProgressCircle },
  props: {
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: void 0 },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(props, { emit }) {
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a;
      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props.debounce, (value) => {
      debouncedLoad.value = debounce_1(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return {
      element,
      spinnerSlotContainer,
      spinnerColor,
      fetching
    };
  }
});
var _hoisted_135 = { class: "va-infinite-scroll__spinner__default" };
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !_ctx.fetching }])
      }, [
        !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
          createBaseVNode("div", _hoisted_135, [
            createVNode(_component_va_progress_circle, {
              size: "small",
              thickness: 0.15,
              color: _ctx.spinnerColor,
              indeterminate: ""
            }, null, 8, ["thickness", "color"])
          ])
        ]) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["class", "aria-busy"]);
}
var _VaInfiniteScroll = _export_sfc(_sfc_main51, [["render", _sfc_render50]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-infinite-scroll/index.js
var VaInfiniteScroll = withConfigTransport(_VaInfiniteScroll);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/VaList.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-list/VaList.css";
var _sfc_main52 = defineComponent({
  name: "VaList",
  props: {
    fit: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list--fit": props.fit }))
  })
});
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list", _ctx.computedClass]),
    role: "list"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaList = _export_sfc(_sfc_main52, [["render", _sfc_render51]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListItem.css";
var __defProp51 = Object.defineProperty;
var __defProps44 = Object.defineProperties;
var __getOwnPropDescs44 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols51 = Object.getOwnPropertySymbols;
var __hasOwnProp51 = Object.prototype.hasOwnProperty;
var __propIsEnum51 = Object.prototype.propertyIsEnumerable;
var __defNormalProp51 = (obj, key2, value) => key2 in obj ? __defProp51(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues51 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp51.call(b2, prop))
      __defNormalProp51(a2, prop, b2[prop]);
  if (__getOwnPropSymbols51)
    for (var prop of __getOwnPropSymbols51(b2)) {
      if (__propIsEnum51.call(b2, prop))
        __defNormalProp51(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps44 = (a2, b2) => __defProps44(a2, __getOwnPropDescs44(b2));
var _sfc_main53 = defineComponent({
  name: "VaListItem",
  emits: ["focus", "click"],
  props: __spreadProps44(__spreadValues51({}, useRouterLinkProps), {
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  }),
  setup(props) {
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = computed(() => ({
      "va-list-item--disabled": props.disabled
    }));
    return __spreadProps44(__spreadValues51({}, useRouterLink(props)), {
      tabIndexComputed,
      computedClass
    });
  }
});
function _sfc_render52(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-list-item", _ctx.computedClass]),
    role: "listitem",
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    tabindex: _ctx.tabIndexComputed
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-list-item__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 32)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
}
var _VaListItem = _export_sfc(_sfc_main53, [["render", _sfc_render52]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListLabel.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListLabel.css";
var _sfc_main54 = defineComponent({
  name: "VaListLabel",
  props: {
    color: { type: String, default: "primary" }
  },
  setup: (props) => {
    const { getColor } = useColors();
    return {
      computedStyle: computed(() => ({
        color: getColor(props.color)
      }))
    };
  }
});
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-list-label",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaListLabel = _export_sfc(_sfc_main54, [["render", _sfc_render53]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListItemLabel.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListItemLabel.css";
var _sfc_main55 = defineComponent({
  name: "VaListItemLabel",
  props: {
    caption: { type: Boolean, default: false },
    lines: { type: Number, default: 1 }
  },
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list-item-label--caption": props.caption })),
    computedStyle: computed(() => ({ "-webkit-line-clamp": props.lines }))
  })
});
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-label", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _VaListItemLabel = _export_sfc(_sfc_main55, [["render", _sfc_render54]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListItemSection.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListItemSection.css";
var _sfc_main56 = defineComponent({
  name: "VaListItemSection",
  props: {
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }))
  })
});
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-section", _ctx.computedClass])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaListItemSection = _export_sfc(_sfc_main56, [["render", _sfc_render55]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListSeparator.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-list/VaListSeparator.css";
var _sfc_main57 = defineComponent({
  name: "VaListSeparator",
  props: {
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }))
  })
});
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    "aria-hidden": "true",
    class: normalizeClass(["va-list-separator", _ctx.computedClass])
  }, null, 2);
}
var _VaListSeparator = _export_sfc(_sfc_main57, [["render", _sfc_render56]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-list/index.js
var VaListItem = withConfigTransport(_VaListItem);
var VaListLabel = withConfigTransport(_VaListLabel);
var VaListItemLabel = withConfigTransport(_VaListItemLabel);
var VaListItemSection = withConfigTransport(_VaListItemSection);
var VaListSeparator = withConfigTransport(_VaListSeparator);
var VaList = withConfigTransport(_VaList);

// node_modules/vuestic-ui/dist/esm/src/components/va-navbar/VaNavbar.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-navbar/VaNavbar.css";
var _sfc_main58 = defineComponent({
  name: "VaNavbar",
  props: {
    color: { type: String, default: "secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false }
  },
  setup(props) {
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const color = computed(() => getColor(props.color));
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => ({
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    return {
      computedStyle,
      shapeStyleComputed
    };
  }
});
var _hoisted_136 = { class: "va-navbar__content" };
var _hoisted_219 = {
  key: 0,
  class: "va-navbar__left"
};
var _hoisted_39 = {
  key: 1,
  class: "va-navbar__center"
};
var _hoisted_47 = {
  key: 2,
  class: "va-navbar__right"
};
function _sfc_render57(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    class: "va-navbar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    createBaseVNode("div", _hoisted_136, [
      _ctx.$slots.left ? (openBlock(), createElementBlock("div", _hoisted_219, [
        renderSlot(_ctx.$slots, "left")
      ])) : createCommentVNode("", true),
      _ctx.$slots.center ? (openBlock(), createElementBlock("div", _hoisted_39, [
        renderSlot(_ctx.$slots, "center")
      ])) : createCommentVNode("", true),
      _ctx.$slots.right ? (openBlock(), createElementBlock("div", _hoisted_47, [
        renderSlot(_ctx.$slots, "right")
      ])) : createCommentVNode("", true)
    ]),
    _ctx.shape ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "va-navbar__background-shape",
      style: normalizeStyle(_ctx.shapeStyleComputed)
    }, null, 4)) : createCommentVNode("", true)
  ], 4);
}
var _VaNavbar = _export_sfc(_sfc_main58, [["render", _sfc_render57]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-navbar/VaNavbarItem/VaNavbarItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-navbar/VaNavbarItem/VaNavbarItem.css";
var _sfc_main59 = defineComponent({
  name: "VaNavbarItem"
});
var _hoisted_137 = { class: "va-navbar__item" };
function _sfc_render58(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_137, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaNavbarItem = _export_sfc(_sfc_main59, [["render", _sfc_render58]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-navbar/index.js
var VaNavbar = withConfigTransport(_VaNavbar);
var VaNavbarItem = withConfigTransport(_VaNavbarItem);

// node_modules/vuestic-ui/dist/esm/src/components/va-option-list/VaOptionList.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useArrayRefs.js
init_vue_runtime_esm_bundler();
var useArrayRefs = () => {
  const itemRefs = shallowRef2([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/esm/src/composables/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "value" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const isStringOrNumber = (option) => {
    const typeOfOption = typeof option;
    return typeOfOption === "string" || typeOfOption === "number";
  };
  const getOptionProperty = (option, selector) => {
    return !selector || isStringOrNumber(option) ? option : getValueByKey(option, selector);
  };
  const getValue2 = (option) => getOptionProperty(option, props.valueBy);
  const getOptionByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.options.find((option) => value === getValue2(option)) || value;
  };
  const getText = (option) => getOptionProperty(option, props.textBy);
  const getDisabled = (option) => getValueByKey(option, props.disabledBy);
  const getTrackBy = (option) => getOptionProperty(option, props.trackBy);
  const getGroupBy = (option) => getOptionProperty(option, props.groupBy);
  return {
    getValue: getValue2,
    getOptionByValue,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-radio/VaRadio.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-radio/VaRadio.css";
var __defProp52 = Object.defineProperty;
var __defProps45 = Object.defineProperties;
var __getOwnPropDescs45 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols52 = Object.getOwnPropertySymbols;
var __hasOwnProp52 = Object.prototype.hasOwnProperty;
var __propIsEnum52 = Object.prototype.propertyIsEnumerable;
var __defNormalProp52 = (obj, key2, value) => key2 in obj ? __defProp52(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues52 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp52.call(b2, prop))
      __defNormalProp52(a2, prop, b2[prop]);
  if (__getOwnPropSymbols52)
    for (var prop of __getOwnPropSymbols52(b2)) {
      if (__propIsEnum52.call(b2, prop))
        __defNormalProp52(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps45 = (a2, b2) => __defProps45(a2, __getOwnPropDescs45(b2));
var _sfc_main60 = defineComponent({
  name: "VaRadio",
  emits: ["update:modelValue", "focus"],
  props: __spreadProps45(__spreadValues52({}, useFormProps), {
    modelValue: { type: [Boolean, Array, String, Object], default: null },
    option: { default: null },
    name: { type: String, default: "" },
    label: { type: String, default: "" },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    tabindex: { type: Number, default: 0 }
  }),
  setup(props, { emit }) {
    const { getColor } = useColors();
    const isActive = computed(() => props.modelValue === props.option);
    const { computedClasses } = useForm("va-radio", props);
    const computedClass = computed(() => __spreadValues52({
      "va-radio--left-label": props.leftLabel
    }, computedClasses));
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return {
        borderColor: getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return { borderColor: getColor(props.color) };
    });
    const computedLabel = computed(() => props.label || props.option);
    const onClick = (e2) => {
      if (props.readonly || props.disabled) {
        return;
      }
      emit("update:modelValue", props.option, e2);
    };
    const onFocus = (e2) => emit("focus", e2);
    return {
      computedClass,
      isActive,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      computedLabel,
      onClick,
      onFocus,
      computedName: computed(() => props.name || generateUniqueId()),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_138 = ["checked", "disabled", "readonly", "name", "value", "aria-checked", "tabindex"];
var _hoisted_220 = { class: "va-radio__text" };
function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["va-radio", _ctx.computedClass])
  }, [
    createBaseVNode("input", {
      class: "va-radio__input",
      type: "radio",
      checked: _ctx.isActive,
      disabled: _ctx.$props.disabled,
      readonly: _ctx.$props.readonly,
      name: _ctx.computedName,
      value: _ctx.computedLabel,
      "aria-checked": _ctx.isActive,
      tabindex: _ctx.tabIndexComputed,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args))
    }, null, 40, _hoisted_138),
    createBaseVNode("span", {
      "aria-hidden": "true",
      class: "va-radio__icon",
      style: normalizeStyle(_ctx.iconComputedStyles)
    }, [
      createBaseVNode("span", {
        class: "va-radio__icon__background",
        style: normalizeStyle(_ctx.iconBackgroundComputedStyles)
      }, null, 4),
      createBaseVNode("span", {
        class: "va-radio__icon__dot",
        style: normalizeStyle(_ctx.iconDotComputedStyles)
      }, null, 4)
    ], 4),
    createBaseVNode("span", _hoisted_220, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.computedLabel), 1)
      ])
    ])
  ], 2);
}
var _VaRadio = _export_sfc(_sfc_main60, [["render", _sfc_render59]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-radio/index.js
var VaRadio = withConfigTransport(_VaRadio);

// node_modules/vuestic-ui/dist/esm/src/components/va-switch/VaSwitch.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-switch/VaSwitch.css";
var __defProp53 = Object.defineProperty;
var __defProps46 = Object.defineProperties;
var __getOwnPropDescs46 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols53 = Object.getOwnPropertySymbols;
var __hasOwnProp53 = Object.prototype.hasOwnProperty;
var __propIsEnum53 = Object.prototype.propertyIsEnumerable;
var __defNormalProp53 = (obj, key2, value) => key2 in obj ? __defProp53(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues53 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp53.call(b2, prop))
      __defNormalProp53(a2, prop, b2[prop]);
  if (__getOwnPropSymbols53)
    for (var prop of __getOwnPropSymbols53(b2)) {
      if (__propIsEnum53.call(b2, prop))
        __defNormalProp53(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps46 = (a2, b2) => __defProps46(a2, __getOwnPropDescs46(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp53.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols53)
    for (var prop of __getOwnPropSymbols53(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum53.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var _sfc_main61 = defineComponent({
  name: "VaSwitch",
  components: { VaProgressCircle, VaMessageListWrapper },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  props: __spreadProps46(__spreadValues53({}, useSelectableProps), {
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "gray" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  }),
  setup(props, { emit, slots }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const _a = useSelectable(props, emit, elements), {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes
    } = _a, selectable = __objRest(_a, [
      "isChecked",
      "computedError",
      "isIndeterminate",
      "computedErrorMessages",
      "validationAriaAttributes"
    ]);
    const computedBackground = computed(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => __spreadProps46(__spreadValues53({}, pick_1(props, ["readonly", "disabled", "leftLabel"])), {
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      onKeyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size2 = { small: "15px", medium: "20px", large: "25px" };
      return size2[props.size];
    });
    const trackStyle = computed(() => ({
      borderColor: props.error ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: props.error ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value
    }));
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const inputAttributesComputed = computed(() => __spreadValues53({
      id: props.id || void 0,
      name: props.name || void 0,
      disabled: props.disabled,
      readonly: props.readonly,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: !!props.modelValue,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0
    }, validationAriaAttributes.value));
    return __spreadProps46(__spreadValues53({}, selectable), {
      computedErrorMessages,
      isChecked,
      computedError,
      isIndeterminate,
      keyboardFocusListeners,
      computedInnerLabel,
      computedLabel,
      computedClass,
      styleComputed,
      progressCircleSize,
      trackStyle,
      labelStyle,
      trackLabelStyle,
      ariaLabelIdComputed,
      inputAttributesComputed
    });
  }
});
var _hoisted_139 = { class: "va-switch__checker-wrapper" };
var _hoisted_221 = { class: "va-switch__checker" };
var _hoisted_310 = ["id"];
function _sfc_render60(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-switch", _ctx.computedClass]),
    style: normalizeStyle(_ctx.styleComputed),
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-switch__container",
        tabindex: "-1",
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-switch__inner",
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-switch__input",
            role: "switch"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]), ["enter"]))
          }), null, 16),
          createBaseVNode("div", {
            class: "va-switch__track",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.trackStyle)
          }, [
            _ctx.computedInnerLabel || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-switch__track-label",
              style: normalizeStyle(_ctx.trackLabelStyle)
            }, [
              renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                createTextVNode(toDisplayString(_ctx.computedInnerLabel), 1)
              ])
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_139, [
              createBaseVNode("span", _hoisted_221, [
                _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
                  key: 0,
                  indeterminate: "",
                  size: _ctx.progressCircleSize,
                  color: _ctx.trackStyle.backgroundColor
                }, null, 8, ["size", "color"])) : createCommentVNode("", true)
              ])
            ])
          ], 4)
        ]),
        _ctx.computedLabel || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "label",
          class: "va-switch__label",
          style: normalizeStyle(_ctx.labelStyle),
          id: _ctx.ariaLabelIdComputed,
          onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["stop"]), ["enter"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.computedLabel), 1)
          ])
        ], 44, _hoisted_310)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaSwitch = _export_sfc(_sfc_main61, [["render", _sfc_render60]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-switch/index.js
var VaSwitch = withConfigTransport(_VaSwitch);

// node_modules/vuestic-ui/dist/esm/src/components/va-option-list/VaOptionList.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-option-list/VaOptionList.css";
var __defProp54 = Object.defineProperty;
var __defProps47 = Object.defineProperties;
var __getOwnPropDescs47 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols54 = Object.getOwnPropertySymbols;
var __hasOwnProp54 = Object.prototype.hasOwnProperty;
var __propIsEnum54 = Object.prototype.propertyIsEnumerable;
var __defNormalProp54 = (obj, key2, value) => key2 in obj ? __defProp54(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues54 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp54.call(b2, prop))
      __defNormalProp54(a2, prop, b2[prop]);
  if (__getOwnPropSymbols54)
    for (var prop of __getOwnPropSymbols54(b2)) {
      if (__propIsEnum54.call(b2, prop))
        __defNormalProp54(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps47 = (a2, b2) => __defProps47(a2, __getOwnPropDescs47(b2));
var _sfc_main62 = defineComponent({
  name: "VaOptionList",
  components: {
    VaRadio,
    VaCheckbox,
    VaSwitch,
    VaMessageListWrapper
  },
  emits: [...useStatefulEmits],
  props: __spreadProps47(__spreadValues54(__spreadValues54(__spreadValues54({}, useSelectableListProps), useValidationProps), useStatefulProps), {
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Object, Array] }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, props.defaultValue);
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const getKey = (option) => getTrackBy(option);
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => {
      valueComputed.value = void 0;
    };
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const { computedError, computedErrorMessages } = useValidation(props, emit, reset, focus);
    const computedProps = computed(() => pick_1(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
    });
    return {
      selectedValue,
      computedError,
      computedErrorMessages,
      getValue: getValue2,
      getText,
      getKey,
      isDisabled,
      reset,
      focus,
      setItemRef,
      computedProps
    };
  }
});
var _hoisted_140 = { class: "va-option-list__list" };
function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_radio = resolveComponent("va-radio");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_switch = resolveComponent("va-switch");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("ul", _hoisted_140, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
          return openBlock(), createElementBlock("li", {
            key: _ctx.getKey(option)
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: _ctx.selectedValue, isDisabled: _ctx.isDisabled, getText: _ctx.getText, getValue: _ctx.getValue })), () => [
              _ctx.$props.type === "radio" ? (openBlock(), createBlock(_component_va_radio, mergeProps({
                key: 0,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                option: _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(_component_va_checkbox, mergeProps({
                key: 1,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(_component_va_switch, mergeProps({
                key: 2,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"]))
            ])
          ]);
        }), 128))
      ])
    ]),
    _: 3
  }, 8, ["error", "error-messages", "error-count"]);
}
var _VaOptionList = _export_sfc(_sfc_main62, [["render", _sfc_render61]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-option-list/index.js
var VaOptionList = withConfigTransport(_VaOptionList);

// node_modules/vuestic-ui/dist/esm/src/components/va-pagination/VaPagination.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-pagination/setPaginationRange.js
var setPaginationRange = (value = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (value - paginationMiddlePage <= 0 || value > pages) {
      start = 1;
    } else {
      start = value + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(value - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i2 = 0; i2 < visiblePages; i2++) {
    range.push(start + i2);
  }
  if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-pagination/VaPagination.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-pagination/VaPagination.css";
var __defProp55 = Object.defineProperty;
var __defProps48 = Object.defineProperties;
var __getOwnPropDescs48 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols55 = Object.getOwnPropertySymbols;
var __hasOwnProp55 = Object.prototype.hasOwnProperty;
var __propIsEnum55 = Object.prototype.propertyIsEnumerable;
var __defNormalProp55 = (obj, key2, value) => key2 in obj ? __defProp55(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues55 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp55.call(b2, prop))
      __defNormalProp55(a2, prop, b2[prop]);
  if (__getOwnPropSymbols55)
    for (var prop of __getOwnPropSymbols55(b2)) {
      if (__propIsEnum55.call(b2, prop))
        __defNormalProp55(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps48 = (a2, b2) => __defProps48(a2, __getOwnPropDescs48(b2));
var _sfc_main63 = defineComponent({
  name: "VaPagination",
  components: { VaButtonGroup, VaButton: VaButton2 },
  emits: useStatefulEmits,
  props: __spreadProps48(__spreadValues55({}, useStatefulProps), {
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: Number, default: 0 },
    pages: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v2) => ["medium", "small", "large"].includes(v2)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    total: { type: Number, default: null },
    pageSize: { type: Number, default: null },
    boundaryIconLeft: { type: String, default: "first_page" },
    boundaryIconRight: { type: String, default: "last_page" },
    directionIconLeft: { type: String, default: "chevron_left" },
    directionIconRight: { type: String, default: "chevron_right" }
  }),
  setup(props, { emit }) {
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usedTotal = computed(() => !!((props.total || props.pageSize === 0) && props.pageSize));
    const { valueComputed } = useStateful(props, emit);
    const { textColorComputed } = useTextColor();
    const currentValue = computed({
      get: () => usedTotal.value ? Math.ceil(valueComputed.value / props.pageSize) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const paginationRange = computed(() => {
      const { visiblePages, total, pageSize, boundaryNumbers, pages } = props;
      const value = currentValue.value || 1;
      const totalPages = usedTotal.value ? Math.ceil(total / pageSize) : pages;
      return setPaginationRange(value, visiblePages, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usedTotal.value ? Math.ceil(props.total / props.pageSize) || 1 : props.pages);
    const IsLstPageNotVisible = computed(() => !!props.visiblePages && lastPage.value > props.visiblePages);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers, input } = props;
      return input || IsLstPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => props.input || IsLstPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = `${currentValue.value}`;
      nextTick(() => {
        var _a;
        return (_a = htmlInput.value) == null ? void 0 : _a.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const onUserInput = (pageNum) => {
      if (pageNum === "..." || pageNum < 1 || pageNum > lastPage.value) {
        return;
      }
      currentValue.value = usedTotal.value ? (pageNum - 1) * props.pageSize + 1 : pageNum;
    };
    const resetInput = () => {
      var _a;
      inputValue.value = "";
      (_a = htmlInput.value) == null ? void 0 : _a.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor } = useColors();
    const activeButtonStyle = (buttonValue) => {
      if (buttonValue === currentValue.value) {
        return {
          backgroundColor: getColor(props.color),
          color: textColorComputed.value
        };
      }
      return {
        color: getColor(props.color)
      };
    };
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1
    }));
    watch([usedTotal, () => props.pages], () => {
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    return {
      currentValue,
      lastPage,
      changeValue,
      inputValue,
      showPagination,
      showBoundaryLinks,
      onUserInput,
      activeButtonStyle,
      showDirectionLinks,
      paginationRange,
      focusInput,
      inputStyleComputed,
      inputAttributesComputed
    };
  }
});
function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return _ctx.showPagination ? (openBlock(), createBlock(_component_va_button_group, {
    key: 0,
    class: "va-pagination",
    flat: _ctx.$props.flat,
    size: _ctx.$props.size,
    color: _ctx.$props.color,
    outline: "",
    onKeydown: [
      _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.onUserInput(_ctx.currentValue - 1), ["stop"]), ["left"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.onUserInput(_ctx.currentValue + 1), ["stop"]), ["right"]))
    ]
  }, {
    default: withCtx(() => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        "aria-label": "go first page",
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.boundaryIconLeft,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onUserInput(1))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("", true),
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        "aria-label": "go prev page",
        outline: "",
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.directionIconLeft,
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onUserInput(_ctx.currentValue - 1))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("", true),
      !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginationRange, (n2, i2) => {
          return openBlock(), createBlock(_component_va_button, {
            key: i2,
            class: normalizeClass(["va-pagination__numeric-button", { "va-button--ellipsis": n2 === "..." }]),
            outline: "",
            "aria-label": `go to ${n2} page`,
            "aria-current": n2 === _ctx.currentValue,
            style: normalizeStyle(_ctx.activeButtonStyle(n2)),
            disabled: _ctx.$props.disabled || n2 === "...",
            onClick: ($event) => _ctx.onUserInput(n2)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(n2), 1)
            ]),
            _: 2
          }, 1032, ["aria-label", "aria-current", "style", "disabled", "class", "onClick"]);
        }), 128))
      ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
        key: 3,
        ref: "htmlInput",
        class: ["va-pagination__input va-button", { "va-pagination__input--flat": _ctx.$props.flat }],
        "aria-label": "enter the page number to go",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
        style: _ctx.inputStyleComputed
      }, _ctx.inputAttributesComputed, {
        onKeydown: _cache[3] || (_cache[3] = withKeys((...args) => _ctx.changeValue && _ctx.changeValue(...args), ["enter"])),
        onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.focusInput && _ctx.focusInput(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.changeValue && _ctx.changeValue(...args))
      }), null, 16)), [
        [vModelDynamic, _ctx.inputValue]
      ]),
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 4,
        "aria-label": "go next page",
        outline: "",
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.directionIconRight,
        onClick: _cache[6] || (_cache[6] = ($event) => _ctx.onUserInput(_ctx.currentValue + 1))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("", true),
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, {
        key: 5,
        "aria-label": "go last page",
        outline: "",
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.boundaryIconRight,
        onClick: _cache[7] || (_cache[7] = ($event) => _ctx.onUserInput(_ctx.lastPage))
      }, null, 8, ["disabled", "icon"])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["flat", "size", "color"])) : createCommentVNode("", true);
}
var _VaPagination = _export_sfc(_sfc_main63, [["render", _sfc_render62]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-pagination/index.js
var VaPagination = withConfigTransport(_VaPagination);

// node_modules/vuestic-ui/dist/esm/src/components/va-parallax/VaParallax.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-parallax/VaParallax.css";
var _sfc_main64 = defineComponent({
  name: "VaParallax",
  props: {
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: Number, default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: Number,
      default: 0.5,
      validator: (value) => value >= 0 && value <= 1
    }
  },
  setup(props) {
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: props.height + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const targetElement = computed(() => {
      var _a;
      if (!props.target) {
        return getScrollableParent((_a = rootElement.value) == null ? void 0 : _a.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      return null;
    });
    const getScrollableParent = (element) => {
      if (!element) {
        return document.body;
      }
      if (element.scrollHeight > element.clientHeight) {
        return element;
      }
      return getScrollableParent(element.parentElement);
    };
    const imgHeight = computed(() => {
      var _a;
      return ((_a = img.value) == null ? void 0 : _a.naturalHeight) || 0;
    });
    const calcDimensions = () => {
      var _a, _b;
      const offset = ((_a = rootElement.value) == null ? void 0 : _a.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - props.height;
      elOffsetTop.value = offset.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props.height + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props.speed;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) == null ? void 0 : _a.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) == null ? void 0 : _a.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a, _b;
      if ((_a = img.value) == null ? void 0 : _a.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return {
      img,
      rootElement,
      computedWrapperStyles,
      computedImgStyles
    };
  }
});
var _hoisted_141 = { class: "va-parallax__image-container" };
var _hoisted_222 = ["src", "alt"];
var _hoisted_311 = { class: "va-parallax__item-container" };
function _sfc_render63(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-parallax",
    style: normalizeStyle(_ctx.computedWrapperStyles)
  }, [
    createBaseVNode("div", _hoisted_141, [
      createBaseVNode("img", {
        ref: "img",
        class: "va-parallax__image",
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        style: normalizeStyle(_ctx.computedImgStyles)
      }, null, 12, _hoisted_222)
    ]),
    createBaseVNode("div", _hoisted_311, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 4);
}
var _VaParallax = _export_sfc(_sfc_main64, [["render", _sfc_render63]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-parallax/index.js
var VaParallax = withConfigTransport(_VaParallax);

// node_modules/vuestic-ui/dist/esm/src/components/va-popover/VaPopover.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-progress-bar/VaProgressBar.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-progress-bar/VaProgressBar.css";
var _sfc_main65 = defineComponent({
  name: "VaProgressBar",
  props: {
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: Number, default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false }
  },
  setup(props) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const isTextSize = computed(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    return {
      rootClass: computed(() => ({
        "va-progress-bar--square": !props.rounded,
        [`va-progress-bar--${props.size}`]: isTextSize.value
      })),
      rooStyle: computed(() => ({
        "--va-progress-bar-color": colorComputed.value,
        "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
      })),
      wrapperStyle: computed(() => ({
        height: getCSSHeight()
      })),
      bufferStyle: computed(() => ({
        width: `${props.indeterminate ? 100 : clamp_1(props.buffer, 0, 100)}%`,
        color: textColorComputed.value,
        [props.reverse ? "right" : "left"]: 0
      })),
      progressStyle: computed(() => ({
        width: `${clamp_1(props.modelValue, 0, 100)}%`,
        marginLeft: props.reverse ? "auto" : void 0
      })),
      intermediateStyle: computed(() => ({
        animationDirection: props.reverse ? "reverse" : "normal"
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        ariaLabel: "progress state",
        ariaValuenow: !props.indeterminate ? props.modelValue : void 0
      }))
    };
  }
});
var _hoisted_143 = {
  key: 0,
  class: "va-progress-bar__info"
};
function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-bar", _ctx.rootClass],
    style: _ctx.rooStyle
  }, _ctx.ariaAttributesComputed), [
    !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_143, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
        _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: "va-progress-bar__wrapper",
      style: normalizeStyle(_ctx.wrapperStyle)
    }, [
      createBaseVNode("div", {
        class: "va-progress-bar__buffer",
        style: normalizeStyle(_ctx.bufferStyle)
      }, [
        _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
          _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
          ], 64)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 4),
      _ctx.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-start",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4),
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-end",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4)
      ], 64)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-progress-bar__progress",
        style: normalizeStyle(_ctx.progressStyle)
      }, null, 4))
    ], 4)
  ], 16);
}
var _VaProgressBar = _export_sfc(_sfc_main65, [["render", _sfc_render64]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-progress-bar/index.js
var VaProgressBar = withConfigTransport(_VaProgressBar);

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/VaRating.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/hooks/useRating.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/types.js
var RatingValue = ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/hooks/useRating.js
var __defProp56 = Object.defineProperty;
var __defProps49 = Object.defineProperties;
var __getOwnPropDescs49 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols56 = Object.getOwnPropertySymbols;
var __hasOwnProp56 = Object.prototype.hasOwnProperty;
var __propIsEnum56 = Object.prototype.propertyIsEnumerable;
var __defNormalProp56 = (obj, key2, value) => key2 in obj ? __defProp56(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues56 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp56.call(b2, prop))
      __defNormalProp56(a2, prop, b2[prop]);
  if (__getOwnPropSymbols56)
    for (var prop of __getOwnPropSymbols56(b2)) {
      if (__propIsEnum56.call(b2, prop))
        __defNormalProp56(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps49 = (a2, b2) => __defProps49(a2, __getOwnPropDescs49(b2));
var getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = __spreadProps49(__spreadValues56({}, useStatefulProps), {
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
});
var useRating = (props) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp_1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/hooks/useVaRatingColors.js
init_vue_runtime_esm_bundler();
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor: getTextColor2 } = useColors();
  const computedColor = computed(() => getColor(props.color));
  const backgroundColor = computed(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getTextColor2(computedColor.value);
    }
    return getTextColor2(backgroundColor.value);
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/components/VaRatingItem/VaRatingItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-rating/components/VaRatingItem/VaRatingItem.css";
var _sfc_main66 = defineComponent({
  name: "VaRatingItem",
  components: { VaIcon: VaIcon2 },
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(props, { emit }) {
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onEnter = () => {
      modelValue.value = 1;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    return {
      computedColor,
      rootEl,
      onEnter,
      onClick,
      onMouseMove,
      onMouseLeave,
      visibleValue,
      computedIconName: computed(() => {
        if (props.halves && visibleValue.value === RatingValue.HALF) {
          return props.halfIcon;
        }
        if (visibleValue.value === RatingValue.EMPTY) {
          return props.emptyIcon;
        }
        return props.icon;
      }),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_144 = ["tabindex"];
function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootEl",
    class: "va-rating-item",
    role: "button",
    tabindex: _ctx.tabIndexComputed,
    onKeyup: [
      _cache[0] || (_cache[0] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["enter"])),
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["space"]))
    ],
    onMousemove: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseMove && _ctx.onMouseMove(...args)),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {
      props: { value: _ctx.visibleValue, onClick: _ctx.onClick }
    }, () => [
      createVNode(_component_va_icon, {
        class: "va-rating-item__wrapper",
        tabindex: "-1",
        tag: "button",
        name: _ctx.computedIconName,
        size: _ctx.$props.size,
        color: _ctx.computedColor,
        onClick: _ctx.onClick
      }, null, 8, ["name", "size", "color", "onClick"])
    ])
  ], 40, _hoisted_144);
}
var _VaRatingItem = _export_sfc(_sfc_main66, [["render", _sfc_render65]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/components/VaRatingItemNumberButton.js
init_vue_runtime_esm_bundler();
var __defProp57 = Object.defineProperty;
var __defProps50 = Object.defineProperties;
var __getOwnPropDescs50 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols57 = Object.getOwnPropertySymbols;
var __hasOwnProp57 = Object.prototype.hasOwnProperty;
var __propIsEnum57 = Object.prototype.propertyIsEnumerable;
var __defNormalProp57 = (obj, key2, value) => key2 in obj ? __defProp57(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues57 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp57.call(b2, prop))
      __defNormalProp57(a2, prop, b2[prop]);
  if (__getOwnPropSymbols57)
    for (var prop of __getOwnPropSymbols57(b2)) {
      if (__propIsEnum57.call(b2, prop))
        __defNormalProp57(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps50 = (a2, b2) => __defProps50(a2, __getOwnPropDescs50(b2));
var _sfc_main67 = defineComponent({
  name: "VaRatingItemNumberButton",
  props: __spreadProps50(__spreadValues57(__spreadValues57({}, useVaRatingColorsProps), useSizeProps), {
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  }),
  setup(props) {
    return __spreadValues57(__spreadValues57({}, useVaRatingColors(props)), useSize(props, "VaRating"));
  }
});
function _sfc_render66(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "va-rating__number-item",
    tabindex: "-1",
    "aria-hidden": "true",
    style: normalizeStyle({
      background: _ctx.backgroundComputed,
      color: _ctx.textColorComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed,
      fontSize: _ctx.fontSizeComputed,
      borderRadius: `${parseInt(_ctx.fontSizeComputed) * 0.125}rem`
    })
  }, toDisplayString(_ctx.itemNumber), 5);
}
var VaRatingItemNumberButton = _export_sfc(_sfc_main67, [["render", _sfc_render66]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/VaRating.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-rating/VaRating.css";
var __defProp58 = Object.defineProperty;
var __defProps51 = Object.defineProperties;
var __getOwnPropDescs51 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols58 = Object.getOwnPropertySymbols;
var __hasOwnProp58 = Object.prototype.hasOwnProperty;
var __propIsEnum58 = Object.prototype.propertyIsEnumerable;
var __defNormalProp58 = (obj, key2, value) => key2 in obj ? __defProp58(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues58 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp58.call(b2, prop))
      __defNormalProp58(a2, prop, b2[prop]);
  if (__getOwnPropSymbols58)
    for (var prop of __getOwnPropSymbols58(b2)) {
      if (__propIsEnum58.call(b2, prop))
        __defNormalProp58(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps51 = (a2, b2) => __defProps51(a2, __getOwnPropDescs51(b2));
var VaRatingItemProps = extractComponentProps(_VaRatingItem);
var VaRatingItemNumberButtonProps = extractComponentProps(VaRatingItemNumberButton, ["modelValue", "itemNumber"]);
var _sfc_main68 = defineComponent({
  name: "VaRating",
  props: __spreadProps51(__spreadValues58(__spreadValues58(__spreadValues58(__spreadValues58(__spreadValues58({}, useRatingProps), useVaRatingColorsProps), useFormProps), VaRatingItemProps), VaRatingItemNumberButtonProps), {
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: Number, default: 5 },
    texts: { type: Array, default: () => [] }
  }),
  emits: ["update:modelValue"],
  components: { VaRatingItem: _VaRatingItem, VaRatingItemNumberButton },
  setup(props) {
    const { computedClasses: rootClass } = useForm("va-rating", props);
    const rating = useRating(props);
    const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
    return __spreadProps51(__spreadValues58(__spreadValues58({}, useVaRatingColors(props)), rating), {
      rootClass,
      VaRatingItemProps: filterComponentProps(props, VaRatingItemProps),
      VaRatingItemNumberButtonProps: filterComponentProps(props, VaRatingItemNumberButtonProps),
      isInteractionsEnabled,
      tabIndexComputed: computed(() => isInteractionsEnabled.value ? 0 : void 0),
      onArrowKeyPress: (direction) => {
        const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
        rating.onItemValueUpdate(rating.visibleValue.value, step * direction);
      }
    });
  }
});
var _hoisted_145 = ["aria-label"];
function _sfc_render67(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaRatingItemNumberButton = resolveComponent("VaRatingItemNumberButton");
  const _component_va_rating_item = resolveComponent("va-rating-item");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-rating", _ctx.rootClass]),
    "aria-label": `current rating ${_ctx.$props.modelValue} of ${_ctx.$props.max}`
  }, [
    createBaseVNode("div", {
      class: "va-rating__item-wrapper",
      onKeyup: [
        _cache[0] || (_cache[0] = withKeys(($event) => _ctx.onArrowKeyPress(-1), ["left"])),
        _cache[1] || (_cache[1] = withKeys(($event) => _ctx.onArrowKeyPress(1), ["right"]))
      ],
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
        return openBlock(), createBlock(_component_va_rating_item, mergeProps({ key: itemNumber }, _ctx.VaRatingItemProps, {
          "aria-label": `vote rating ${itemNumber} of ${_ctx.$props.max}`,
          "model-value": _ctx.getItemValue(itemNumber - 1),
          tabindex: _ctx.tabIndexComputed,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onHover: ($event) => _ctx.isInteractionsEnabled && _ctx.onItemHoveredValueUpdate(itemNumber - 1, $event),
          "onUpdate:modelValue": ($event) => _ctx.isInteractionsEnabled && _ctx.onItemValueUpdate(itemNumber - 1, $event)
        }), createSlots({ _: 2 }, [
          _ctx.$props.numbers ? {
            name: "default",
            fn: withCtx(({ props }) => [
              createVNode(_component_VaRatingItemNumberButton, mergeProps(_ctx.VaRatingItemNumberButtonProps, {
                "model-value": props.value,
                "item-number": itemNumber,
                onClick: props.onClick
              }), null, 16, ["model-value", "item-number", "onClick"])
            ])
          } : void 0
        ]), 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
      }), 128))
    ], 32),
    _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "va-rating__text-wrapper",
      style: normalizeStyle({ color: _ctx.computedColor })
    }, toDisplayString(_ctx.$props.texts[Math.round(_ctx.visibleValue) - 1]), 5)) : createCommentVNode("", true)
  ], 10, _hoisted_145);
}
var _VaRating = _export_sfc(_sfc_main68, [["render", _sfc_render67]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/components/VaRatingItem/index.js
var VaRatingItem = withConfigTransport(_VaRatingItem);

// node_modules/vuestic-ui/dist/esm/src/components/va-rating/index.js
var VaRating = withConfigTransport(_VaRating);

// node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelect.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useMaxSelections.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections, emit) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= maxSelections.value;
  };
  const addOption = (optionToAdd) => {
    const newSelectedOptions = [...selections.value, optionToAdd];
    emit("update:modelValue", newSelectedOptions);
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}

// node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelectOptionList/VaSelectOptionList.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/utils/scroll-to-element.js
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};

// node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelectOptionList/VaSelectOptionList.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelectOptionList/VaSelectOptionList.css";
var __defProp59 = Object.defineProperty;
var __defProps52 = Object.defineProperties;
var __getOwnPropDescs52 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols59 = Object.getOwnPropertySymbols;
var __hasOwnProp59 = Object.prototype.hasOwnProperty;
var __propIsEnum59 = Object.prototype.propertyIsEnumerable;
var __defNormalProp59 = (obj, key2, value) => key2 in obj ? __defProp59(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues59 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp59.call(b2, prop))
      __defNormalProp59(a2, prop, b2[prop]);
  if (__getOwnPropSymbols59)
    for (var prop of __getOwnPropSymbols59(b2)) {
      if (__propIsEnum59.call(b2, prop))
        __defNormalProp59(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps52 = (a2, b2) => __defProps52(a2, __getOwnPropDescs52(b2));
var _sfc_main69 = defineComponent({
  name: "VaSelectOptionList",
  components: { VaIcon: VaIcon2 },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: __spreadProps52(__spreadValues59({}, useColorProps), {
    options: { type: Array, default: () => [] },
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    getGroupBy: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: {
      type: [String, Number, Object],
      default: null
    }
  }),
  setup(props, { emit }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const rootElement = shallowRef();
    const itemRefs = ref({});
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        emit("scroll-bottom");
      }
    };
    const beforeUpdate = () => {
      itemRefs.value = {};
    };
    const setItemRef = (option) => (el) => {
      if (el) {
        itemRefs.value[props.getTrackBy(option)] = el;
      }
    };
    const hoveredOptionComputed = computed({
      get: () => props.hoveredOption || null,
      set: (value) => emit("update:hoveredOption", value)
    });
    const filteredOptions = computed(() => {
      if (!props.search) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = props.getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !option.group) {
        groups._noGroup.push(option);
      } else {
        const groupBy = props.getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const selectOption = (option) => emit("select-option", option);
    const getOptionIcon = (option) => typeof option === "object" ? option.icon : void 0;
    const getOptionClass = (option) => ({
      "va-select-option-list__option": true,
      "va-select-option-list__option--selected": props.getSelectedState(option)
    });
    const getOptionStyle = (option) => ({
      color: props.getSelectedState(option) ? getColor(props.color) : "inherit",
      backgroundColor: isHovered(option) ? getHoverColor2(getColor(props.color)) : "transparent"
    });
    const isHovered = (option) => {
      if (!hoveredOptionComputed.value) {
        return false;
      }
      if (typeof option === "string") {
        return option === hoveredOptionComputed.value;
      }
      if (!props.getTrackBy) {
        return false;
      }
      return props.getTrackBy(hoveredOptionComputed.value) === props.getTrackBy(option);
    };
    const updateHoveredOption = (option) => {
      hoveredOptionComputed.value = option || null;
    };
    const hoveredOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {
      return !!hoveredOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(hoveredOptionComputed.value);
    }));
    const hoverPreviousOption = () => {
      if (!hoveredOptionComputed.value) {
        filteredOptions.value.length && updateHoveredOption(filteredOptions.value.at(-1));
      } else {
        if (filteredOptions.value[hoveredOptionIndex.value - 1]) {
          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value - 1];
        } else {
          emit("no-previous-option-to-hover");
        }
      }
    };
    const hoverNextOption = () => {
      if (!hoveredOptionComputed.value) {
        filteredOptions.value.length && updateHoveredOption(filteredOptions.value[0]);
      } else {
        if (filteredOptions.value[hoveredOptionIndex.value + 1]) {
          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value + 1];
        }
      }
    };
    const hoverFirstOption = () => {
      if (filteredOptions.value.length > 0) {
        updateHoveredOption(filteredOptions.value[0]);
      }
    };
    const focus = () => {
      var _a;
      (_a = rootElement.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const scrollToOption = (option) => {
      if (!option) {
        return;
      }
      const element = itemRefs.value[props.getTrackBy(option)];
      if (element) {
        scrollToElement(element);
      }
    };
    watch(() => props.hoveredOption, (newOption) => newOption && scrollToOption(newOption));
    const publicMethods = {
      hoverPreviousOption,
      hoverNextOption,
      hoverFirstOption,
      focus,
      scrollToOption
    };
    return __spreadValues59({
      rootElement,
      getColor,
      filteredOptions,
      optionGroups,
      onScroll,
      beforeUpdate,
      setItemRef,
      selectOption,
      getOptionIcon,
      getOptionClass,
      getOptionStyle,
      updateHoveredOption
    }, publicMethods);
  }
});
var _hoisted_146 = ["tabindex"];
var _hoisted_223 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
var _hoisted_312 = ["aria-selected", "onClick", "onMouseover"];
var _hoisted_48 = {
  key: 0,
  class: "va-select-option-list no-options"
};
function _sfc_render68(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.hoverNextOption && _ctx.hoverNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.hoverNextOption && _ctx.hoverNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_223, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
          return openBlock(), createElementBlock("div", {
            key: _ctx.$props.getTrackBy(option),
            ref_for: true,
            ref: _ctx.setItemRef(option),
            role: "option",
            "aria-selected": !!_ctx.$props.getSelectedState(option),
            class: normalizeClass(_ctx.getOptionClass(option)),
            style: normalizeStyle(_ctx.getOptionStyle(option)),
            onClick: ($event) => _ctx.selectOption(option),
            onMouseover: ($event) => _ctx.updateHoveredOption(option)
          }, [
            _ctx.getOptionIcon(option) ? (openBlock(), createBlock(_component_va_icon, {
              key: 0,
              size: "small",
              class: "va-select-option-list__option--icon",
              name: _ctx.getOptionIcon(option)
            }, null, 8, ["name"])) : createCommentVNode("", true),
            createBaseVNode("span", null, toDisplayString(_ctx.getText(option)), 1),
            withDirectives(createVNode(_component_va_icon, {
              class: "va-select-option-list__option--selected-icon",
              size: "small",
              name: "done",
              color: _ctx.getColor(_ctx.$props.color)
            }, null, 8, ["color"]), [
              [vShow, _ctx.$props.getSelectedState(option)]
            ])
          ], 46, _hoisted_312);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_48, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_146);
}
var _VaSelectOptionList = _export_sfc(_sfc_main69, [["render", _sfc_render68]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelectOptionList/index.js
var VaSelectOptionList = withConfigTransport(_VaSelectOptionList);

// node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelect.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-select/VaSelect.css";
var __defProp60 = Object.defineProperty;
var __defProps53 = Object.defineProperties;
var __getOwnPropDescs53 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols60 = Object.getOwnPropertySymbols;
var __hasOwnProp60 = Object.prototype.hasOwnProperty;
var __propIsEnum60 = Object.prototype.propertyIsEnumerable;
var __defNormalProp60 = (obj, key2, value) => key2 in obj ? __defProp60(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues60 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp60.call(b2, prop))
      __defNormalProp60(a2, prop, b2[prop]);
  if (__getOwnPropSymbols60)
    for (var prop of __getOwnPropSymbols60(b2)) {
      if (__propIsEnum60.call(b2, prop))
        __defNormalProp60(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps53 = (a2, b2) => __defProps53(a2, __getOwnPropDescs53(b2));
var _sfc_main70 = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectOptionList,
    VaIcon: VaIcon2,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: __spreadProps53(__spreadValues60(__spreadValues60(__spreadValues60(__spreadValues60(__spreadValues60(__spreadValues60({}, useSelectableListProps), useValidationProps), useLoadingProps), useMaxSelectionsProps), useClearableProps), useFormProps), {
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    separator: { type: String, default: ", " },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "Items not found" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    dropdownIcon: {
      type: [String, Object],
      default: () => ({
        open: "expand_more",
        close: "expand_less"
      }),
      validator: (value) => {
        if (typeof value === "string") {
          return true;
        }
        const isOpenIconString = typeof value.open === "string";
        const isCloseIconString = typeof value.close === "string";
        return isOpenIconString && isCloseIconString;
      }
    },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    requiredMark: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const { getHoverColor: getHoverColor2, getColor } = useColors();
    const { getOptionByValue, getValue: getValue2, getText, getTrackBy, getGroupBy } = useSelectableList(props);
    const {
      validate,
      computedError,
      computedErrorMessages
    } = useValidation(props, emit, () => reset(), () => focus());
    const colorComputed = computed(() => getColor(props.color));
    const toggleIconColor = computed(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
    const onScrollBottom = () => {
      emit("scroll-bottom");
    };
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const valueComputed = computed({
      get() {
        const value = getOptionByValue(props.modelValue);
        if (props.multiple) {
          if (!value) {
            return [];
          }
          if (!Array.isArray(value)) {
            return [value];
          }
          return value.map((o2) => getOptionByValue(o2));
        }
        if (Array.isArray(value)) {
          if (value.length) {
            return value[value.length - 1];
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue2));
        } else {
          emit("update:modelValue", getValue2(value));
        }
      }
    });
    const valueComputedString = computed(() => {
      if (!valueComputed.value) {
        return props.clearValue;
      }
      if (typeof valueComputed.value === "string" || typeof valueComputed.value === "number") {
        return valueComputed.value;
      }
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
      }
      return getText(valueComputed.value);
    });
    const isPlaceholder = computed(() => props.placeholder && !valueComputedString.value);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const toggleIcon = computed(() => {
      if (!props.dropdownIcon) {
        return "";
      }
      if (typeof props.dropdownIcon === "string") {
        return props.dropdownIcon;
      }
      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v2) => Array.isArray(v2.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections), emit);
        const isSelected = checkIsOptionSelected(getValue2(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue2(option), getValue2(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          addOption(getValue2(option));
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : __spreadValues60({}, option);
        hideAndFocus();
      }
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => getText(option) === searchInput.value);
      if (!(props.allowCreate === "unique" && hasAddedOption)) {
        emit("create-new", searchInput.value);
        searchInput.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value) {
        return;
      }
      if (!showDropdownContent.value) {
        showDropdown();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && searchInput.value !== "";
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const hoverPreviousOption = () => {
      var _a;
      (_a = optionList.value) == null ? void 0 : _a.hoverPreviousOption();
    };
    const hoverNextOption = () => {
      var _a;
      (_a = optionList.value) == null ? void 0 : _a.hoverNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? showDropdown() : hideDropdown();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const hideDropdown = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const toggleDropdown = () => {
      if (showDropdownContent.value) {
        hideAndFocus();
      } else {
        showDropdown();
      }
    };
    const onSelectClick = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      toggleDropdown();
    };
    const hideAndFocus = () => {
      hideDropdown();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.hoverFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const focus = () => {
      var _a;
      if (props.disabled) {
        return;
      }
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick((_a = input.value) == null ? void 0 : _a.blur);
    };
    const reset = () => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key2) => key2 === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    return {
      isFocused,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      onSelectClick,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueComputed,
      valueComputedString,
      showClearIcon,
      toggleIcon,
      computedErrorMessages,
      computedError,
      filteredOptions,
      checkIsOptionSelected,
      closeOnContentClick,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      hoverPreviousOption,
      hoverNextOption,
      showDropdownContentComputed,
      showDropdown,
      hideDropdown,
      hideAndFocus,
      toggleDropdown,
      toggleIconColor,
      onHintedSearch,
      getText,
      getTrackBy,
      getGroupBy,
      onScrollBottom,
      clearIconProps,
      isPlaceholder
    };
  }
});
var _hoisted_147 = {
  key: 0,
  class: "va-select-anchor__placeholder"
};
var _hoisted_224 = { class: "va-select-dropdown__options-wrapper" };
function _sfc_render69(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    ref: "dropdown",
    class: "va-select va-select__dropdown va-select-dropdown",
    "aria-label": `select option (currently selected: ${_ctx.$props.modelValue})`,
    placement: _ctx.$props.placement,
    disabled: _ctx.$props.disabled,
    "max-height": _ctx.$props.maxHeight,
    "close-on-content-click": _ctx.closeOnContentClick,
    stateful: false,
    offset: [1, 0],
    "keep-anchor-width": "",
    "keyboard-navigation": "",
    "inner-anchor-selector": ".va-input-wrapper__field",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    onClose: _ctx.focus
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, {
        ref: "input",
        class: "va-select__anchor va-select-anchor__input",
        "model-value": _ctx.valueComputedString,
        success: _ctx.$props.success,
        error: _ctx.computedError,
        color: _ctx.$props.color,
        label: _ctx.$props.label,
        loading: _ctx.$props.loading,
        disabled: _ctx.$props.disabled,
        outline: _ctx.$props.outline,
        bordered: _ctx.$props.bordered,
        "required-mark": _ctx.$props.requiredMark,
        messages: _ctx.$props.messages,
        "error-messages": _ctx.computedErrorMessages,
        focused: _ctx.isFocused,
        tabindex: _ctx.tabIndexComputed,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur
      }, createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-hidden": "false",
            "aria-label": "reset",
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          _ctx.$slots.appendInner ? renderSlot(_ctx.$slots, "appendInner", { key: 0 }) : createCommentVNode("", true),
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon
          }, null, 8, ["color", "name"])
        ]),
        default: withCtx(() => [
          _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_147, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
            valueString: _ctx.valueComputedString,
            value: _ctx.valueComputed,
            tabindex: _ctx.tabIndexComputed
          })), () => [
            createTextVNode(toDisplayString(_ctx.valueComputedString), 1)
          ])
        ]),
        _: 2
      }, [
        _ctx.$slots.prepend ? {
          name: "prepend",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prepend")
          ])
        } : void 0,
        _ctx.$slots.append ? {
          name: "append",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "append")
          ])
        } : void 0,
        _ctx.$slots.prependInner ? {
          name: "prependInner",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prependInner")
          ])
        } : void 0
      ]), 1032, ["model-value", "success", "error", "color", "label", "loading", "disabled", "outline", "bordered", "required-mark", "messages", "error-messages", "focused", "tabindex", "onFocus", "onBlur"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width })
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            placeholder: "Search",
            "aria-label": "options filter",
            tabindex: _ctx.tabIndexComputed,
            bordered: true,
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            onKeydown: [
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["tabindex", "modelValue", "onKeydown"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_224, [
            createVNode(_component_va_select_option_list, {
              ref: "optionList",
              hoveredOption: _ctx.hoveredOption,
              "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
              style: normalizeStyle({ maxHeight: _ctx.$props.maxHeight }),
              options: _ctx.filteredOptions,
              "selected-value": _ctx.valueComputed,
              "get-selected-state": _ctx.checkIsOptionSelected,
              "get-text": _ctx.getText,
              "get-track-by": _ctx.getTrackBy,
              "get-group-by": _ctx.getGroupBy,
              search: _ctx.searchInput,
              "no-options-text": _ctx.$props.noOptionsText,
              color: _ctx.$props.color,
              tabindex: _ctx.tabIndexComputed,
              onSelectOption: _ctx.selectOption,
              onNoPreviousOptionToHover: _ctx.focusSearchBar,
              onKeydown: [
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
                _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
                _ctx.onHintedSearch
              ],
              onScrollBottom: _ctx.onScrollBottom
            }, null, 8, ["hoveredOption", "style", "options", "selected-value", "get-selected-state", "get-text", "get-track-by", "get-group-by", "search", "no-options-text", "color", "tabindex", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
          ])
        ]),
        _: 1
      }, 8, ["style"])
    ]),
    _: 3
  }, 8, ["aria-label", "placement", "disabled", "max-height", "close-on-content-click", "modelValue", "onClose"]);
}
var _VaSelect = _export_sfc(_sfc_main70, [["render", _sfc_render69]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-select/index.js
var VaSelect = withConfigTransport(_VaSelect);

// node_modules/vuestic-ui/dist/esm/src/components/va-separator/VaSeparator.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-separator/VaSeparator.css";
var _sfc_main71 = defineComponent({
  name: "VaSeparator"
});
var _hoisted_148 = {
  class: "va-separator",
  "aria-hidden": "true"
};
function _sfc_render70(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_148);
}
var VaSeparator = _export_sfc(_sfc_main71, [["render", _sfc_render70]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebar.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/hooks/useSidebar.js
init_vue_runtime_esm_bundler();
var key = Symbol("VaSidebar");
var useSidebar = () => {
  const { props } = getCurrentInstance();
  provide(key, {
    color: toRef(props, "color")
  });
};
var useSidebarItem = () => {
  const { color } = inject(key, { color: ref("white") });
  return {
    sidebarColor: color
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebar.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebar.css";
var _sfc_main72 = defineComponent({
  name: "VaSidebar",
  props: {
    color: { type: String, default: "background" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    position: {
      type: String,
      default: "left",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: Boolean, default: true }
  },
  setup(props) {
    const { getColor } = useColors();
    useSidebar();
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const computedWidth = computed(() => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    });
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => {
      const backgroundColor = getColor(props.color);
      const background = props.gradient ? getGradientBackground(backgroundColor) : backgroundColor;
      const color = textColorComputed.value;
      return {
        color,
        background,
        width: computedWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      right: props.position === "right",
      animated: props.animated
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    return {
      computedClass,
      computedStyle,
      updateHoverState
    };
  }
});
var _hoisted_149 = { class: "va-sidebar__menu" };
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("aside", {
    class: normalizeClass(["va-sidebar", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.updateHoverState(false))
  }, [
    createBaseVNode("div", _hoisted_149, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 38);
}
var _VaSidebar = _export_sfc(_sfc_main72, [["render", _sfc_render71]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.css";
var __defProp61 = Object.defineProperty;
var __defProps54 = Object.defineProperties;
var __getOwnPropDescs54 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols61 = Object.getOwnPropertySymbols;
var __hasOwnProp61 = Object.prototype.hasOwnProperty;
var __propIsEnum61 = Object.prototype.propertyIsEnumerable;
var __defNormalProp61 = (obj, key2, value) => key2 in obj ? __defProp61(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues61 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp61.call(b2, prop))
      __defNormalProp61(a2, prop, b2[prop]);
  if (__getOwnPropSymbols61)
    for (var prop of __getOwnPropSymbols61(b2)) {
      if (__propIsEnum61.call(b2, prop))
        __defNormalProp61(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps54 = (a2, b2) => __defProps54(a2, __getOwnPropDescs54(b2));
var _sfc_main73 = defineComponent({
  name: "VaSidebarItem",
  props: __spreadProps54(__spreadValues61({}, useRouterLinkProps), {
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    borderColor: { type: String, default: void 0 }
  }),
  setup(props) {
    const anchor = shallowRef();
    const { isHovered } = useHover(anchor);
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { sidebarColor } = useSidebarItem();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      return getColor(sidebarColor.value);
    });
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const style = {
        color: props.textColor
      };
      if (props.active) {
        style.backgroundColor = backgroundColorComputed.value;
        style.color = textColorComputed.value;
        style.borderColor = getColor(props.borderColor || props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(getColor(props.hoverColor || props.activeColor));
      }
      return style;
    });
    const { tagComputed, hrefComputed } = useRouterLink(props);
    return {
      anchor,
      computedStyle,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isHovered
    };
  }
});
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "anchor",
    class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to
  }, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "style", "href", "to"]);
}
var _VaSidebarItem = _export_sfc(_sfc_main73, [["render", _sfc_render72]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.css";
var _sfc_main74 = defineComponent({
  name: "VaSidebarItemContent"
});
var _hoisted_150 = { class: "va-sidebar__item__content va-sidebar-item-content" };
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_150, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemContent = _export_sfc(_sfc_main74, [["render", _sfc_render73]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.css";
var _sfc_main75 = defineComponent({
  name: "VaSidebarItemTitle"
});
var _hoisted_151 = { class: "va-sidebar__title va-sidebar-item-title" };
function _sfc_render74(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_151, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemTitle = _export_sfc(_sfc_main75, [["render", _sfc_render74]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/VaSidebarItem/index.js
var VaSidebarItemContent = withConfigTransport(_VaSidebarItemContent);
var VaSidebarItemTitle = withConfigTransport(_VaSidebarItemTitle);
var VaSidebarItem = withConfigTransport(_VaSidebarItem);

// node_modules/vuestic-ui/dist/esm/src/components/va-sidebar/index.js
var VaSidebar = withConfigTransport(_VaSidebar);

// node_modules/vuestic-ui/dist/esm/src/components/va-slider/VaSlider.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-slider/validateSlider.js
var validateSlider = (value, step, min, max, range) => {
  const inRange = (v2) => {
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  }
  return true;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-slider/VaSlider.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-slider/VaSlider.css";
var __defProp62 = Object.defineProperty;
var __defProps55 = Object.defineProperties;
var __getOwnPropDescs55 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols62 = Object.getOwnPropertySymbols;
var __hasOwnProp62 = Object.prototype.hasOwnProperty;
var __propIsEnum62 = Object.prototype.propertyIsEnumerable;
var __defNormalProp62 = (obj, key2, value) => key2 in obj ? __defProp62(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues62 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp62.call(b2, prop))
      __defNormalProp62(a2, prop, b2[prop]);
  if (__getOwnPropSymbols62)
    for (var prop of __getOwnPropSymbols62(b2)) {
      if (__propIsEnum62.call(b2, prop))
        __defNormalProp62(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps55 = (a2, b2) => __defProps55(a2, __getOwnPropDescs55(b2));
var _sfc_main76 = defineComponent({
  name: "VaSlider",
  components: { VaIcon: VaIcon2 },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  props: {
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true }
  },
  setup(props, { emit, slots }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset = ref(0);
    const size2 = ref(0);
    const currentValue = ref(Array.isArray(props.modelValue) ? [...props.modelValue] : props.modelValue);
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => __spreadProps55(__spreadValues62({}, pick_1(props, ["disabled", "readonly", "vertical"])), {
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [trackSizeStyle.value]: `${val2}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val2}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range && index !== void 0 ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => props.modelValue,
      set: (val2) => {
        if (!props.range) {
          val2 = limitValue(val2);
        }
        if (!flag.value) {
          emit("change", val2);
        }
        emit("update:modelValue", val2);
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props.max - props.min) / props.step;
      return size2.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props.max - props.min) / props.step - 1);
    const position = computed(() => {
      return Array.isArray(props.modelValue) ? [(props.modelValue[0] - props.min) / props.step * gap.value, (props.modelValue[1] - props.min) / props.step * gap.value] : (props.modelValue - props.min) / props.step * gap.value;
    });
    const limit = computed(() => [0, size2.value]);
    const valueLimit = computed(() => [props.min, props.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e2, index = currentSliderDotIndex.value) => {
      var _a, _b;
      e2.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e2 ? e2.touches[0] : e2;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(props.modelValue)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(props.modelValue) ? (_a = dots.value[index]) == null ? void 0 : _a.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e2) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e2.preventDefault();
      if ("touches" in e2) {
        setValueOnPos(getPos(e2.touches[0]));
      } else {
        setValueOnPos(getPos(e2));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", props.modelValue);
        } else {
          return false;
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const moveWithKeys = (event) => {
      var _a, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (isRange3, where, which) => {
        if (isRange3 && Array.isArray(val.value)) {
          if (!props.pins) {
            return val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = val.value[which] / onePinInterval | 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value[which] !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value.splice(which, 1, nearestPinVal);
          } else {
            val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
        } else {
          if (!props.pins && !Array.isArray(val.value)) {
            val.value += where ? props.step : -props.step;
            return;
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = !Array.isArray(val.value) ? val.value / onePinInterval | 0 : 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value = nearestPinVal;
          } else {
            val.value += where ? props.step : -props.step;
          }
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min):
            (_a = dots.value[0]) == null ? void 0 : _a.focus();
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min):
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max):
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min):
            moveDot(true, 0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max):
            moveDot(true, 1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(false, 1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(false, 1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props.step > val.value[0] && pin * props.step < val.value[1];
      } else {
        return pin * props.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e2) => {
      getStaticData();
      return props.vertical ? offset.value - e2.clientY : e2.clientX - offset.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size2.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value) && Array.isArray(currentValue.value) && Array.isArray(props.modelValue)) {
        if (isDiff(currentValue.value[slider], newValue)) {
          currentValue.value.splice(slider, 1, newValue);
          if (slider === 0) {
            val.value = [currentValue.value.splice(slider, 1, newValue)[0], props.modelValue[1]];
            currentValue.value = [...val.value];
          } else {
            val.value = [props.modelValue[0], currentValue.value.splice(slider, 1, newValue)[0]];
            currentValue.value = [...val.value];
          }
        }
      } else {
        if (newValue < props.min || newValue > props.max) {
          return false;
        }
        if (isDiff(currentValue.value, newValue)) {
          currentValue.value = newValue;
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(props.modelValue) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value[1] = val.value[0];
            currentSliderDotIndex.value = 0;
          }
          const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v2);
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value[0] = val.value[1];
            currentSliderDotIndex.value = 1;
          }
          const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v2);
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const limitValue = (val2) => {
      const inRange = (v2) => {
        if (v2 < props.min) {
          return props.min;
        } else if (v2 > props.max) {
          return props.max;
        }
        return v2;
      };
      if (Array.isArray(val2)) {
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 0) {
          const v2 = inRange(val2[1]);
          return [v2, v2];
        }
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 1) {
          const v2 = inRange(val2[0]);
          return [v2, v2];
        }
        return val2.map((v2) => inRange(v2));
      } else {
        return inRange(val2);
      }
    };
    const isDiff = (a2, b2) => JSON.stringify(a2) !== JSON.stringify(b2);
    const clickOnContainer = (e2) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e2 ? getPos(e2.touches[0]) : getPos(e2);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e2, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": props.min,
      "aria-valuemax": props.max,
      "aria-label": !slots.label && !props.label ? `current slider value is ${String(props.modelValue)}` : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      ariaOrientation: props.vertical ? "vertical" : "horizontal",
      ariaDisabled: props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(props.modelValue) ? props.modelValue : void 0,
      "aria-valuetext": Array.isArray(props.modelValue) ? String(props.modelValue) : void 0
    }));
    onMounted(() => {
      if (validateSlider(props.modelValue, props.step, props.min, props.max, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props.step,
      () => props.min,
      () => props.max,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return {
      getColor,
      dot,
      dots,
      setItemRefByIndex,
      orders,
      sliderContainer,
      val,
      getValueByOrder,
      sliderClass,
      dotClass,
      labelStyles,
      processedStyles,
      getPinStyles,
      dottedStyles,
      getDottedStyles,
      clickOnContainer,
      hasMouseDown,
      trackStyles,
      pinsCol,
      checkActivePin,
      isFocused,
      isActiveDot,
      getTrackLabel,
      currentSliderDotIndex,
      ariaLabelIdComputed,
      ariaAttributesComputed
    };
  }
});
var _hoisted_153 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_225 = ["id"];
var _hoisted_313 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_49 = ["tabindex", "onFocus"];
var _hoisted_57 = ["tabindex"];
var _hoisted_66 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_74 = ["id"];
var _hoisted_83 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
function _sfc_render75(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_153, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "append" : "prepend")
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "va-input__label",
      id: _ctx.ariaLabelIdComputed,
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_225)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_313, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args)),
      onMouseup: _cache[4] || (_cache[4] = ($event) => _ctx.hasMouseDown = false),
      onTouchstart: _cache[5] || (_cache[5] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args))
    }, [
      createBaseVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4),
      _ctx.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i2) => {
        return openBlock(), createElementBlock("div", {
          key: i2,
          class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": _ctx.checkActivePin(pin) }]),
          style: normalizeStyle(_ctx.getPinStyles(pin))
        }, null, 6);
      }), 128)) : createCommentVNode("", true),
      _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", {
          ref: "process",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          "aria-hidden": "true",
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
          return openBlock(), createElementBlock("div", {
            key: "dot" + order,
            ref_for: true,
            ref: _ctx.setItemRefByIndex(order),
            class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
            style: normalizeStyle(_ctx.getDottedStyles(order)),
            tabindex: _ctx.disabled || _ctx.readonly ? void 0 : 0,
            onFocus: ($event) => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
            onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = false)
          }, [
            _ctx.isActiveDot(order) ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
              class: "va-slider__handler__dot--focus"
            }, null, 4)) : createCommentVNode("", true),
            _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle(_ctx.labelStyles),
              class: "va-slider__handler__dot--value"
            }, [
              renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1)
              ])
            ], 4)) : createCommentVNode("", true)
          ], 46, _hoisted_49);
        }), 128))
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createBaseVNode("div", {
          ref: "process",
          "aria-hidden": "true",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        createBaseVNode("div", {
          ref: "dot",
          class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
          style: normalizeStyle(_ctx.dottedStyles),
          tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = false)
        }, [
          _ctx.isActiveDot(0) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-slider__handler__dot--focus",
            style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
          }, null, 4)) : createCommentVNode("", true),
          _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-slider__handler__dot--value",
            style: normalizeStyle(_ctx.labelStyles)
          }, [
            renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
              createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1)
            ])
          ], 4)) : createCommentVNode("", true)
        ], 46, _hoisted_57)
      ], 64))
    ], 544),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_66, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && _ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 4,
      class: "va-input__label va-input__label--inverse",
      style: normalizeStyle(_ctx.labelStyles),
      id: _ctx.ariaLabelIdComputed
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_74)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_83, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "prepend" : "append")
    ])) : createCommentVNode("", true)
  ], 16);
}
var _VaSlider = _export_sfc(_sfc_main76, [["render", _sfc_render75]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-slider/index.js
var VaSlider = withConfigTransport(_VaSlider);

// node_modules/vuestic-ui/dist/esm/src/components/va-spacer/VaSpacer.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-spacer/VaSpacer.css";
var _sfc_main77 = defineComponent({
  name: "VaSpacer"
});
var _hoisted_154 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
function _sfc_render76(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_154);
}
var VaSpacer = _export_sfc(_sfc_main77, [["render", _sfc_render76]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tabs/VaTabs.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-tabs/types.js
var TabsViewKey = Symbol("TabsView");
var TabKey = Symbol("Tab");

// node_modules/vuestic-ui/dist/esm/src/components/va-tabs/VaTabs.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-tabs/VaTabs.css";
var __defProp63 = Object.defineProperty;
var __defProps56 = Object.defineProperties;
var __getOwnPropDescs56 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols63 = Object.getOwnPropertySymbols;
var __hasOwnProp63 = Object.prototype.hasOwnProperty;
var __propIsEnum63 = Object.prototype.propertyIsEnumerable;
var __defNormalProp63 = (obj, key2, value) => key2 in obj ? __defProp63(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues63 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp63.call(b2, prop))
      __defNormalProp63(a2, prop, b2[prop]);
  if (__getOwnPropSymbols63)
    for (var prop of __getOwnPropSymbols63(b2)) {
      if (__propIsEnum63.call(b2, prop))
        __defNormalProp63(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps56 = (a2, b2) => __defProps56(a2, __getOwnPropDescs56(b2));
var getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
var _sfc_main78 = defineComponent({
  name: "VaTabs",
  components: { VaButton: VaButton2, VaConfig },
  emits: ["update:modelValue", "click:next", "click:prev"],
  props: __spreadProps56(__spreadValues63({}, useStatefulProps), {
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "chevron_left" },
    nextIcon: { type: String, default: "chevron_right" }
  }),
  setup: (props, { emit }) => {
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : ""
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (showPagination.value && leftSidePosition + containerClientWidth <= tabsClientWidth) {
        tabsContentOffset.value = leftSidePosition;
      } else if (showPagination.value && rightSidePosition >= containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
      } else {
        tabsContentOffset.value = 0;
      }
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a;
        tab.updateSidePositions();
        const isTabSelected = (((_a = tab.name) == null ? void 0 : _a.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (tabsContentOffset.value + containerClientWidth > tabsClientWidth && tabsList.value) {
        moveToTab(tabsList.value[0]);
      }
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
    };
    const movePaginationLeft = () => {
      var _a, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      if (tabsList.value) {
        for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
          const currentTabLeftSidePosition = unref((_a = tabsList.value[i2]) == null ? void 0 : _a.leftSidePosition);
          const nextTabLeftSidePosition = unref((_b = tabsList.value[i2 + 1]) == null ? void 0 : _b.leftSidePosition);
          if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
            offsetToSet = currentTabLeftSidePosition;
            break;
          }
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      if (tabsList.value) {
        for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
          const rightSidePosition2 = unref(tabsList.value[i2].rightSidePosition);
          if (rightSidePosition2 > containerRightSide) {
            offsetToSet = unref(tabsList.value[i2].leftSidePosition);
            if (tabsContentOffset.value < offsetToSet) {
              break;
            }
          }
        }
      }
      const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a = container.value) == null ? void 0 : _a.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const redrawTabs = () => {
      const oldShowPaginationValue = showPagination.value;
      updatePagination();
      if (oldShowPaginationValue === showPagination.value) {
        updateTabsState();
        includeAnimation();
      } else {
        requestAnimationFrame(() => {
          updateTabsState();
          includeAnimation();
        });
      }
    };
    const selectTab = (tab) => {
      var _a;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a = tab.name) == null ? void 0 : _a.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a = tab.name) == null ? void 0 : _a.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a;
        tabListItem.id = ((_a = tabListItem.name) == null ? void 0 : _a.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper, tabs], redrawTabs);
    return {
      wrapper,
      container,
      tabs,
      tabsList,
      sliderHeight,
      sliderWidth,
      sliderOffsetX,
      sliderOffsetY,
      showPagination,
      tabsContentOffset,
      startingXPoint,
      animationIncluded,
      colorComputed,
      tabConfig,
      computedClass,
      computedTabsClass,
      tabSelected,
      sliderStyles,
      paginationControlledStyles,
      disablePaginationLeft,
      disablePaginationRight,
      resetSliderSizes,
      moveToTab,
      updateStartingXPoint,
      updateTabsState,
      updatePagination,
      movePaginationLeft,
      movePaginationRight,
      updateSlider,
      includeAnimation,
      redrawTabs,
      selectTab
    };
  }
});
var _hoisted_155 = ["aria-disabled"];
var _hoisted_226 = createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_314 = [
  _hoisted_226
];
var _hoisted_410 = { class: "va-tabs__tabs-items" };
var _hoisted_58 = { class: "va-tabs__content" };
function _sfc_render77(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createBaseVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        class: "va-tabs__pagination",
        "aria-label": "move pagination left",
        size: "medium",
        disabled: _ctx.disablePaginationLeft,
        color: _ctx.color,
        flat: "",
        icon: _ctx.$props.prevIcon,
        onClick: _ctx.movePaginationLeft
      }, null, 8, ["disabled", "color", "icon", "onClick"])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createBaseVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createBaseVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_314, 4),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_410, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3
          }, 8, ["components"])
        ], 4)
      ], 2),
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        class: "va-tabs__pagination",
        "aria-label": "move pagination right",
        size: "medium",
        color: _ctx.color,
        disabled: _ctx.disablePaginationRight,
        flat: "",
        icon: _ctx.$props.nextIcon,
        onClick: _ctx.movePaginationRight
      }, null, 8, ["color", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ], 8, _hoisted_155),
    createBaseVNode("div", _hoisted_58, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var _VaTabs = _export_sfc(_sfc_main78, [["render", _sfc_render77]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tabs/components/VaTab/VaTab.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-tabs/components/VaTab/VaTab.css";
var __defProp64 = Object.defineProperty;
var __defProps57 = Object.defineProperties;
var __getOwnPropDescs57 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols64 = Object.getOwnPropertySymbols;
var __hasOwnProp64 = Object.prototype.hasOwnProperty;
var __propIsEnum64 = Object.prototype.propertyIsEnumerable;
var __defNormalProp64 = (obj, key2, value) => key2 in obj ? __defProp64(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues64 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp64.call(b2, prop))
      __defNormalProp64(a2, prop, b2[prop]);
  if (__getOwnPropSymbols64)
    for (var prop of __getOwnPropSymbols64(b2)) {
      if (__propIsEnum64.call(b2, prop))
        __defNormalProp64(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps57 = (a2, b2) => __defProps57(a2, __getOwnPropDescs57(b2));
var _sfc_main79 = defineComponent({
  name: "VaTab",
  components: { VaIcon: VaIcon2 },
  emits: ["click", "keydown-enter", "focus"],
  props: __spreadProps57(__spreadValues64({}, useRouterLinkProps), {
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  }),
  setup: (props, { emit }) => {
    const tabElement = shallowRef();
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props);
    const classComputed = computed(() => ({ "va-tab--disabled": props.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      color: hasKeyboardFocus.value || hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a, _b;
      const componentOffsetLeft = ((_a = tabElement.value) == null ? void 0 : _a.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const onTabClick = () => {
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = () => {
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return {
      tabElement,
      parentDisabled,
      isActive,
      hoverState,
      hasKeyboardFocus,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isActiveRouterLink,
      colorComputed,
      classComputed,
      computedStyle,
      tabIndexComputed,
      rightSidePosition,
      leftSidePosition,
      updateHoverState,
      updateSidePositions,
      onTabClick,
      onTabKeydown,
      onFocus
    };
  }
});
var _hoisted_156 = ["tabindex"];
var _hoisted_227 = ["textContent"];
function _sfc_render78(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    ref: "tabElement",
    class: normalizeClass(["va-tab", _ctx.classComputed]),
    role: "tab",
    "aria-selected": _ctx.isActive,
    "aria-disabled": _ctx.$props.disabled || _ctx.parentDisabled,
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.updateHoverState(false))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({ class: "va-tab__content" }, toHandlers(_ctx.keyboardFocusListeners), {
        tabindex: _ctx.tabIndexComputed,
        onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onTabClick && _ctx.onTabClick(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onTabKeydown && _ctx.onTabKeydown(...args), ["enter"]))
      }), [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-tab__icon",
            size: "small",
            name: _ctx.icon
          }, null, 8, ["name"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: "va-tab__label",
            textContent: toDisplayString(_ctx.label)
          }, null, 8, _hoisted_227)
        ])
      ], 16, _hoisted_156)
    ]),
    _: 3
  }, 8, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]);
}
var _VaTab = _export_sfc(_sfc_main79, [["render", _sfc_render78]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tabs/components/VaTab/index.js
var VaTab = withConfigTransport(_VaTab);

// node_modules/vuestic-ui/dist/esm/src/components/va-tabs/index.js
var VaTabs = withConfigTransport(_VaTabs);

// node_modules/vuestic-ui/dist/esm/src/components/va-time-input/VaTimeInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-time-input/hooks/time-text-parser.js
init_vue_runtime_esm_bundler();
var parse = (text) => {
  const m2 = text.match(/[0-9]{1,2}/g);
  if (!m2) {
    return [];
  }
  return m2.map((s2) => Number(s2));
};
var parsePeriod = (text) => {
  const m2 = text.match(/pm|am/i);
  if (!m2) {
    return null;
  }
  return Number(m2[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d2 = new Date();
  const [h3, m2, s2] = parse(text);
  const period = parsePeriod(text);
  if (!h3) {
    return null;
  }
  const is12format = period !== null && h3 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h3 === 12 ? 0 : h3 : h3;
  d2.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d2.setMinutes(Math.min(m2 || 0, 60));
  d2.setSeconds(Math.min(s2 || 0, 60));
  return d2;
};
var useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction2;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-time-input/hooks/time-text-formatter.js
var useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/VaTimePicker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/hooks/useTimePicker.js
init_vue_runtime_esm_bundler();
var safeModelValue = (m2) => m2.value ? m2.value : new Date(new Date().setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h3) => (h3 === 0 ? 12 : h3) - Number(h3 > 12) * 12;
var from12to24 = (h3, isAM = false) => (h3 === 12 ? 0 : h3) + Number(isAM) * 12;
var createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed(() => props.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i2) => props.hoursFilter(props.ampm ? i2 + 12 * Number(isPM.value) : i2));
    }
    return array.map((n2) => {
      return props.ampm ? from24to12(n2) : n2;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i2) => i2 === h22);
      }
      const h3 = modelValue.value.getHours();
      return items2.value.findIndex((i2) => i2 === h3);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m2 = modelValue.value.getMinutes();
      return items2.value.findIndex((i2) => i2 === m2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s2 = modelValue.value.getSeconds();
      return items2.value.findIndex((i2) => i2 === s2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h3 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h3 + 12 : h3;
        if (isPM.value && h3 <= 12) {
          h24 = h3 + 12;
        }
        if (!isPM.value && h3 >= 12) {
          h24 = h3 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props, modelValue) => {
  const { view } = toRefs(props);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.css";
var _sfc_main80 = defineComponent({
  name: "VaTimePickerColumn",
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        rootElement.value.scrollTo({
          behavior: animated ? "smooth" : "auto",
          top: index * props.cellHeight
        });
      });
    };
    const makeActiveByIndex = (index) => {
      syncActiveItemIndex.value = index;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n2) => {
      if (!Number.isInteger(n2)) {
        return n2;
      }
      return n2 < 10 ? `0${n2}` : `${n2}`;
    };
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max((scrollTop - scrollTop % props.cellHeight) / props.cellHeight, scrollTop / props.cellHeight);
      if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce_1(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    return {
      rootElement,
      makeActiveNext,
      makeActivePrev,
      makeActiveByIndex,
      onScroll,
      onCellClick,
      formatCell,
      focus,
      blur
    };
  }
});
var _hoisted_157 = ["onClick"];
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    tabindex: "0",
    class: "va-time-picker-column",
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(), ["stop", "prevent"]), ["down"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(5), ["stop", "prevent"]), ["space"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.makeActivePrev(), ["stop", "prevent"]), ["up"]))
    ],
    onScrollPassive: _cache[3] || (_cache[3] = (...args) => _ctx.onScroll && _ctx.onScroll(...args)),
    onTouchmovePassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
      return openBlock(), createElementBlock("div", {
        key: item,
        class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
        onClick: ($event) => _ctx.onCellClick(index)
      }, [
        renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: _ctx.activeItemIndex, items: _ctx.items, formattedItem: _ctx.formatCell(item) })), () => [
          createTextVNode(toDisplayString(_ctx.formatCell(item)), 1)
        ])
      ], 10, _hoisted_157);
    }), 128))
  ], 544);
}
var _VaTimePickerColumn = _export_sfc(_sfc_main80, [["render", _sfc_render79]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/components/VaTimePickerColumn/index.js
var VaTimePickerColumn = withConfigTransport(_VaTimePickerColumn);

// node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/VaTimePicker.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/VaTimePicker.css";
var __defProp65 = Object.defineProperty;
var __defProps58 = Object.defineProperties;
var __getOwnPropDescs58 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols65 = Object.getOwnPropertySymbols;
var __hasOwnProp65 = Object.prototype.hasOwnProperty;
var __propIsEnum65 = Object.prototype.propertyIsEnumerable;
var __defNormalProp65 = (obj, key2, value) => key2 in obj ? __defProp65(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues65 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp65.call(b2, prop))
      __defNormalProp65(a2, prop, b2[prop]);
  if (__getOwnPropSymbols65)
    for (var prop of __getOwnPropSymbols65(b2)) {
      if (__propIsEnum65.call(b2, prop))
        __defNormalProp65(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps58 = (a2, b2) => __defProps58(a2, __getOwnPropDescs58(b2));
var _sfc_main81 = defineComponent({
  name: "VaTimePicker",
  components: { VaTimePickerColumn },
  props: __spreadProps58(__spreadValues65(__spreadValues65({}, useStatefulProps), useFormProps), {
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: Number, default: 30 },
    visibleCellsCount: { type: Number, default: 7 }
  }),
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { columns, isPM } = useTimePicker(props, valueComputed);
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a;
      (_a = pickers.value[idx]) == null ? void 0 : _a.focus();
    };
    const blur = (idx) => {
      var _a;
      idx ? (_a = pickers.value[idx]) == null ? void 0 : _a.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useForm("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => __spreadProps58(__spreadValues65({}, computedFormClasses), {
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
      return {
        height: `${props.cellHeight * props.visibleCellsCount}px`,
        "cell-height": `${props.cellHeight}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    return {
      columns,
      computedStyles,
      computedClasses,
      isPM,
      pickers,
      setItemRef,
      focusNext,
      focusPrev,
      activeColumnIndex,
      focus,
      blur
    };
  }
});
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumn = resolveComponent("VaTimePickerColumn");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-time-picker", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyles)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column, idx) => {
      return openBlock(), createBlock(_component_VaTimePickerColumn, {
        key: idx,
        ref_for: true,
        ref: _ctx.setItemRef,
        items: column.items,
        tabindex: _ctx.disabled ? -1 : 0,
        "cell-height": _ctx.$props.cellHeight,
        activeItemIndex: column.activeItem.value,
        "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["stop", "prevent"]), ["right"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["stop", "prevent"]), ["left"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
        ],
        onFocus: ($event) => _ctx.activeColumnIndex = idx
      }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
    }), 128))
  ], 6);
}
var _VaTimePicker = _export_sfc(_sfc_main81, [["render", _sfc_render80]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-time-input/VaTimeInput.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-time-input/VaTimeInput.css";
var __defProp66 = Object.defineProperty;
var __defProps59 = Object.defineProperties;
var __getOwnPropDescs59 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols66 = Object.getOwnPropertySymbols;
var __hasOwnProp66 = Object.prototype.hasOwnProperty;
var __propIsEnum66 = Object.prototype.propertyIsEnumerable;
var __defNormalProp66 = (obj, key2, value) => key2 in obj ? __defProp66(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues66 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp66.call(b2, prop))
      __defNormalProp66(a2, prop, b2[prop]);
  if (__getOwnPropSymbols66)
    for (var prop of __getOwnPropSymbols66(b2)) {
      if (__propIsEnum66.call(b2, prop))
        __defNormalProp66(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps59 = (a2, b2) => __defProps59(a2, __getOwnPropDescs59(b2));
var VaInputWrapperProps2 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var _sfc_main82 = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    "update:modelValue",
    "update:isOpen"
  ],
  props: __spreadProps59(__spreadValues66(__spreadValues66(__spreadValues66(__spreadValues66({}, useClearableProps), VaInputWrapperProps2), extractComponentProps(_VaTimePicker)), useValidationProps), {
    isOpen: { type: Boolean, default: void 0 },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" }
  }),
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
    const [modelValueSync] = useSyncProp("modelValue", props, emit);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(modelValueSync.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v2) {
        isOpenSync.value = v2;
        if (v2) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e2) => {
      var _a;
      const val = (_a = e2.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v2 = parse2(val);
      if (isValid.value && v2) {
        modelValueSync.value = v2;
      } else {
        modelValueSync.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
    };
    const { computedError, computedErrorMessages, listeners, validationAriaAttributes } = useValidation(props, emit, reset, focus);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const iconProps = computed(() => ({
      name: props.icon,
      color: props.color,
      size: "small"
    }));
    const computedInputWrapperProps = computed(() => __spreadProps59(__spreadValues66({}, filterComponentProps(props, VaInputWrapperProps2).value), {
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e2) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e2 == null ? void 0 : e2.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const inputAttributesComputed = computed(() => __spreadValues66(__spreadValues66({
      readonly: props.readonly || !props.manualInput,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || "selected date",
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    return {
      input,
      timePicker,
      timePickerProps: filterComponentProps(props, extractComponentProps(_VaTimePicker)),
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      modelValueSync,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      iconTabindexComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render81(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    modelValue: _ctx.doShowDropdown,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.doShowDropdown = $event),
    class: normalizeClass(["va-time-input", _ctx.$attrs.class]),
    placement: "bottom-start",
    "inner-anchor-selector": ".va-input-wrapper__field",
    style: normalizeStyle(_ctx.$attrs.style),
    offset: [2, 0],
    "close-on-content-click": false,
    disabled: _ctx.$props.disabled,
    "keyboard-navigation": ""
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({ class: "va-time-input__anchor" }, _ctx.computedInputWrapperProps), createSlots({
        default: withCtx(() => [
          createBaseVNode("input", mergeProps({
            ref: "input",
            class: "va-time-input__input"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.computedInputListeners), {
            onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
          }), null, 16)
        ]),
        prependInner: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(__spreadProps59(__spreadValues66({}, slotScope), { toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))),
          _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": "toggle dropdown",
            "aria-hidden": "false",
            tabindex: _ctx.iconTabindexComputed
          }, _ctx.iconProps), null, 16, ["tabindex"])) : createCommentVNode("", true)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": "reset time",
            "aria-hidden": "false",
            tabindex: _ctx.iconTabindexComputed
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["tabindex", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            role: "button",
            "aria-label": "toggle dropdown",
            "aria-hidden": "false",
            tabindex: _ctx.iconTabindexComputed
          }, _ctx.iconProps), null, 16, ["tabindex"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(__spreadProps59(__spreadValues66({}, slotScope), { toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))))
            ])
          };
        })
      ]), 1040)
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.modelValueSync = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown", "onKeypress"])
    ]),
    _: 3
  }, 8, ["modelValue", "class", "style", "disabled"]);
}
var _VaTimeInput = _export_sfc(_sfc_main82, [["render", _sfc_render81]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-time-input/index.js
var VaTimeInput = withConfigTransport(_VaTimeInput);

// node_modules/vuestic-ui/dist/esm/src/components/va-time-picker/index.js
var VaTimePicker = withConfigTransport(_VaTimePicker);

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimeline.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimeline.css";
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a;
  return !!((_a = slot == null ? void 0 : slot.props) == null ? void 0 : _a.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a;
  const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME = "va-timeline";
var _sfc_main83 = {
  name: COMPONENT_NAME,
  props: {
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props, { slots }) {
    return () => h("div", {
      class: {
        [COMPONENT_NAME]: true,
        [`${COMPONENT_NAME}--vertical`]: props.vertical,
        [`${COMPONENT_NAME}--align-top`]: props.alignTop
      }
    }, processSlots({ props, slots }));
  }
};

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineItem/VaTimelineItem.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.css";
var componentName2 = "va-timeline-separator";
var _sfc_main84 = defineComponent({
  name: componentName2,
  props: {
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props) {
    const { getColor } = useColors();
    return () => h("div", {
      class: {
        [componentName2]: true,
        [`${componentName2}--vertical`]: props.vertical
      }
    }, [
      h("div", {
        class: {
          [`${componentName2}__line`]: true,
          [`${componentName2}__line--active`]: props.activePrevious
        },
        style: {
          backgroundColor: getColor(props.activePrevious ? props.color : "divider")
        }
      }),
      h("div", {
        class: {
          [`${componentName2}__center`]: true,
          [`${componentName2}__center--active`]: props.active
        },
        style: {
          backgroundColor: getColor(props.active ? props.color : "divider")
        }
      }),
      h("div", {
        class: {
          [`${componentName2}__line`]: true,
          [`${componentName2}__line--active`]: props.activeNext
        },
        style: {
          backgroundColor: getColor(props.activeNext ? props.color : "divider")
        }
      })
    ]);
  }
});

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineSeparator/index.js
var VaTimelineSeparator = withConfigTransport(_sfc_main84);

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineItem/VaTimelineItem.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineItem/VaTimelineItem.css";
var __defProp67 = Object.defineProperty;
var __defProps60 = Object.defineProperties;
var __getOwnPropDescs60 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols67 = Object.getOwnPropertySymbols;
var __hasOwnProp67 = Object.prototype.hasOwnProperty;
var __propIsEnum67 = Object.prototype.propertyIsEnumerable;
var __defNormalProp67 = (obj, key2, value) => key2 in obj ? __defProp67(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues67 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp67.call(b2, prop))
      __defNormalProp67(a2, prop, b2[prop]);
  if (__getOwnPropSymbols67)
    for (var prop of __getOwnPropSymbols67(b2)) {
      if (__propIsEnum67.call(b2, prop))
        __defNormalProp67(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps60 = (a2, b2) => __defProps60(a2, __getOwnPropDescs60(b2));
var COMPONENT_NAME2 = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var _sfc_main85 = defineComponent({
  name: COMPONENT_NAME2,
  props: __spreadProps60(__spreadValues67({}, VaTimelineSeparatorProps), {
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  }),
  setup(props, { slots }) {
    const children = [
      h(VaTimelineSeparator, __spreadValues67({}, filterComponentProps(props, VaTimelineSeparatorProps).value))
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(h("div", { class: `${COMPONENT_NAME2}__before` }, before()));
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(h("div", { class: `${COMPONENT_NAME2}__after` }, after()));
    }
    return () => h("div", {
      class: [
        { [COMPONENT_NAME2]: true },
        { [`${COMPONENT_NAME2}--vertical`]: props.vertical },
        { [`${COMPONENT_NAME2}--is-first`]: props.isFirst },
        { [`${COMPONENT_NAME2}--is-last`]: props.isLast }
      ]
    }, children);
  }
});

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/VaTimelineItem/index.js
var VaTimelineItem = withConfigTransport(_sfc_main85);

// node_modules/vuestic-ui/dist/esm/src/components/va-timeline/index.js
var VaTimeline = withConfigTransport(_sfc_main83);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeView.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/types/index.js
var TreeViewKey = Symbol("TreeView");
var TreeCategoryKey = Symbol("TreeCategory");
var TreeNodeKey = Symbol("TreeNode");

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeView.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeView.css";
var __defProp68 = Object.defineProperty;
var __getOwnPropSymbols68 = Object.getOwnPropertySymbols;
var __hasOwnProp68 = Object.prototype.hasOwnProperty;
var __propIsEnum68 = Object.prototype.propertyIsEnumerable;
var __defNormalProp68 = (obj, key2, value) => key2 in obj ? __defProp68(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues68 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp68.call(b2, prop))
      __defNormalProp68(a2, prop, b2[prop]);
  if (__getOwnPropSymbols68)
    for (var prop of __getOwnPropSymbols68(b2)) {
      if (__propIsEnum68.call(b2, prop))
        __defNormalProp68(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main86 = defineComponent({
  name: "VaTreeView",
  props: {
    color: {
      type: String,
      default: ""
    }
  },
  setup: (props) => {
    const categories = ref([]);
    const collapse = () => {
      nextTick(() => {
        categories.value.forEach((child) => {
          child.collapse();
        });
      });
    };
    const expand = () => {
      nextTick(() => {
        categories.value.forEach((child) => {
          child.expand();
        });
      });
    };
    const onChildMounted = (category) => {
      categories.value.push(category);
    };
    const onChildUnmounted = (removableCategory) => {
      categories.value = categories.value.filter((category) => category !== removableCategory);
    };
    const treeView = {
      color: props.color,
      onChildMounted,
      onChildUnmounted
    };
    provide(TreeViewKey, treeView);
    return __spreadValues68({
      collapse,
      expand
    }, useColors());
  }
});
var _hoisted_158 = { class: "va-tree-view" };
function _sfc_render82(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_158, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaTreeView = _export_sfc(_sfc_main86, [["render", _sfc_render82]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeNode/VaTreeNode.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeNode/VaTreeNode.css";
var _sfc_main87 = defineComponent({
  name: "VaTreeNode",
  components: { VaIcon: VaIcon2 },
  props: {
    highlighted: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ""
    },
    iconRight: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(props) {
    const { getColor } = useColors();
    const treeCategory = inject(TreeCategoryKey, {
      onChildMounted: (value) => void 0,
      onChildUnmounted: (value) => void 0
    });
    provide(TreeNodeKey, {
      props: computed(() => props)
    });
    onMounted(() => treeCategory && treeCategory.onChildMounted(TreeNodeKey));
    onBeforeUnmount(() => treeCategory && treeCategory.onChildUnmounted(TreeNodeKey));
    return {
      treeCategory,
      getColor
    };
  }
});
var _hoisted_159 = {
  key: 0,
  class: "va-tree-node__checkbox"
};
var _hoisted_228 = {
  key: 1,
  class: "va-tree-node__icon"
};
var _hoisted_315 = { class: "va-tree-node__label" };
var _hoisted_411 = {
  key: 2,
  class: "va-tree-node__icon-right",
  size: 24
};
function _sfc_render83(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tree-node", { "va-tree-node--highlighted": _ctx.$props.highlighted }])
  }, [
    _ctx.$slots.checkbox ? (openBlock(), createElementBlock("div", _hoisted_159, [
      renderSlot(_ctx.$slots, "checkbox")
    ])) : createCommentVNode("", true),
    _ctx.$props.icon ? (openBlock(), createElementBlock("div", _hoisted_228, [
      createVNode(_component_va_icon, {
        name: _ctx.$props.icon,
        color: _ctx.getColor("info"),
        size: 24
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_315, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.$props.iconRight ? (openBlock(), createElementBlock("div", _hoisted_411, [
      createVNode(_component_va_icon, {
        name: _ctx.$props.iconRight,
        color: _ctx.getColor("info")
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true)
  ], 2);
}
var _VaTreeNode = _export_sfc(_sfc_main87, [["render", _sfc_render83]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeNode/index.js
var VaTreeNode = withConfigTransport(_VaTreeNode);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeCategory/VaTreeCategory.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/SquareWithIcon/SquareWithIcon.js
init_vue_runtime_esm_bundler();
var _sfc_main88 = defineComponent({
  name: "SquareWithIcon",
  components: { VaIcon: VaIcon2 },
  props: {
    icon: {
      type: String,
      default: "",
      required: true
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return {
      colorComputed
    };
  }
});
function _sfc_render84(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: "square-with-icon",
    style: normalizeStyle({ backgroundColor: _ctx.colorComputed })
  }, [
    createVNode(_component_va_icon, {
      name: _ctx.$props.icon
    }, null, 8, ["name"])
  ], 4);
}
var SquareWithIcon = _export_sfc(_sfc_main88, [["render", _sfc_render84]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeCategory/VaTreeCategory.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeCategory/VaTreeCategory.css";
var _sfc_main89 = defineComponent({
  name: "VaTreeCategory",
  components: {
    SquareWithIcon,
    VaIcon
  },
  props: {
    label: {
      type: [String, Number],
      default: ""
    },
    isOpen: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup: (props) => {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const nodes = ref([]);
    const isOpenCached = ref(false);
    const onChildMounted = (node) => {
      nodes.value.push(node);
    };
    const onChildUnmounted = (removableNode) => {
      nodes.value = nodes.value.filter((node) => node !== removableNode);
    };
    const treeView = inject(TreeViewKey, {
      onChildMounted: (value) => void 0,
      onChildUnmounted: (value) => void 0
    });
    const collapse = () => {
      isOpenCached.value = false;
      nextTick(() => {
        nodes.value.forEach((child) => {
          if (child.$options.name === "va-tree-category") {
            child.collapse();
          }
        });
      });
    };
    const expand = () => {
      isOpenCached.value = true;
      nextTick(() => {
        nodes.value.forEach((child) => {
          var _a;
          (_a = child.expand) == null ? void 0 : _a.call(child);
        });
      });
    };
    const toggle = (e2) => {
      if (!e2.target.classList.contains("va-checkbox__input")) {
        isOpenCached.value = !isOpenCached.value;
      }
    };
    watch(() => props.isOpen, (isOpen) => {
      isOpenCached.value = isOpen;
    }, { immediate: true });
    const treeCategory = {
      treeView,
      nodes: nodes.value,
      isOpenCached: isOpenCached.value,
      onChildMounted,
      onChildUnmounted,
      collapse,
      expand,
      toggle
    };
    provide(TreeCategoryKey, treeCategory);
    onMounted(() => treeView == null ? void 0 : treeView.onChildMounted(treeCategory));
    onBeforeUnmount(() => treeView == null ? void 0 : treeView.onChildUnmounted(treeCategory));
    return {
      treeCategory,
      treeView,
      nodes,
      isOpenCached,
      collapse,
      expand,
      toggle,
      getColor,
      colorComputed
    };
  }
});
var _hoisted_160 = { class: "va-tree-category" };
var _hoisted_229 = { class: "va-tree-category__header-switcher" };
var _hoisted_316 = {
  key: 0,
  class: "va-tree-category__header-checkbox"
};
var _hoisted_412 = {
  key: 1,
  class: "va-tree-category__header-icon"
};
var _hoisted_59 = { class: "va-tree-category__header-label" };
var _hoisted_67 = {
  key: 0,
  class: "va-tree-category__list-container"
};
var _hoisted_75 = { class: "va-tree-category__list-internal-container" };
function _sfc_render85(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_square_with_icon = resolveComponent("square-with-icon");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", _hoisted_160, [
    createBaseVNode("div", {
      class: "va-tree-category__header",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args))
    }, [
      createBaseVNode("div", _hoisted_229, [
        createVNode(_component_square_with_icon, {
          icon: _ctx.isOpenCached ? "remove" : "add",
          color: _ctx.colorComputed
        }, null, 8, ["icon", "color"])
      ]),
      _ctx.$slots.checkbox ? (openBlock(), createElementBlock("div", _hoisted_316, [
        renderSlot(_ctx.$slots, "checkbox")
      ])) : createCommentVNode("", true),
      _ctx.$props.icon ? (openBlock(), createElementBlock("div", _hoisted_412, [
        createVNode(_component_va_icon, {
          name: _ctx.$props.icon,
          color: _ctx.getColor("info")
        }, null, 8, ["name", "color"])
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_59, toDisplayString(_ctx.$props.label), 1)
    ]),
    _ctx.isOpenCached ? (openBlock(), createElementBlock("div", _hoisted_67, [
      createBaseVNode("div", _hoisted_75, [
        renderSlot(_ctx.$slots, "default")
      ])
    ])) : createCommentVNode("", true)
  ]);
}
var _VaTreeCategory = _export_sfc(_sfc_main89, [["render", _sfc_render85]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/VaTreeCategory/index.js
var VaTreeCategory = withConfigTransport(_VaTreeCategory);

// node_modules/vuestic-ui/dist/esm/src/components/va-tree-view/index.js
var VaTreeView = withConfigTransport(_VaTreeView);

// node_modules/vuestic-ui/dist/esm/src/components/va-popover/VaPopover.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-popover/VaPopover.css";
var __defProp69 = Object.defineProperty;
var __defProps61 = Object.defineProperties;
var __getOwnPropDescs61 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols69 = Object.getOwnPropertySymbols;
var __hasOwnProp69 = Object.prototype.hasOwnProperty;
var __propIsEnum69 = Object.prototype.propertyIsEnumerable;
var __defNormalProp69 = (obj, key2, value) => key2 in obj ? __defProp69(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues69 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp69.call(b2, prop))
      __defNormalProp69(a2, prop, b2[prop]);
  if (__getOwnPropSymbols69)
    for (var prop of __getOwnPropSymbols69(b2)) {
      if (__propIsEnum69.call(b2, prop))
        __defNormalProp69(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps61 = (a2, b2) => __defProps61(a2, __getOwnPropDescs61(b2));
var VaDropdownProps = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var _sfc_main90 = defineComponent({
  name: "VaPopover",
  components: { VaDropdown, VaIcon: VaIcon2 },
  props: __spreadProps61(__spreadValues69({}, VaDropdownProps), {
    trigger: { default: "hover" },
    color: { type: String, default: "dark" },
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 }
  }),
  setup(props, { slots }) {
    const VaDropdownPropValues = filterComponentProps(props, VaDropdownProps);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const showIconComputed = computed(() => props.icon || slots.icon);
    const showTitleComputed = computed(() => props.title || slots.title);
    const showBodyComputed = computed(() => props.message || slots.body);
    const showPopoverContentComputed = computed(() => showTitleComputed.value || showBodyComputed.value);
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return {
      textColorComputed,
      VaDropdownPropValues,
      showBodyComputed,
      showIconComputed,
      showTitleComputed,
      computedPopoverStyle,
      showPopoverContentComputed
    };
  }
});
var _hoisted_161 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_230 = { key: 1 };
var _hoisted_317 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_413 = {
  key: 1,
  class: "va-popover__body"
};
function _sfc_render86(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps(_ctx.VaDropdownPropValues, {
    "model-value": _ctx.modelValue,
    "close-on-click-outside": _ctx.autoHide,
    offset: _ctx.$props.offset,
    class: "va-popover"
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        style: normalizeStyle(_ctx.computedPopoverStyle),
        class: "va-popover__content",
        role: "tooltip"
      }, [
        _ctx.showIconComputed ? (openBlock(), createElementBlock("div", _hoisted_161, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, {
              name: _ctx.$props.icon,
              color: _ctx.textColorComputed
            }, null, 8, ["name", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.showPopoverContentComputed ? (openBlock(), createElementBlock("div", _hoisted_230, [
          _ctx.showTitleComputed ? (openBlock(), createElementBlock("div", _hoisted_317, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.title), 1)
            ])
          ])) : createCommentVNode("", true),
          _ctx.showBodyComputed ? (openBlock(), createElementBlock("div", _hoisted_413, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.message), 1)
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 4)
    ]),
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["model-value", "close-on-click-outside", "offset"]);
}
var _VaPopover = _export_sfc(_sfc_main90, [["render", _sfc_render86]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-popover/index.js
var VaPopover = withConfigTransport(_VaPopover);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/composables/useStrictInject.js
init_vue_runtime_esm_bundler();
var useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.css";
var INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
var __default__ = defineComponent({
  name: "VaFileUploadUndo",
  components: {
    VaProgressBar,
    VaButton: VaButton2
  },
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup: (props) => {
    const progress = ref(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props.vertical
    }));
    const undoDurationStyle = computed(() => {
      var _a;
      return `${(_a = undoDuration.value) != null ? _a : 0}ms`;
    });
    onMounted(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return {
      progress,
      undoDuration,
      undoButtonText,
      computedClasses,
      undoDurationStyle,
      deletedFileMessage
    };
  }
});
var __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "35ceb3fe": _ctx.undoDurationStyle
  }));
};
var __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
var _sfc_main91 = __default__;
var _hoisted_163 = { class: "va-file-upload-undo__text" };
function _sfc_render87(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_bar = resolveComponent("va-progress-bar");
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_va_progress_bar, {
      "model-value": _ctx.progress,
      rounded: false,
      class: "va-file-upload-undo-progress-bar"
    }, null, 8, ["model-value"]),
    createBaseVNode("div", {
      class: normalizeClass(["va-file-upload-undo", _ctx.computedClasses])
    }, [
      createBaseVNode("span", _hoisted_163, toDisplayString(_ctx.deletedFileMessage), 1),
      createVNode(_component_va_button, {
        class: "va-file-upload-undo__button",
        "aria-label": _ctx.undoButtonText,
        size: "small",
        outline: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.undoButtonText), 1)
        ]),
        _: 1
      }, 8, ["aria-label"])
    ], 2)
  ], 64);
}
var _VaFileUploadUndo = _export_sfc(_sfc_main91, [["render", _sfc_render87]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadUndo/index.js
var VaFileUploadUndo = withConfigTransport(_VaFileUploadUndo);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.css";
var INJECTION_ERROR_MESSAGE2 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
var _sfc_main92 = defineComponent({
  name: "VaFileUploadListItem",
  components: {
    VaListItem,
    VaListItemSection,
    VaFileUploadUndo,
    VaButton: VaButton2
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE2);
    const { onFocus, onBlur } = useFocus();
    const removed = ref(false);
    const removeFile = () => {
      var _a;
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, (_a = undoDuration.value) != null ? _a : 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return {
      undo,
      removed,
      disabled,
      computedClasses,
      onBlur,
      onFocus,
      removeFile,
      recoverFile
    };
  }
});
var _hoisted_164 = { class: "va-file-upload-list-item__content" };
var _hoisted_231 = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
var _hoisted_318 = { class: "va-file-upload-list-item__size" };
function _sfc_render88(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-list-item", _ctx.computedClasses]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, { onRecover: _ctx.recoverFile }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_164, [
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", _hoisted_231, toDisplayString(_ctx.file && _ctx.file.name), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_318, toDisplayString(_ctx.file && _ctx.file.size), 1),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "clear",
              class: "va-file-upload-list-item__delete",
              "aria-label": "remove file",
              onClick: withModifiers(_ctx.removeFile, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["space"])
              ],
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["onClick", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled"]);
}
var _VaFileUploadListItem = _export_sfc(_sfc_main92, [["render", _sfc_render88]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadListItem/index.js
var VaFileUploadListItem = withConfigTransport(_VaFileUploadListItem);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.css";
var INJECTION_ERROR_MESSAGE3 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
var _sfc_main93 = defineComponent({
  name: "VaFileUploadGalleryItem",
  components: {
    VaFileUploadUndo,
    VaButton: VaButton2,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE3);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      var _a;
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, (_a = undoDuration.value) != null ? _a : 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e2) => {
          var _a, _b;
          if (((_a = e2.target) == null ? void 0 : _a.result).includes("image")) {
            previewImage.value = (_b = e2.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    return {
      undo,
      removed,
      disabled,
      isFocused,
      previewImage,
      classesComputed,
      overlayStylesComputed,
      onBlur,
      onFocus,
      removeImage,
      recoverImage
    };
  }
});
var _hoisted_165 = ["src", "alt"];
var _hoisted_232 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_319 = ["title"];
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-gallery-item", _ctx.classesComputed]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    onFocus: _ctx.onFocus,
    onBlur: _ctx.onBlur
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, {
            vertical: "",
            onRecover: _ctx.recoverImage
          }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          _ctx.previewImage ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.previewImage,
            alt: _ctx.file.name || "",
            class: "va-file-upload-gallery-item__image"
          }, null, 8, _hoisted_165)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_232, [
            createBaseVNode("div", {
              class: "va-file-upload-gallery-item__overlay-background",
              style: normalizeStyle(_ctx.overlayStylesComputed)
            }, null, 4),
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-file-upload-gallery-item__name",
              title: _ctx.file.name
            }, toDisplayString(_ctx.file.name), 9, _hoisted_319)) : createCommentVNode("", true),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "delete_outline",
              class: "va-file-upload-gallery-item__delete",
              "aria-label": "remove file",
              onClick: _ctx.removeImage,
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["onClick", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
}
var _VaFileUploadGalleryItem = _export_sfc(_sfc_main93, [["render", _sfc_render89]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadGalleryItem/index.js
var VaFileUploadGalleryItem = withConfigTransport(_VaFileUploadGalleryItem);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.js
init_vue_runtime_esm_bundler();
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.css";
var INJECTION_ERROR_MESSAGE4 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
var _sfc_main94 = defineComponent({
  name: "VaFileUploadSingleItem",
  components: {
    VaButton: VaButton2,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null }
  },
  setup: () => ({
    disabled: useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE4).disabled
  })
});
var _hoisted_166 = { class: "va-file-upload-single-item__name" };
var _hoisted_233 = createTextVNode(" Delete ");
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    class: "va-file-upload-single-item",
    tabindex: "-1"
  }, {
    default: withCtx(() => [
      createVNode(_component_va_list_item_section, { class: "va-file-upload-single-item__content" }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_166, toDisplayString(_ctx.file && _ctx.file.name), 1),
          !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
            key: 0,
            class: "va-file-upload-single-item__button",
            "aria-label": "remove file",
            size: "small",
            color: "danger",
            flat: "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
          }, {
            default: withCtx(() => [
              _hoisted_233
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["disabled", "aria-disabled"]);
}
var _VaFileUploadSingleItem = _export_sfc(_sfc_main94, [["render", _sfc_render90]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadSingleItem/index.js
var VaFileUploadSingleItem = withConfigTransport(_VaFileUploadSingleItem);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.css";
var _sfc_main95 = defineComponent({
  name: "VaFileUploadList",
  components: {
    VaList,
    VaFileUploadListItem,
    VaFileUploadGalleryItem,
    VaFileUploadSingleItem
  },
  emits: ["remove", "removeSingle"],
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    color: { type: String, default: "success" }
  },
  setup(props) {
    const filesList = computed(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k2 = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i2 = Math.floor(Math.log(bytes) / Math.log(k2));
      return parseFloat((bytes / Math.pow(k2, i2)).toFixed(2)) + " " + sizes[i2];
    };
    const formatDate = (date = new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    return {
      filesList
    };
  }
});
function _sfc_render91(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_list_item = resolveComponent("va-file-upload-list-item");
  const _component_va_file_upload_gallery_item = resolveComponent("va-file-upload-gallery-item");
  const _component_va_file_upload_single_item = resolveComponent("va-file-upload-single-item");
  const _component_va_list = resolveComponent("va-list");
  return openBlock(), createBlock(_component_va_list, {
    class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${_ctx.type}`]),
    role: _ctx.type !== "single" ? "list" : void 0
  }, {
    default: withCtx(() => [
      _ctx.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_list_item, {
          key: file.name,
          file,
          color: _ctx.color,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }, null, 8, ["file", "color", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_gallery_item, {
          key: file.name,
          file,
          color: _ctx.color,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }, null, 8, ["file", "color", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "single" && _ctx.filesList.length ? (openBlock(), createBlock(_component_va_file_upload_single_item, {
        key: 2,
        file: _ctx.filesList[_ctx.filesList.length - 1],
        onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
      }, null, 8, ["file"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["role", "class"]);
}
var _VaFileUploadList = _export_sfc(_sfc_main95, [["render", _sfc_render91]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUploadList/index.js
var VaFileUploadList = withConfigTransport(_VaFileUploadList);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUpload.js
import "F:/DeepLearningNLP/Graduation-Design/node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/VaFileUpload.css";
var _sfc_main96 = defineComponent({
  name: "VaFileUpload",
  components: {
    VaModal,
    VaButton: VaButton2,
    VaFileUploadList
  },
  props: {
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    undoButtonText: { type: String, default: "Undo" },
    dropZoneText: { type: String, default: "Drag\u2019n\u2019drop files or" },
    uploadButtonText: { type: String, default: "Upload file" },
    deletedFileMessage: { type: String, default: "File was successfully deleted" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(props, { emit }) {
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const validateFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t2) => props.fileTypes.includes(t2));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e2) => {
      var _a, _b;
      const f2 = ((_a = e2.target) == null ? void 0 : _a.files) || ((_b = e2.dataTransfer) == null ? void 0 : _b.files);
      if (!f2) {
        return;
      }
      const validatedFiles = props.fileTypes ? validateFiles(Array.from(f2)) : f2;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e2) => {
      uploadFile(e2);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        files.value = validateFiles(files.value);
      }
    });
    provide(VaFileUploadKey, {
      undo: toRef(props, "undo"),
      disabled: toRef(props, "disabled"),
      undoDuration: toRef(props, "undoDuration"),
      undoButtonText: toRef(props, "undoButtonText"),
      deletedFileMessage: toRef(props, "deletedFileMessage")
    });
    return {
      modal,
      dropzoneHighlight,
      fileInputRef,
      colorComputed,
      computedStyle,
      computedClasses,
      files,
      uploadFile,
      changeFieldValue,
      removeFile,
      removeSingleFile,
      callFileDialogue
    };
  }
});
var _hoisted_167 = { class: "va-file-upload__field" };
var _hoisted_234 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_320 = ["accept", "multiple", "disabled"];
function _sfc_render92(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_file_upload_list = resolveComponent("va-file-upload-list");
  const _component_va_modal = resolveComponent("va-modal");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-file-upload", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode("div", _hoisted_167, [
        _ctx.dropzone ? (openBlock(), createElementBlock("div", _hoisted_234, toDisplayString(_ctx.dropZoneText), 1)) : createCommentVNode("", true),
        createVNode(_component_va_button, {
          class: "va-file-upload__field__button",
          disabled: _ctx.disabled,
          "aria-disabled": _ctx.disabled,
          color: _ctx.colorComputed,
          style: normalizeStyle({ "pointer-events": _ctx.dropzoneHighlight ? "none" : "" }),
          onChange: _ctx.changeFieldValue,
          onClick: _ctx.callFileDialogue
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.uploadButtonText), 1)
          ]),
          _: 1
        }, 8, ["disabled", "aria-disabled", "color", "style", "onChange", "onClick"])
      ])
    ]),
    createBaseVNode("input", {
      ref: "fileInputRef",
      type: "file",
      class: "va-file-upload__field__input",
      tabindex: -1,
      "aria-hidden": "true",
      accept: _ctx.fileTypes,
      multiple: _ctx.type !== "single",
      disabled: _ctx.disabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.changeFieldValue && _ctx.changeFieldValue(...args)),
      onDragenter: _cache[1] || (_cache[1] = ($event) => _ctx.dropzoneHighlight = true),
      onDragleave: _cache[2] || (_cache[2] = ($event) => _ctx.dropzoneHighlight = false)
    }, null, 40, _hoisted_320),
    _ctx.files.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(_component_va_file_upload_list, {
      key: 0,
      type: _ctx.type,
      files: _ctx.files,
      color: _ctx.colorComputed,
      onRemove: _ctx.removeFile,
      onRemoveSingle: _ctx.removeSingleFile
    }, null, 8, ["type", "files", "color", "onRemove", "onRemoveSingle"])) : createCommentVNode("", true),
    createVNode(_component_va_modal, {
      modelValue: _ctx.modal,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.modal = $event),
      "hide-default-actions": "",
      title: "File validation",
      message: "File type is incorrect!"
    }, null, 8, ["modelValue"])
  ], 6);
}
var _VaFileUpload = _export_sfc(_sfc_main96, [["render", _sfc_render92]]);

// node_modules/vuestic-ui/dist/esm/src/components/va-file-upload/index.js
var VaFileUpload = withConfigTransport(_VaFileUpload);

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/vuestic-components.js
init_vue_runtime_esm_bundler();
var vuesticComponentMap = Object.freeze(Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAvatar,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton: VaButton2,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFileUpload,
  VaForm,
  VaHover,
  VaIcon: VaIcon2,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaSelect,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  VaSpacer,
  VaSwitch,
  VaTabs,
  VaTab,
  VaTimeInput,
  VaTimeline,
  VaTimelineItem,
  VaTimePicker,
  VaTreeCategory,
  VaTreeNode,
  VaTreeRoot: VaTreeView,
  VaTreeView
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/create-vuestic/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config } = options;
    Object.entries(vuesticComponentMap).forEach(([name, component]) => {
      app.component(name, component);
    });
    usePlugin(app, GlobalConfigPlugin(config));
    usePlugin(app, ColorConfigPlugin);
    usePlugin(app, VaDropdownPlugin);
    usePlugin(app, VaToastPlugin);
    usePlugin(app, VaModalPlugin);
  }
}));

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/create-vuestic/create-vuestic-essential.js
init_vue_runtime_esm_bundler();
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config, components, plugins } = options;
    usePlugin(app, (plugins == null ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app, (plugins == null ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app.component(name, component);
      });
    }
  }
}));

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/old/vuestic-plugin.js
var VuesticPlugin = {
  install(app, vuesticConfig) {
    app.use(GlobalConfigPlugin(vuesticConfig));
    app.use(ColorConfigPlugin());
    Object.entries(vuesticComponentMap).forEach(([name, component]) => {
      app.component(name, component);
    });
    app.use(VaDropdownPlugin());
    app.use(VaToastPlugin());
    app.use(VaModalPlugin());
  }
};

// node_modules/vuestic-ui/dist/esm/src/vuestic-plugin/old/vuestic-plugin-without-components.js
var VuesticPluginsWithoutComponents = {
  install(app, vuesticConfig) {
    app.use(VaDropdownPlugin());
    app.use(VaToastPlugin());
    app.use(VaModalPlugin);
    app.use(GlobalConfigPlugin(vuesticConfig));
    app.use(ColorConfigPlugin());
  }
};

// node_modules/vuestic-ui/dist/esm/main.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/esm/src/components/va-modal/hooks/useModal.js
init_vue_runtime_esm_bundler();
var useModal = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  return { init };
};

// node_modules/vuestic-ui/dist/esm/src/components/va-toast/hooks/useToast.js
init_vue_runtime_esm_bundler();
var useToast = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext;
  const createdInThisSetupContext = [];
  const init = (options) => {
    const id = createToastInstance(options, appContext);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};
export {
  ColorConfigPlugin,
  GlobalConfigPlugin,
  TabKey,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAvatar,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton2 as VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadKey,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaHover,
  VaIcon2 as VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaSelect,
  VaSelectOptionList,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  VaSpacer,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeCategory,
  VaTreeNode,
  VaTreeView,
  VuesticIconAliases,
  VuesticIconFonts,
  VuesticPlugin,
  VuesticPluginsWithoutComponents,
  createIconsConfig,
  createVuestic,
  createVuesticEssential,
  useColors,
  useGlobalConfig,
  useIcons,
  useModal,
  useToast
};
//# sourceMappingURL=vuestic-ui.js.map
