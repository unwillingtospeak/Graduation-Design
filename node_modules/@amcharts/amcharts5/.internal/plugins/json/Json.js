import { __awaiter, __generator, __read } from "tslib";
import { Entity } from "../../core/util/Entity";
import { Container } from "../../core/render/Container";
import { Color } from "../../core/util/Color";
import { Template } from "../../core/util/Template";
import * as $type from "../../core/util/Type";
import * as $array from "../../core/util/Array";
import * as $object from "../../core/util/Object";
import classes from "./Classes";
function isObject(value) {
    return $type.isObject(value);
}
function getClass(name) {
    return __awaiter(this, void 0, void 0, function () {
        var promise;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    promise = classes[name];
                    return [4 /*yield*/, promise()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function parseArray(root, value, refs) {
    return Promise.all($array.map(value, function (value) { return parseType(root, value, refs); }));
}
function lookupRef(refs, name) {
    var i = refs.length;
    while (i--) {
        var sub = refs[i];
        if (name in sub) {
            return sub[name];
        }
    }
    throw new Error("Could not find ref #" + name);
}
function parseSettings(root, object, refs) {
    return __awaiter(this, void 0, void 0, function () {
        var settings;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    settings = {};
                    return [4 /*yield*/, Promise.all($array.map($object.keys(object), function (key) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, _b;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _a = settings;
                                        _b = key;
                                        return [4 /*yield*/, parseType(root, object[key], refs)];
                                    case 1:
                                        _a[_b] = _c.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _a.sent();
                    return [2 /*return*/, settings];
            }
        });
    });
}
function parseProperties(root, object, refs) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.all($array.map($object.keys(object), function (key) { return __awaiter(_this, void 0, void 0, function () {
                        var parsed;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, parseValue(root, object[key], refs)];
                                case 1:
                                    parsed = _a.sent();
                                    return [2 /*return*/, function (entity) {
                                            var old = entity[key];
                                            if (old && old instanceof Entity) {
                                                // TODO merge it if the value is an Entity
                                                if (parsed.isValue) {
                                                    throw new Error("Cannot merge value into Entity");
                                                }
                                                if (parsed.settings) {
                                                    old.setAll(parsed.settings);
                                                }
                                                mergeEntity(old, parsed);
                                            }
                                            else if (parsed.isValue) {
                                                // Merge Array into List
                                                if (old && $type.isArray(parsed.value)) {
                                                    $array.each(parsed.value, function (value) {
                                                        old.push(value);
                                                    });
                                                }
                                                else {
                                                    // TODO merge it if the value is an Entity
                                                    entity[key] = parsed.value;
                                                }
                                            }
                                            else {
                                                entity[key] = constructEntity(root, parsed);
                                            }
                                        }];
                            }
                        });
                    }); }))];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function parseRefs(root, object, refs) {
    return __awaiter(this, void 0, void 0, function () {
        var newRefs;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    newRefs = {};
                    return [4 /*yield*/, Promise.all($array.map($object.keys(object), function (key) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, _b;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _a = newRefs;
                                        _b = key;
                                        return [4 /*yield*/, parseType(root, object[key], refs)];
                                    case 1:
                                        _a[_b] = _c.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _a.sent();
                    return [2 /*return*/, newRefs];
            }
        });
    });
}
function parseValue(root, value, refs) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, settings, _c, _d, _e, _f, construct, settings, properties, children, ref;
        var _g;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    if (!$type.isArray(value)) return [3 /*break*/, 2];
                    _g = {
                        isValue: true
                    };
                    return [4 /*yield*/, parseArray(root, value, refs)];
                case 1: return [2 /*return*/, (_g.value = _h.sent(),
                        _g)];
                case 2:
                    if (!isObject(value)) return [3 /*break*/, 14];
                    if (!(value.type === "Color")) return [3 /*break*/, 3];
                    return [2 /*return*/, {
                            isValue: true,
                            value: Color.fromAny(value.value),
                        }];
                case 3:
                    if (!(value.type === "Template")) return [3 /*break*/, 9];
                    if (!value.refs) return [3 /*break*/, 5];
                    _b = (_a = refs).concat;
                    return [4 /*yield*/, parseRefs(root, value.refs, refs)];
                case 4:
                    refs = _b.apply(_a, [[_h.sent()]]);
                    _h.label = 5;
                case 5:
                    if (!value.settings) return [3 /*break*/, 7];
                    return [4 /*yield*/, parseSettings(root, value.settings, refs)];
                case 6:
                    _c = _h.sent();
                    return [3 /*break*/, 8];
                case 7:
                    _c = {};
                    _h.label = 8;
                case 8:
                    settings = (_c);
                    return [2 /*return*/, {
                            isValue: true,
                            value: Template.new(settings),
                        }];
                case 9:
                    if (!value.refs) return [3 /*break*/, 11];
                    _e = (_d = refs).concat;
                    return [4 /*yield*/, parseRefs(root, value.refs, refs)];
                case 10:
                    refs = _e.apply(_d, [[_h.sent()]]);
                    _h.label = 11;
                case 11: return [4 /*yield*/, Promise.all([
                        (value.type ? getClass(value.type) : Promise.resolve(undefined)),
                        (value.settings ? parseSettings(root, value.settings, refs) : Promise.resolve(undefined)),
                        (value.properties ? parseProperties(root, value.properties, refs) : Promise.resolve(undefined)),
                        (value.children ? parseArray(root, value.children, refs) : Promise.resolve(undefined)),
                    ])];
                case 12:
                    _f = __read.apply(void 0, [_h.sent(), 4]), construct = _f[0], settings = _f[1], properties = _f[2], children = _f[3];
                    return [2 /*return*/, {
                            isValue: false,
                            type: value.type,
                            construct: construct,
                            settings: settings,
                            adapters: value.adapters,
                            children: children,
                            properties: properties,
                            value: value,
                        }];
                case 13: return [3 /*break*/, 15];
                case 14:
                    if ($type.isString(value)) {
                        if (value[0] === "#") {
                            ref = value.slice(1);
                            if (value[1] === "#") {
                                return [2 /*return*/, {
                                        isValue: true,
                                        value: ref,
                                    }];
                            }
                            else {
                                return [2 /*return*/, {
                                        isValue: true,
                                        value: lookupRef(refs, ref),
                                    }];
                            }
                        }
                        else {
                            return [2 /*return*/, {
                                    isValue: true,
                                    value: value,
                                }];
                        }
                    }
                    else {
                        return [2 /*return*/, {
                                isValue: true,
                                value: value,
                            }];
                    }
                    _h.label = 15;
                case 15: return [2 /*return*/];
            }
        });
    });
}
function mergeEntity(entity, parsed) {
    if (parsed.adapters) {
        $array.each(parsed.adapters, function (adapter) {
            entity.adapters.add(adapter.key, adapter.callback);
        });
    }
    if (parsed.properties) {
        $array.each(parsed.properties, function (fn) {
            fn(entity);
        });
    }
    if (entity instanceof Container) {
        if (parsed.children) {
            entity.children.setAll(parsed.children);
        }
    }
}
function constructEntity(root, parsed) {
    if (!parsed.construct) {
        return parsed.value;
    }
    var entity = parsed.construct.new(root, parsed.settings || {});
    mergeEntity(entity, parsed);
    return entity;
}
function parseType(root, value, refs) {
    return __awaiter(this, void 0, void 0, function () {
        var parsed;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, parseValue(root, value, refs)];
                case 1:
                    parsed = _a.sent();
                    if (parsed.isValue) {
                        return [2 /*return*/, parsed.value];
                    }
                    else {
                        return [2 /*return*/, constructEntity(root, parsed)];
                    }
                    return [2 /*return*/];
            }
        });
    });
}
var JsonParser = /** @class */ (function () {
    function JsonParser() {
    }
    Object.defineProperty(JsonParser.prototype, "parse", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root, object) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, parseType(root, object, [])];
                });
            });
        }
    });
    Object.defineProperty(JsonParser.prototype, "parseString", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root, string) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.parse(root, JSON.parse(string))];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        }
    });
    return JsonParser;
}());
export { JsonParser };
//# sourceMappingURL=Json.js.map