{"version":3,"file":"Json.js","sourceRoot":"","sources":["../../../../../src/.internal/plugins/json/Json.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Root } from \"../../core/Root\";\nimport type { Sprite } from \"../../core/render/Sprite\";\nimport { Entity } from \"../../core/util/Entity\";\nimport { Container } from \"../../core/render/Container\";\nimport { Color } from \"../../core/util/Color\";\nimport { Template } from \"../../core/util/Template\";\n\nimport * as $type from \"../../core/util/Type\";\nimport * as $array from \"../../core/util/Array\";\nimport * as $object from \"../../core/util/Object\";\n\nimport type { IClasses } from \"./Classes\";\nimport classes from \"./Classes\";\n\n\ninterface IRef {\n    [key: string]: any;\n}\n\n\nfunction isObject(value: any): value is { [key: string]: any } {\n    return $type.isObject(value);\n}\n\n\nasync function getClass(name: string): Promise<typeof Entity> {\n    const promise = classes[name as keyof IClasses];\n    return await promise() as typeof Entity;\n}\n\n\nfunction parseArray(root: Root, value: Array<unknown>, refs: Array<IRef>): Promise<any> {\n    return Promise.all($array.map(value, (value) => parseType(root, value, refs)));\n}\n\n\nfunction lookupRef(refs: Array<IRef>, name: string): any {\n    let i = refs.length;\n\n    while (i--) {\n        const sub = refs[i];\n\n        if (name in sub) {\n            return sub[name];\n        }\n    }\n\n    throw new Error(\"Could not find ref #\" + name);\n}\n\n\ninterface IAdapter<E extends Entity> {\n    key: keyof E[\"_settings\"],\n    callback: (value: E[\"_settings\"][this[\"key\"]], target: E, key: this[\"key\"]) => E[\"_settings\"][this[\"key\"]],\n}\n\ntype IParsedProperties = Array<(entity: Entity) => void>;\n\ninterface IParsedEntity<E extends Entity> {\n    isValue: false,\n    type: string | undefined,\n    construct: typeof Entity | undefined,\n    settings: object | undefined,\n    adapters: Array<IAdapter<E>> | undefined,\n    children: Array<Sprite> | undefined,\n    properties: IParsedProperties | undefined,\n    value: object,\n}\n\ntype IParsed<E extends Entity>\n    = IParsedEntity<E>\n    | { isValue: true, value: any };\n\n\nasync function parseSettings<E extends Entity>(root: Root, object: object, refs: Array<IRef>): Promise<E[\"_settings\"]> {\n    const settings: { [key: string]: any } = {};\n\n    await Promise.all($array.map($object.keys(object), async (key) => {\n        settings[key] = await parseType(root, object[key], refs);\n    }));\n\n    return settings;\n}\n\n\nasync function parseProperties(root: Root, object: object, refs: Array<IRef>): Promise<IParsedProperties> {\n    return await Promise.all($array.map($object.keys(object), async (key) => {\n        const parsed = await parseValue(root, object[key], refs);\n\n        return (entity: Entity) => {\n            const old = entity[key] as unknown;\n\n            if (old && old instanceof Entity) {\n                // TODO merge it if the value is an Entity\n                if (parsed.isValue) {\n                    throw new Error(\"Cannot merge value into Entity\");\n                }\n\n                if (parsed.settings) {\n                    old.setAll(parsed.settings);\n                }\n\n                mergeEntity(old, parsed);\n\n            } else if (parsed.isValue) {\n                // Merge Array into List\n                if (old && $type.isArray(parsed.value)) {\n                    $array.each(parsed.value, (value) => {\n                        (old as any).push(value);\n                    });\n\n                } else {\n                    // TODO merge it if the value is an Entity\n                    (entity as any)[key] = parsed.value;\n                }\n\n            } else {\n                (entity as any)[key] = constructEntity(root, parsed);\n            }\n        };\n    }));\n}\n\n\nasync function parseRefs(root: Root, object: { [key: string]: any }, refs: Array<IRef>): Promise<IRef> {\n    const newRefs: IRef = {};\n\n    await Promise.all($array.map($object.keys(object), async (key) => {\n        newRefs[key] = await parseType(root, object[key], refs);\n    }));\n\n    return newRefs;\n}\n\n\nasync function parseValue<E extends Entity>(root: Root, value: any, refs: Array<IRef>): Promise<IParsed<E>> {\n    if ($type.isArray(value)) {\n        return {\n            isValue: true,\n            value: await parseArray(root, value, refs),\n        };\n\n    } else if (isObject(value)) {\n        if (value.type === \"Color\") {\n            return {\n                isValue: true,\n                value: Color.fromAny(value.value),\n            };\n\n        } else if (value.type === \"Template\") {\n            if (value.refs) {\n                refs = refs.concat([await parseRefs(root, value.refs, refs)]);\n            }\n\n            const settings = (value.settings ? await parseSettings(root, value.settings, refs) : {});\n\n            return {\n                isValue: true,\n                value: Template.new(settings),\n            };\n\n        } else {\n            if (value.refs) {\n                refs = refs.concat([await parseRefs(root, value.refs, refs)]);\n            }\n\n            const [construct, settings, properties, children] = await Promise.all([\n                (value.type ? getClass(value.type) : Promise.resolve(undefined)),\n                (value.settings ? parseSettings(root, value.settings, refs) : Promise.resolve(undefined)),\n                (value.properties ? parseProperties(root, value.properties, refs) : Promise.resolve(undefined)),\n                (value.children ? parseArray(root, value.children, refs) : Promise.resolve(undefined)),\n            ]);\n\n            return {\n                isValue: false,\n                type: value.type,\n                construct,\n                settings,\n                adapters: value.adapters,\n                children,\n                properties,\n                value,\n            };\n        }\n\n    } else if ($type.isString(value)) {\n        if (value[0] === \"#\") {\n            const ref = value.slice(1);\n\n            if (value[1] === \"#\") {\n                return {\n                    isValue: true,\n                    value: ref,\n                };\n\n            } else {\n                return {\n                    isValue: true,\n                    value: lookupRef(refs, ref),\n                };\n            }\n\n        } else {\n            return {\n                isValue: true,\n                value,\n            };\n        }\n\n    } else {\n        return {\n            isValue: true,\n            value,\n        };\n    }\n}\n\n\nfunction mergeEntity<E extends Entity>(entity: E, parsed: IParsedEntity<E>): void {\n    if (parsed.adapters) {\n        $array.each(parsed.adapters, (adapter) => {\n            entity.adapters.add(adapter.key, adapter.callback);\n        });\n    }\n\n    if (parsed.properties) {\n        $array.each(parsed.properties, (fn) => {\n            fn(entity);\n        });\n    }\n\n    if (entity instanceof Container) {\n        if (parsed.children) {\n            entity.children.setAll(parsed.children);\n        }\n    }\n}\n\n\nfunction constructEntity<E extends Entity>(root: Root, parsed: IParsedEntity<E>): E | object {\n    if (!parsed.construct) {\n        return parsed.value;\n    }\n\n    const entity = parsed.construct.new(root, parsed.settings || {}) as E;\n\n    mergeEntity(entity, parsed);\n\n    return entity;\n}\n\n\nasync function parseType(root: Root, value: unknown, refs: Array<IRef>): Promise<any> {\n    const parsed = await parseValue(root, value, refs);\n\n    if (parsed.isValue) {\n        return parsed.value;\n\n    } else {\n        return constructEntity(root, parsed);\n    }\n}\n\n\nexport class JsonParser {\n    async parse<E extends Entity>(root: Root, object: unknown): Promise<E> {\n        return parseType(root, object, []);\n    }\n\n    async parseString<E extends Entity>(root: Root, string: string): Promise<E> {\n        return await this.parse(root, JSON.parse(string));\n    }\n}\n"]}