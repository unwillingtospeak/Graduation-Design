var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { computed, unref, watchPostEffect } from "vue";
import { m as mapObject } from "../utils/map-object.js";
import { u as useDomRect } from "./useDomRect.js";
import { u as useClientOnly } from "./useClientOnly.js";
const placementsPositions = ["top", "bottom", "left", "right"].reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ["auto"]);
const coordsToCss = ({ x, y }) => ({ left: `${x}px`, top: `${y}px` });
const parsePlacement = (placement) => {
  let [position, align] = placement.split("-");
  if (position === "auto") {
    position = "bottom";
  }
  return { position, align: align || "center" };
};
const parseOffset = (offset) => {
  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
const calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
  if (align === "start") {
    return anchorStart;
  }
  if (align === "end") {
    return anchorStart + anchorSize - contentSize;
  }
  return anchorStart + (anchorSize - contentSize) / 2;
};
const calculateContentCoords = (placement, anchor, content) => {
  const { position, align } = parsePlacement(placement);
  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
  switch (position) {
    case "top":
      return { x: alignmentX, y: anchor.top - content.height };
    case "left":
      return { y: alignmentY, x: anchor.left - content.width };
    case "right":
      return { y: alignmentY, x: anchor.right };
    case "bottom":
    default:
      return { x: alignmentX, y: anchor.bottom };
  }
};
const calculateOffsetCoords = (placement, offset) => {
  const { position } = parsePlacement(placement);
  const { main, cross } = parseOffset(offset);
  switch (position) {
    case "left":
      return { y: cross, x: -main };
    case "right":
      return { y: cross, x: main };
    case "top":
      return { y: -main, x: cross };
    case "bottom":
    default:
      return { y: main, x: cross };
  }
};
const calculateContentOverflow = (coords, content, viewport) => {
  const xMax = viewport.right;
  const yMax = viewport.bottom;
  const xMin = viewport.left;
  const yMin = viewport.top;
  return {
    top: Math.max(yMin - coords.y, 0),
    bottom: Math.max(coords.y + content.height - yMax, 0),
    left: Math.max(xMin - coords.x, 0),
    right: Math.max(coords.x + content.width - xMax, 0)
  };
};
const clamp = (min, v, max) => Math.max(Math.min(v, max), min);
const calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {
  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport);
  const x = coords.x - right + left;
  const y = coords.y - bottom + top;
  const { x: offsetX, y: offsetY } = offsetCoords;
  return {
    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),
    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY)
  };
};
const getAutoPlacement = (placement, coords, content, viewport) => {
  const { position, align } = parsePlacement(placement);
  const overflow = calculateContentOverflow(coords, content, viewport);
  const newPlacements = {
    top: ["bottom", align].join("-"),
    bottom: ["top", align].join("-"),
    right: ["left", align].join("-"),
    left: ["right", align].join("-")
  };
  return overflow[position] ? newPlacements[position] : placement;
};
const findFirstRelativeParent = (el) => {
  while (el) {
    if (window.getComputedStyle(el).position === "relative") {
      return el;
    }
    el = el.parentElement;
  }
  return document.body;
};
const useDropdown = (anchorRef, contentRef, options) => {
  const documentRef = useClientOnly(() => document);
  const rootRef = computed(() => {
    if (!documentRef.value) {
      return void 0;
    }
    const { root } = unref(options);
    if (root) {
      let el;
      if (typeof root === "string") {
        el = documentRef.value.querySelector(root);
      } else {
        el = root;
      }
      if (!el) {
        return documentRef.value.body;
      }
      return findFirstRelativeParent(el);
    }
    return documentRef.value.body;
  });
  const { domRect: anchorDomRect } = useDomRect(anchorRef);
  const { domRect: contentDomRect } = useDomRect(contentRef);
  const css = {
    width: "max-content",
    position: "absolute"
  };
  watchPostEffect(() => {
    var _a, _b;
    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
      return;
    }
    const { placement, offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options);
    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);
    let offsetCoords = { x: 0, y: 0 };
    if (offset) {
      offsetCoords = calculateOffsetCoords(placement, offset);
      coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
    }
    const rootRect = rootRef.value.getBoundingClientRect();
    const viewportRect = (_b = (_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) != null ? _b : rootRect;
    if (autoPlacement) {
      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect);
      if (newPlacement !== placement) {
        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);
        if (offset) {
          offsetCoords = calculateOffsetCoords(newPlacement, offset);
          coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
        }
      }
    }
    if (stickToEdges) {
      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);
    }
    coords.x -= rootRect.x;
    coords.y -= rootRect.y;
    if (contentRef.value) {
      let widthCss = {};
      if (keepAnchorWidth) {
        const { width } = anchorDomRect.value;
        widthCss = { width: `${width}px`, maxWidth: `${width}px` };
      }
      Object.assign(contentRef.value.style, __spreadValues(__spreadValues(__spreadValues({}, css), coordsToCss(coords)), widthCss));
    }
  });
  return {
    anchorDomRect,
    contentDomRect
  };
};
export { placementsPositions as p, useDropdown as u };
//# sourceMappingURL=useDropdown.js.map
