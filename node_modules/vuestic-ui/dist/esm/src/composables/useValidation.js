import { watch, inject, computed, onMounted, onBeforeUnmount } from "vue";
import { f as flatten_1, e as isFunction_1, g as isString_1 } from "../../vendor.js";
import { u as useSyncProp } from "./useSyncProp.js";
import { a as useFocus } from "./useFocus.js";
import { F as FormServiceKey } from "../components/va-form/consts.js";
const normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString_1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction_1(rule) ? rule(callArguments) : rule);
};
const useValidationProps = {
  modelValue: { required: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
const useValidationEmits = ["update:error", "update:errorMessages"];
const useValidation = (props, emit, reset, focus) => {
  const { isFocused, onFocus, onBlur } = useFocus();
  const [computedError] = useSyncProp("error", props, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props, emit, []);
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
  };
  const validate = () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    let error = false;
    let errorMessages = [];
    const rules = flatten_1(props.rules);
    normalizeValidationRules(rules, props.modelValue).forEach((validationResult) => {
      if (isString_1(validationResult)) {
        errorMessages = [...errorMessages, validationResult];
        error = true;
      } else if (validationResult === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  watch(isFocused, (newVal) => !newVal && validate());
  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation });
  const context = {
    resetValidation,
    focus,
    validate,
    reset,
    hasError: () => computedError.value
  };
  const form = inject(FormServiceKey, void 0);
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": !!computedErrorMessages.value.length,
    "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
  }));
  onMounted(() => {
    form == null ? void 0 : form.onChildMounted(context);
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.onChildUnmounted(context);
  });
  return {
    computedError,
    computedErrorMessages,
    listeners: { onFocus, onBlur },
    validate,
    resetValidation,
    validationAriaAttributes
  };
};
export { useValidationEmits as a, useValidation as b, useValidationProps as u };
//# sourceMappingURL=useValidation.js.map
