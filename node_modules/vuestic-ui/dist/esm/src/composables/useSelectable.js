var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { computed } from "vue";
import { a as useStatefulProps, b as useStateful } from "./useStateful.js";
import { u as useLoadingProps } from "./useLoading.js";
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from "./useValidation.js";
import { a as useFocus } from "./useFocus.js";
const useSelectableProps = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, useStatefulProps), useLoadingProps), useValidationProps), {
  arrayValue: { type: null, default: null },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
});
const useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
const checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
const useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => emit("update:modelValue", false);
  const focus = () => {
    var _a;
    return (_a = input.value) == null ? void 0 : _a.focus();
  };
  const { computedError, computedErrorMessages, validate, validationAriaAttributes } = useValidation(props, emit, reset, focus);
  const { valueComputed } = useStateful(props, emit);
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [label.value, container.value].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      computedError.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a;
    if (modelIsArray.value) {
      return (_a = props.modelValue) == null ? void 0 : _a.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};
export { useSelectableProps as a, useSelectable as b, useSelectableEmits as u };
//# sourceMappingURL=useSelectable.js.map
