{"version":3,"file":"createProxyComponent.js","sources":["../../../../../src/services/config-transport/createProxyComponent.ts"],"sourcesContent":["import { getCurrentInstance, ComponentInternalInstance, DefineComponent, SetupContext, Ref, shallowReadonly } from 'vue'\nimport { useComponentConfigProps } from '../component-config/component-config'\n\n/** Compiled and reactive props. By default they passed to setup fn */\ntype Props = Record<string, unknown>;\n/** Raw props */\ntype RawProps = Record<string, unknown>;\n\n/**\n * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.\n * @returns new props object, where some props replaced with props from config.\n */\nconst createPropsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  /**\n   * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.\n   * It is a default props that passed to setup function.\n   */\n  const instanceProps: Props = instance.props\n\n  return new Proxy(instanceProps, {\n    get: (target, key: string) => {\n      /**\n       * Props passed to VNode. Not compiled at all and not reactive.\n       * VNode props contained only props passed from parent.\n       */\n      const incommingProps: RawProps = instance.vnode.props || {}\n\n      /**\n       * Make sure to access both original and from config prop in get.\n       * Since instanceProps and propsFromConfig both are reactive, we need to know that both of\n       * this objects are dependency of effect where proxy is used.\n       * If original prop will not be accessed vue will not track reactivity for original props object.\n       */\n      const originalProp = target[key]\n      const propFromConfig = propsFromConfig.value[key]\n\n      // Return prop from config only if user didn't pass props manually\n      if (incommingProps[key] === undefined && propFromConfig !== undefined) {\n        return propFromConfig\n      }\n\n      return originalProp\n    },\n  })\n}\n\n/**\n * Patch instance props with Proxy.\n * This will change props object during render and in Devtools.\n */\nconst patchInstanceProps = (instance: ComponentInternalInstance, props: Props) => {\n  instance.props = props\n}\n\nexport const createProxyComponent = <T extends DefineComponent>(component: T) => {\n  const customSetup = (originalProps: Props, ctx: SetupContext) => {\n    const instance = getCurrentInstance()! // Not null during setup call\n    const propsFromConfig = useComponentConfigProps(component)\n\n    const props = createPropsWithCustomConfig(instance, propsFromConfig)\n\n    patchInstanceProps(instance, props)\n\n    return component.setup?.(shallowReadonly(props), ctx)\n  }\n\n  return new Proxy(component, {\n    get (target, key: any) {\n      if (key === 'setup') { return customSetup }\n\n      return target[key]\n    },\n  })\n}\n"],"names":[],"mappings":";;AAYA,MAAM,8BAA8B,CAAC,UAAqC,oBAAgC;AAKxG,QAAM,gBAAuB,SAAS;AAE/B,SAAA,IAAI,MAAM,eAAe;AAAA,IAC9B,KAAK,CAAC,QAAQ,QAAgB;AAK5B,YAAM,iBAA2B,SAAS,MAAM,SAAS,CAAA;AAQzD,YAAM,eAAe,OAAO;AACtB,YAAA,iBAAiB,gBAAgB,MAAM;AAG7C,UAAI,eAAe,SAAS,UAAa,mBAAmB,QAAW;AAC9D,eAAA;AAAA,MACT;AAEO,aAAA;AAAA,IACT;AAAA,EAAA,CACD;AACH;AAMA,MAAM,qBAAqB,CAAC,UAAqC,UAAiB;AAChF,WAAS,QAAQ;AACnB;AAEa,MAAA,uBAAuB,CAA4B,cAAiB;AACzE,QAAA,cAAc,CAAC,eAAsB,QAAsB;;AAC/D,UAAM,WAAW;AACX,UAAA,kBAAkB,wBAAwB,SAAS;AAEnD,UAAA,QAAQ,4BAA4B,UAAU,eAAe;AAEnE,uBAAmB,UAAU,KAAK;AAElC,WAAO,gBAAU,UAAV,mCAAkB,gBAAgB,KAAK,GAAG;AAAA,EAAG;AAG/C,SAAA,IAAI,MAAM,WAAW;AAAA,IAC1B,IAAK,QAAQ,KAAU;AACrB,UAAI,QAAQ,SAAS;AAAS,eAAA;AAAA,MAAY;AAE1C,aAAO,OAAO;AAAA,IAChB;AAAA,EAAA,CACD;AACH;;"}