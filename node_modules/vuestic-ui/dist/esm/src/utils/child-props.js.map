{"version":3,"file":"child-props.js","sources":["../../../../src/utils/child-props.ts"],"sourcesContent":["import { ComponentOptionsBase, PropType, computed, ExtractPropTypes } from 'vue'\nimport { getComponentProps } from './resolve-component-props'\n\n/**\n * Accepts parent component props and return value only for child component props.\n *\n * Used to proxy child component props from parent.\n */\nexport const filterComponentProps = <\n  ChildProps extends Record<string, unknown>,\n  Props extends Record<string, unknown>,\n  Result extends ExtractPropTypes<ChildProps>\n>(propsValues: Props, childProps: ChildProps) => {\n  return computed(() => {\n    return Object\n      .keys(childProps)\n      .reduce((acc, propName: string) => {\n        (acc as any)[propName] = propsValues[propName]\n        return acc\n      }, {} as Result)\n  })\n}\n\n// Define component\ndeclare type DefineComponentOptions = ComponentOptionsBase<any, any, any, any, any, any, any, any>\n\n// ExtractOptionProp taken from Vue3 source code\ndeclare type ExtractDefineComponentOptionProp<T> = T extends ComponentOptionsBase<infer P, any, any, any, any, any, any, any> ? unknown extends P ? {} : P : {};\n// Remove useless readonly and nullable key here:\n// -readonly removes readonly\n// -? removes undefined from key, so we can be sure that prop exists and should have type.\ndeclare type ExtractDefineComponentPropsType<T> = {\n  -readonly [K in keyof ExtractDefineComponentOptionProp<T>]-?: {\n    type: PropType<ExtractDefineComponentOptionProp<T>[K]>,\n    required: undefined extends ExtractDefineComponentOptionProp<T>[K] ? false : true,\n    default: undefined extends ExtractDefineComponentOptionProp<T>[K] ? undefined : ExtractDefineComponentOptionProp<T>[K],\n  }\n}\n\n// Class component\ndeclare type ClassComponent = { prototype: { $props: unknown }}\n\ndeclare type ExtractClassComponentOptionProp<T extends ClassComponent> = T['prototype']['$props']\n\ndeclare type ExtractClassComponentPropsType<T extends ClassComponent> = {\n  -readonly [K in keyof ExtractClassComponentOptionProp<T>]-?: {\n    type: PropType<ExtractClassComponentOptionProp<T>[K]>,\n    required: undefined extends ExtractClassComponentOptionProp<T>[K] ? false: true,\n  }\n}\n\ndeclare type ExtractComponentProps<T extends ClassComponent | DefineComponentOptions> = T extends DefineComponentOptions ? ExtractDefineComponentPropsType<T> :\n  T extends ClassComponent ? ExtractClassComponentPropsType<T> : never\n\n/**\n * Works only with defineComponent function.\n * @notion Be aware that `withConfigTransport` you will lose prop types\n */\nexport function extractComponentProps<T> (component: T, ignoreProps?: string[]): ExtractComponentProps<T> {\n  const props: any = getComponentProps(component as any)\n\n  if (ignoreProps) {\n    return Object\n      .keys(props)\n      .reduce<Record<string, unknown>>((acc, propName) => {\n        if (ignoreProps.includes(propName)) { return acc }\n\n        if (props[propName] === undefined) { return acc }\n\n        acc[propName] = typeof props[propName] === 'string' ? {} : props[propName]\n\n        return acc\n      }, {}) as ExtractComponentProps<T>\n  }\n\n  return props\n}\n\ndeclare type ExtractEmitsType<T> = T extends ComponentOptionsBase<any, any, any, any, any, any, any, infer E> ? E: []\n\nexport function extractComponentEmits<T> (component: T): ExtractEmitsType<T> {\n  return [...new Set((component as any).emits)] as any\n}\n"],"names":[],"mappings":";;AAQa,MAAA,uBAAuB,CAIlC,aAAoB,eAA2B;AAC/C,SAAO,SAAS,MAAM;AACpB,WAAO,OACJ,KAAK,UAAU,EACf,OAAO,CAAC,KAAK,aAAqB;AAChC,UAAY,YAAY,YAAY;AAC9B,aAAA;AAAA,IACT,GAAG,CAAY,CAAA;AAAA,EAAA,CAClB;AACH;AAqCO,+BAAmC,WAAc,aAAkD;AAClG,QAAA,QAAa,kBAAkB,SAAgB;AAErD,MAAI,aAAa;AACf,WAAO,OACJ,KAAK,KAAK,EACV,OAAgC,CAAC,KAAK,aAAa;AAC9C,UAAA,YAAY,SAAS,QAAQ,GAAG;AAAS,eAAA;AAAA,MAAI;AAE7C,UAAA,MAAM,cAAc,QAAW;AAAS,eAAA;AAAA,MAAI;AAEhD,UAAI,YAAY,OAAO,MAAM,cAAc,WAAW,KAAK,MAAM;AAE1D,aAAA;AAAA,IACT,GAAG,CAAE,CAAA;AAAA,EACT;AAEO,SAAA;AACT;AAIO,+BAAmC,WAAmC;AAC3E,SAAO,CAAC,GAAG,IAAI,IAAK,UAAkB,KAAK,CAAC;AAC9C;;"}