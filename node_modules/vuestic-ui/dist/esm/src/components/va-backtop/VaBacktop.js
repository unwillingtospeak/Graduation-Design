import { defineComponent, ref, computed, onMounted, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeStyle, withKeys, withModifiers, renderSlot, createVNode, createCommentVNode } from "vue";
import { V as VaButton } from "../va-button/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaBacktop_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaBacktop",
  components: { VaButton },
  props: {
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    }
  },
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        return document.querySelector(props.target);
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const visible = computed(() => targetScrollValue.value > props.visibilityHeight);
    onMounted(() => {
      targetElement = getTargetElement();
      targetElement.addEventListener("scroll", handleScroll, true);
    });
    onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    return {
      computedStyle,
      visible,
      scrollToTop
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": "back to top",
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "expand_less",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 36)) : createCommentVNode("", true);
}
var _VaBacktop = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaBacktop as _ };

import './VaBacktop.css';
//# sourceMappingURL=VaBacktop.js.map
