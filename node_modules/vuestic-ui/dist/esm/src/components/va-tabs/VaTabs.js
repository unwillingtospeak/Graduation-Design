var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, ref, reactive, computed, unref, provide, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, createBlock, createCommentVNode, normalizeStyle, createVNode, withCtx, renderSlot } from "vue";
import "../../../vendor.js";
import { u as useColors } from "../../composables/useColors.js";
import "../../composables/useDropdown.js";
import { u as useResizeObserver } from "../../composables/useResizeObserver.js";
import { a as useStatefulProps, b as useStateful } from "../../composables/useStateful.js";
import { T as TabsViewKey } from "./types.js";
import { V as VaButton } from "../va-button/index.js";
import { V as VaConfig } from "../va-config/VaConfig.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaTabs_vue_vue_type_style_index_0_lang = "";
const getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
const _sfc_main = defineComponent({
  name: "VaTabs",
  components: { VaButton, VaConfig },
  emits: ["update:modelValue", "click:next", "click:prev"],
  props: __spreadProps(__spreadValues({}, useStatefulProps), {
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "chevron_left" },
    nextIcon: { type: String, default: "chevron_right" }
  }),
  setup: (props, { emit }) => {
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : ""
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (showPagination.value && leftSidePosition + containerClientWidth <= tabsClientWidth) {
        tabsContentOffset.value = leftSidePosition;
      } else if (showPagination.value && rightSidePosition >= containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
      } else {
        tabsContentOffset.value = 0;
      }
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a;
        tab.updateSidePositions();
        const isTabSelected = (((_a = tab.name) == null ? void 0 : _a.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (tabsContentOffset.value + containerClientWidth > tabsClientWidth && tabsList.value) {
        moveToTab(tabsList.value[0]);
      }
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
    };
    const movePaginationLeft = () => {
      var _a, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      if (tabsList.value) {
        for (let i = 0; i < tabsList.value.length - 1; i++) {
          const currentTabLeftSidePosition = unref((_a = tabsList.value[i]) == null ? void 0 : _a.leftSidePosition);
          const nextTabLeftSidePosition = unref((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
          if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
            offsetToSet = currentTabLeftSidePosition;
            break;
          }
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      if (tabsList.value) {
        for (let i = 0; i < tabsList.value.length - 1; i++) {
          const rightSidePosition2 = unref(tabsList.value[i].rightSidePosition);
          if (rightSidePosition2 > containerRightSide) {
            offsetToSet = unref(tabsList.value[i].leftSidePosition);
            if (tabsContentOffset.value < offsetToSet) {
              break;
            }
          }
        }
      }
      const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a = container.value) == null ? void 0 : _a.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const redrawTabs = () => {
      const oldShowPaginationValue = showPagination.value;
      updatePagination();
      if (oldShowPaginationValue === showPagination.value) {
        updateTabsState();
        includeAnimation();
      } else {
        requestAnimationFrame(() => {
          updateTabsState();
          includeAnimation();
        });
      }
    };
    const selectTab = (tab) => {
      var _a;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a = tab.name) == null ? void 0 : _a.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a = tab.name) == null ? void 0 : _a.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a;
        tabListItem.id = ((_a = tabListItem.name) == null ? void 0 : _a.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper, tabs], redrawTabs);
    return {
      wrapper,
      container,
      tabs,
      tabsList,
      sliderHeight,
      sliderWidth,
      sliderOffsetX,
      sliderOffsetY,
      showPagination,
      tabsContentOffset,
      startingXPoint,
      animationIncluded,
      colorComputed,
      tabConfig,
      computedClass,
      computedTabsClass,
      tabSelected,
      sliderStyles,
      paginationControlledStyles,
      disablePaginationLeft,
      disablePaginationRight,
      resetSliderSizes,
      moveToTab,
      updateStartingXPoint,
      updateTabsState,
      updatePagination,
      movePaginationLeft,
      movePaginationRight,
      updateSlider,
      includeAnimation,
      redrawTabs,
      selectTab
    };
  }
});
const _hoisted_1 = ["aria-disabled"];
const _hoisted_2 = /* @__PURE__ */ createElementVNode("div", { class: "va-tabs__slider" }, null, -1);
const _hoisted_3 = [
  _hoisted_2
];
const _hoisted_4 = { class: "va-tabs__tabs-items" };
const _hoisted_5 = { class: "va-tabs__content" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createElementVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        class: "va-tabs__pagination",
        "aria-label": "move pagination left",
        size: "medium",
        disabled: _ctx.disablePaginationLeft,
        color: _ctx.color,
        flat: "",
        icon: _ctx.$props.prevIcon,
        onClick: _ctx.movePaginationLeft
      }, null, 8, ["disabled", "color", "icon", "onClick"])) : createCommentVNode("", true),
      createElementVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createElementVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createElementVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_3, 4),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_4, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3
          }, 8, ["components"])
        ], 4)
      ], 2),
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        class: "va-tabs__pagination",
        "aria-label": "move pagination right",
        size: "medium",
        color: _ctx.color,
        disabled: _ctx.disablePaginationRight,
        flat: "",
        icon: _ctx.$props.nextIcon,
        onClick: _ctx.movePaginationRight
      }, null, 8, ["color", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ], 8, _hoisted_1),
    createElementVNode("div", _hoisted_5, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var _VaTabs = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaTabs as _ };

import './VaTabs.css';
//# sourceMappingURL=VaTabs.js.map
