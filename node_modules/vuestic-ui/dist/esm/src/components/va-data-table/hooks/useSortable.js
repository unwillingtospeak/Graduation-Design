import { ref, computed, watch } from "vue";
function useSortable(columns, filteredRows, props, emit) {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const column = columns.value.find((column2) => column2.name === sortBySync.value);
    if (!column || !column.sortable) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.indexOf(column);
    return [...filteredRows.value].sort((a, b) => {
      const firstValue = a.cells[columnIndex].value;
      const secondValue = b.cells[columnIndex].value;
      const firstSource = a.cells[columnIndex].source;
      const secondSource = b.cells[columnIndex].source;
      if (sortingOrderSync.value === null) {
        return a.initialIndex - b.initialIndex;
      } else {
        const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    if (column.name === sortBySync.value) {
      sortingOrderSync.value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      sortingOrderSync.value = column.sortingOptions[0];
    }
  }
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "expand_less" : sortingOrderSync.value === "desc" ? "expand_more" : "unfold_more";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting,
    sortedRows,
    sortingOrderIconName
  };
}
export { useSortable as u };
//# sourceMappingURL=useSortable.js.map
