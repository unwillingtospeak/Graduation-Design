var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, computed, ref, watch, nextTick, resolveComponent, openBlock, createBlock, withCtx, createVNode, createSlots, mergeProps, withModifiers, withKeys, createCommentVNode, renderSlot, createElementBlock, toDisplayString, normalizeProps, createTextVNode, normalizeStyle, createElementVNode } from "vue";
import "../../../vendor.js";
import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.js";
import { u as useColors } from "../../composables/useColors.js";
import { u as useFocusDeep } from "../../composables/useFocusDeep.js";
import { u as useFormProps } from "../../composables/useForm.js";
import { u as useLoadingProps } from "../../composables/useLoading.js";
import { u as useMaxSelectionsProps, a as useMaxSelections } from "../../composables/useMaxSelections.js";
import "../../composables/useDropdown.js";
import { a as useValidationEmits, u as useValidationProps, b as useValidation } from "../../composables/useValidation.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaInput } from "../va-input/index.js";
import { V as VaSelectOptionList } from "./VaSelectOptionList/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.js";
var VaSelect_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectOptionList,
    VaIcon,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, useSelectableListProps), useValidationProps), useLoadingProps), useMaxSelectionsProps), useClearableProps), useFormProps), {
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    separator: { type: String, default: ", " },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "Items not found" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    dropdownIcon: {
      type: [String, Object],
      default: () => ({
        open: "expand_more",
        close: "expand_less"
      }),
      validator: (value) => {
        if (typeof value === "string") {
          return true;
        }
        const isOpenIconString = typeof value.open === "string";
        const isCloseIconString = typeof value.close === "string";
        return isOpenIconString && isCloseIconString;
      }
    },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    requiredMark: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const { getHoverColor, getColor } = useColors();
    const { getOptionByValue, getValue, getText, getTrackBy, getGroupBy } = useSelectableList(props);
    const {
      validate,
      computedError,
      computedErrorMessages
    } = useValidation(props, emit, () => reset(), () => focus());
    const colorComputed = computed(() => getColor(props.color));
    const toggleIconColor = computed(() => props.readonly ? getHoverColor(colorComputed.value) : colorComputed.value);
    const onScrollBottom = () => {
      emit("scroll-bottom");
    };
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const valueComputed = computed({
      get() {
        const value = getOptionByValue(props.modelValue);
        if (props.multiple) {
          if (!value) {
            return [];
          }
          if (!Array.isArray(value)) {
            return [value];
          }
          return value.map((o) => getOptionByValue(o));
        }
        if (Array.isArray(value)) {
          if (value.length) {
            return value[value.length - 1];
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue));
        } else {
          emit("update:modelValue", getValue(value));
        }
      }
    });
    const valueComputedString = computed(() => {
      if (!valueComputed.value) {
        return props.clearValue;
      }
      if (typeof valueComputed.value === "string" || typeof valueComputed.value === "number") {
        return valueComputed.value;
      }
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
      }
      return getText(valueComputed.value);
    });
    const isPlaceholder = computed(() => props.placeholder && !valueComputedString.value);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const toggleIcon = computed(() => {
      if (!props.dropdownIcon) {
        return "";
      }
      if (typeof props.dropdownIcon === "string") {
        return props.dropdownIcon;
      }
      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue(option1);
      const two = getValue(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections), emit);
        const isSelected = checkIsOptionSelected(getValue(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue(option), getValue(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          addOption(getValue(option));
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : __spreadValues({}, option);
        hideAndFocus();
      }
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => getText(option) === searchInput.value);
      if (!(props.allowCreate === "unique" && hasAddedOption)) {
        emit("create-new", searchInput.value);
        searchInput.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value) {
        return;
      }
      if (!showDropdownContent.value) {
        showDropdown();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && searchInput.value !== "";
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const hoverPreviousOption = () => {
      var _a;
      (_a = optionList.value) == null ? void 0 : _a.hoverPreviousOption();
    };
    const hoverNextOption = () => {
      var _a;
      (_a = optionList.value) == null ? void 0 : _a.hoverNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? showDropdown() : hideDropdown();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const hideDropdown = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const toggleDropdown = () => {
      if (showDropdownContent.value) {
        hideAndFocus();
      } else {
        showDropdown();
      }
    };
    const onSelectClick = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      toggleDropdown();
    };
    const hideAndFocus = () => {
      hideDropdown();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.hoverFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const focus = () => {
      var _a;
      if (props.disabled) {
        return;
      }
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick((_a = input.value) == null ? void 0 : _a.blur);
    };
    const reset = () => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    return {
      isFocused,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      onSelectClick,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueComputed,
      valueComputedString,
      showClearIcon,
      toggleIcon,
      computedErrorMessages,
      computedError,
      filteredOptions,
      checkIsOptionSelected,
      closeOnContentClick,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      hoverPreviousOption,
      hoverNextOption,
      showDropdownContentComputed,
      showDropdown,
      hideDropdown,
      hideAndFocus,
      toggleDropdown,
      toggleIconColor,
      onHintedSearch,
      getText,
      getTrackBy,
      getGroupBy,
      onScrollBottom,
      clearIconProps,
      isPlaceholder
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "va-select-anchor__placeholder"
};
const _hoisted_2 = { class: "va-select-dropdown__options-wrapper" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    ref: "dropdown",
    class: "va-select va-select__dropdown va-select-dropdown",
    "aria-label": `select option (currently selected: ${_ctx.$props.modelValue})`,
    placement: _ctx.$props.placement,
    disabled: _ctx.$props.disabled,
    "max-height": _ctx.$props.maxHeight,
    "close-on-content-click": _ctx.closeOnContentClick,
    stateful: false,
    offset: [1, 0],
    "keep-anchor-width": "",
    "keyboard-navigation": "",
    "inner-anchor-selector": ".va-input-wrapper__field",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    onClose: _ctx.focus
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, {
        ref: "input",
        class: "va-select__anchor va-select-anchor__input",
        "model-value": _ctx.valueComputedString,
        success: _ctx.$props.success,
        error: _ctx.computedError,
        color: _ctx.$props.color,
        label: _ctx.$props.label,
        loading: _ctx.$props.loading,
        disabled: _ctx.$props.disabled,
        outline: _ctx.$props.outline,
        bordered: _ctx.$props.bordered,
        "required-mark": _ctx.$props.requiredMark,
        messages: _ctx.$props.messages,
        "error-messages": _ctx.computedErrorMessages,
        focused: _ctx.isFocused,
        tabindex: _ctx.tabIndexComputed,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur
      }, createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-hidden": "false",
            "aria-label": "reset",
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          _ctx.$slots.appendInner ? renderSlot(_ctx.$slots, "appendInner", { key: 0 }) : createCommentVNode("", true),
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon
          }, null, 8, ["color", "name"])
        ]),
        default: withCtx(() => [
          _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
            valueString: _ctx.valueComputedString,
            value: _ctx.valueComputed,
            tabindex: _ctx.tabIndexComputed
          })), () => [
            createTextVNode(toDisplayString(_ctx.valueComputedString), 1)
          ])
        ]),
        _: 2
      }, [
        _ctx.$slots.prepend ? {
          name: "prepend",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prepend")
          ])
        } : void 0,
        _ctx.$slots.append ? {
          name: "append",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "append")
          ])
        } : void 0,
        _ctx.$slots.prependInner ? {
          name: "prependInner",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prependInner")
          ])
        } : void 0
      ]), 1032, ["model-value", "success", "error", "color", "label", "loading", "disabled", "outline", "bordered", "required-mark", "messages", "error-messages", "focused", "tabindex", "onFocus", "onBlur"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width })
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            placeholder: "Search",
            "aria-label": "options filter",
            tabindex: _ctx.tabIndexComputed,
            bordered: true,
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            onKeydown: [
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["tabindex", "modelValue", "onKeydown"])) : createCommentVNode("", true),
          createElementVNode("div", _hoisted_2, [
            createVNode(_component_va_select_option_list, {
              ref: "optionList",
              hoveredOption: _ctx.hoveredOption,
              "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
              style: normalizeStyle({ maxHeight: _ctx.$props.maxHeight }),
              options: _ctx.filteredOptions,
              "selected-value": _ctx.valueComputed,
              "get-selected-state": _ctx.checkIsOptionSelected,
              "get-text": _ctx.getText,
              "get-track-by": _ctx.getTrackBy,
              "get-group-by": _ctx.getGroupBy,
              search: _ctx.searchInput,
              "no-options-text": _ctx.$props.noOptionsText,
              color: _ctx.$props.color,
              tabindex: _ctx.tabIndexComputed,
              onSelectOption: _ctx.selectOption,
              onNoPreviousOptionToHover: _ctx.focusSearchBar,
              onKeydown: [
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
                withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
                _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
                _ctx.onHintedSearch
              ],
              onScrollBottom: _ctx.onScrollBottom
            }, null, 8, ["hoveredOption", "style", "options", "selected-value", "get-selected-state", "get-text", "get-track-by", "get-group-by", "search", "no-options-text", "color", "tabindex", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
          ])
        ]),
        _: 1
      }, 8, ["style"])
    ]),
    _: 3
  }, 8, ["aria-label", "placement", "disabled", "max-height", "close-on-content-click", "modelValue", "onClose"]);
}
var _VaSelect = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSelect as _ };

import './VaSelect.css';
//# sourceMappingURL=VaSelect.js.map
