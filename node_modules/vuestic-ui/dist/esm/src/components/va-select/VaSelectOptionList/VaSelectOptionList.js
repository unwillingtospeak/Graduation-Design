var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, ref, computed, watch, resolveComponent, openBlock, createElementBlock, withKeys, withModifiers, Fragment, renderList, toDisplayString, createCommentVNode, normalizeClass, normalizeStyle, createBlock, createElementVNode, withDirectives, createVNode, vShow } from "vue";
import { s as scrollToElement } from "../../../utils/scroll-to-element.js";
import "../../../../vendor.js";
import { a as useColorProps, u as useColors } from "../../../composables/useColors.js";
import "../../../composables/useDropdown.js";
import { V as VaIcon } from "../../va-icon/index.js";
import { _ as _export_sfc } from "../../../../plugin-vue_export-helper.js";
var VaSelectOptionList_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSelectOptionList",
  components: { VaIcon },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: __spreadProps(__spreadValues({}, useColorProps), {
    options: { type: Array, default: () => [] },
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    getGroupBy: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: {
      type: [String, Number, Object],
      default: null
    }
  }),
  setup(props, { emit }) {
    const { getColor, getHoverColor } = useColors();
    const rootElement = shallowRef();
    const itemRefs = ref({});
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        emit("scroll-bottom");
      }
    };
    const beforeUpdate = () => {
      itemRefs.value = {};
    };
    const setItemRef = (option) => (el) => {
      if (el) {
        itemRefs.value[props.getTrackBy(option)] = el;
      }
    };
    const hoveredOptionComputed = computed({
      get: () => props.hoveredOption || null,
      set: (value) => emit("update:hoveredOption", value)
    });
    const filteredOptions = computed(() => {
      if (!props.search) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = props.getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !option.group) {
        groups._noGroup.push(option);
      } else {
        const groupBy = props.getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const selectOption = (option) => emit("select-option", option);
    const getOptionIcon = (option) => typeof option === "object" ? option.icon : void 0;
    const getOptionClass = (option) => ({
      "va-select-option-list__option": true,
      "va-select-option-list__option--selected": props.getSelectedState(option)
    });
    const getOptionStyle = (option) => ({
      color: props.getSelectedState(option) ? getColor(props.color) : "inherit",
      backgroundColor: isHovered(option) ? getHoverColor(getColor(props.color)) : "transparent"
    });
    const isHovered = (option) => {
      if (!hoveredOptionComputed.value) {
        return false;
      }
      if (typeof option === "string") {
        return option === hoveredOptionComputed.value;
      }
      if (!props.getTrackBy) {
        return false;
      }
      return props.getTrackBy(hoveredOptionComputed.value) === props.getTrackBy(option);
    };
    const updateHoveredOption = (option) => {
      hoveredOptionComputed.value = option || null;
    };
    const hoveredOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {
      return !!hoveredOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(hoveredOptionComputed.value);
    }));
    const hoverPreviousOption = () => {
      if (!hoveredOptionComputed.value) {
        filteredOptions.value.length && updateHoveredOption(filteredOptions.value.at(-1));
      } else {
        if (filteredOptions.value[hoveredOptionIndex.value - 1]) {
          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value - 1];
        } else {
          emit("no-previous-option-to-hover");
        }
      }
    };
    const hoverNextOption = () => {
      if (!hoveredOptionComputed.value) {
        filteredOptions.value.length && updateHoveredOption(filteredOptions.value[0]);
      } else {
        if (filteredOptions.value[hoveredOptionIndex.value + 1]) {
          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value + 1];
        }
      }
    };
    const hoverFirstOption = () => {
      if (filteredOptions.value.length > 0) {
        updateHoveredOption(filteredOptions.value[0]);
      }
    };
    const focus = () => {
      var _a;
      (_a = rootElement.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const scrollToOption = (option) => {
      if (!option) {
        return;
      }
      const element = itemRefs.value[props.getTrackBy(option)];
      if (element) {
        scrollToElement(element);
      }
    };
    watch(() => props.hoveredOption, (newOption) => newOption && scrollToOption(newOption));
    const publicMethods = {
      hoverPreviousOption,
      hoverNextOption,
      hoverFirstOption,
      focus,
      scrollToOption
    };
    return __spreadValues({
      rootElement,
      getColor,
      filteredOptions,
      optionGroups,
      onScroll,
      beforeUpdate,
      setItemRef,
      selectOption,
      getOptionIcon,
      getOptionClass,
      getOptionStyle,
      updateHoveredOption
    }, publicMethods);
  }
});
const _hoisted_1 = ["tabindex"];
const _hoisted_2 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
const _hoisted_3 = ["aria-selected", "onClick", "onMouseover"];
const _hoisted_4 = {
  key: 0,
  class: "va-select-option-list no-options"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.hoverPreviousOption && _ctx.hoverPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.hoverNextOption && _ctx.hoverNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.hoverNextOption && _ctx.hoverNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
          return openBlock(), createElementBlock("div", {
            key: _ctx.$props.getTrackBy(option),
            ref_for: true,
            ref: _ctx.setItemRef(option),
            role: "option",
            "aria-selected": !!_ctx.$props.getSelectedState(option),
            class: normalizeClass(_ctx.getOptionClass(option)),
            style: normalizeStyle(_ctx.getOptionStyle(option)),
            onClick: ($event) => _ctx.selectOption(option),
            onMouseover: ($event) => _ctx.updateHoveredOption(option)
          }, [
            _ctx.getOptionIcon(option) ? (openBlock(), createBlock(_component_va_icon, {
              key: 0,
              size: "small",
              class: "va-select-option-list__option--icon",
              name: _ctx.getOptionIcon(option)
            }, null, 8, ["name"])) : createCommentVNode("", true),
            createElementVNode("span", null, toDisplayString(_ctx.getText(option)), 1),
            withDirectives(createVNode(_component_va_icon, {
              class: "va-select-option-list__option--selected-icon",
              size: "small",
              name: "done",
              color: _ctx.getColor(_ctx.$props.color)
            }, null, 8, ["color"]), [
              [vShow, _ctx.$props.getSelectedState(option)]
            ])
          ], 46, _hoisted_3);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_4, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_1);
}
var _VaSelectOptionList = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSelectOptionList as _ };

import './VaSelectOptionList.css';
//# sourceMappingURL=VaSelectOptionList.js.map
