import { defineComponent, shallowRef, ref, computed, watch, resolveComponent, openBlock, createBlock, resolveDynamicComponent, normalizeClass, withCtx, renderSlot, createElementVNode, createVNode, createCommentVNode } from "vue";
import { d as debounce_1 } from "../../../vendor.js";
import { s as sleep } from "../../services/utils.js";
import { u as useColors } from "../../composables/useColors.js";
import "../../composables/useDropdown.js";
import { u as useScroll } from "./hooks/useScroll.js";
import { V as VaProgressCircle } from "../va-progress-circle/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaInfiniteScroll_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaInfiniteScroll",
  components: { VaProgressCircle },
  props: {
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: void 0 },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(props, { emit }) {
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a;
      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props.debounce, (value) => {
      debouncedLoad.value = debounce_1(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return {
      element,
      spinnerSlotContainer,
      spinnerColor,
      fetching
    };
  }
});
const _hoisted_1 = { class: "va-infinite-scroll__spinner__default" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createElementVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !_ctx.fetching }])
      }, [
        !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
          createElementVNode("div", _hoisted_1, [
            createVNode(_component_va_progress_circle, {
              size: "small",
              thickness: 0.15,
              color: _ctx.spinnerColor,
              indeterminate: ""
            }, null, 8, ["thickness", "color"])
          ])
        ]) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["class", "aria-busy"]);
}
var _VaInfiniteScroll = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaInfiniteScroll as _ };

import './VaInfiniteScroll.css';
//# sourceMappingURL=VaInfiniteScroll.js.map
