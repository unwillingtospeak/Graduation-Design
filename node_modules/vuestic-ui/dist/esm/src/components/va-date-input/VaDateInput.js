var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, ref, toRefs, computed, watch, nextTick, resolveComponent, openBlock, createBlock, normalizeClass, normalizeStyle, withCtx, renderSlot, normalizeProps, guardReactiveProps, createVNode, mergeProps, createSlots, createElementVNode, toHandlers, createCommentVNode, withModifiers, withKeys, renderList } from "vue";
import { o as omit_1 } from "../../../vendor.js";
import { e as extractComponentProps, a as extractComponentEmits, f as filterComponentProps } from "../../utils/child-props.js";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.js";
import "colortranslator";
import { u as useFocusEmits, a as useFocus } from "../../composables/useFocus.js";
import { u as useParsable } from "../../composables/useParsable.js";
import "../../composables/useDropdown.js";
import { u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from "../../composables/useValidation.js";
import { u as useSyncProp } from "../va-date-picker/hooks/sync-prop.js";
import { u as useRangeModelValueGuard } from "./hooks/range-model-value-guard.js";
import { u as useDateParser } from "./hooks/input-text-parser.js";
import { i as isDates, a as isSingleDate, b as isRange } from "../va-date-picker/utils/date-utils.js";
import { _ as _VaDatePicker } from "../va-date-picker/VaDatePicker.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import "../va-input/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.js";
var VaDateInput_vue_vue_type_style_index_0_lang = "";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const VaDatePickerProps = extractComponentProps(_VaDatePicker);
const _sfc_main = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon
  },
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, useClearableProps), VaInputWrapperProps), VaDatePickerProps), useValidationProps), {
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "calendar_today" }
  }),
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp(isOpen, "is-open", emit, false);
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => {
      statefulValue.value = props.clearValue;
      emit("clear");
    };
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const { computedError, computedErrorMessages, listeners, validationAriaAttributes } = useValidation(props, emit, reset, focus);
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const iconProps = computed(() => ({
      name: props.icon,
      color: props.color,
      size: "small",
      class: "va-date-input__icon"
    }));
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const computedInputWrapperProps = computed(() => __spreadProps(__spreadValues({}, filterComponentProps(props, VaInputWrapperProps).value), {
      focused: isFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const inputAttributesComputed = computed(() => __spreadValues(__spreadValues({
      readonly: props.readonly || !props.manualInput,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || "selected date",
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    return {
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      isFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(props, VaDatePickerProps),
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur,
      iconTabindexComputed
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.isOpenSync = $event),
    class: normalizeClass(["va-date-input", _ctx.$attrs.class]),
    "inner-anchor-selector": ".va-input-wrapper__field",
    style: normalizeStyle(_ctx.$attrs.style),
    offset: [2, 0],
    "close-on-content-click": false,
    stateful: false,
    disabled: _ctx.$props.disabled,
    "keyboard-navigation": "",
    onOpen: _ctx.focusDatePicker,
    onClose: _ctx.focus
  }, {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputAttributes: _ctx.inputAttributesComputed, inputWrapperProps: _ctx.inputWrapperProps, inputListeners: _ctx.inputListeners })), () => [
        createVNode(_component_va_input_wrapper, mergeProps(_ctx.inputWrapperProps, { class: "va-date-input__anchor" }), createSlots({
          default: withCtx(() => [
            createElementVNode("input", mergeProps({
              ref: "input",
              class: "va-date-input__input"
            }, _ctx.inputAttributesComputed, toHandlers(_ctx.inputListeners), {
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
            }), null, 16)
          ]),
          prependInner: withCtx((slotScope) => [
            renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, normalizeProps(mergeProps({ key: 0 }, _ctx.iconProps)), null, 16)) : createCommentVNode("", true)
          ]),
          icon: withCtx(() => [
            _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              class: "va-date-input__clear-icon",
              role: "button",
              "aria-label": "reset date",
              "aria-hiden": "false",
              tabindex: _ctx.iconTabindexComputed
            }, _ctx.clearIconProps, {
              onClick: withModifiers(_ctx.reset, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
              ]
            }), null, 16, ["tabindex", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 1,
              tabindex: _ctx.iconTabindexComputed
            }, _ctx.iconProps), null, 16, ["tabindex"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.filterSlots, (name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          })
        ]), 1040)
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, { class: "va-date-input__dropdown-content" }, {
        default: withCtx(() => [
          createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
            modelValue: _ctx.valueWithoutText,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueWithoutText = $event),
            "onClick:day": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:day", $event)),
            "onClick:month": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:month", $event)),
            "onClick:year": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:year", $event)),
            "onHover:day": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:day", $event)),
            "onHover:month": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:month", $event)),
            "onHover:year": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("hover:year", $event)),
            "onUpdate:view": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:view", $event))
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["modelValue"])
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 8, ["modelValue", "class", "style", "disabled", "onOpen", "onClose"]);
}
var _VaDateInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaDateInput as _ };

import './VaDateInput.css';
//# sourceMappingURL=VaDateInput.js.map
