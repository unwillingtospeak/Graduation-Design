var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, ref, computed, onMounted, onBeforeUnmount, watch, resolveComponent, openBlock, createElementBlock, mergeProps, renderSlot, createCommentVNode, normalizeStyle, createTextVNode, toDisplayString, createVNode, createElementVNode, Fragment, renderList, normalizeClass, normalizeProps, guardReactiveProps } from "vue";
import { p as pick_1 } from "../../../vendor.js";
import { g as generateUniqueId } from "../../services/utils.js";
import { u as useArrayRefs } from "../../composables/useArrayRefs.js";
import { u as useBem } from "../../composables/useBem.js";
import { u as useColors } from "../../composables/useColors.js";
import "../../composables/useDropdown.js";
import { v as validateSlider } from "./validateSlider.js";
import { V as VaIcon } from "../va-icon/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaSlider_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSlider",
  components: { VaIcon },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  props: {
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true }
  },
  setup(props, { emit, slots }) {
    const { getColor, getHoverColor } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset = ref(0);
    const size = ref(0);
    const currentValue = ref(Array.isArray(props.modelValue) ? [...props.modelValue] : props.modelValue);
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => __spreadProps(__spreadValues({}, pick_1(props, ["disabled", "readonly", "vertical"])), {
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [trackSizeStyle.value]: `${val2}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val2}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range && index !== void 0 ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => props.modelValue,
      set: (val2) => {
        if (!props.range) {
          val2 = limitValue(val2);
        }
        if (!flag.value) {
          emit("change", val2);
        }
        emit("update:modelValue", val2);
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props.max - props.min) / props.step;
      return size.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props.max - props.min) / props.step - 1);
    const position = computed(() => {
      return Array.isArray(props.modelValue) ? [(props.modelValue[0] - props.min) / props.step * gap.value, (props.modelValue[1] - props.min) / props.step * gap.value] : (props.modelValue - props.min) / props.step * gap.value;
    });
    const limit = computed(() => [0, size.value]);
    const valueLimit = computed(() => [props.min, props.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e, index = currentSliderDotIndex.value) => {
      var _a, _b;
      e.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e ? e.touches[0] : e;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(props.modelValue)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(props.modelValue) ? (_a = dots.value[index]) == null ? void 0 : _a.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e.preventDefault();
      if ("touches" in e) {
        setValueOnPos(getPos(e.touches[0]));
      } else {
        setValueOnPos(getPos(e));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", props.modelValue);
        } else {
          return false;
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const moveWithKeys = (event) => {
      var _a, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (isRange, where, which) => {
        if (isRange && Array.isArray(val.value)) {
          if (!props.pins) {
            return val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = val.value[which] / onePinInterval | 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value[which] !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value.splice(which, 1, nearestPinVal);
          } else {
            val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
        } else {
          if (!props.pins && !Array.isArray(val.value)) {
            val.value += where ? props.step : -props.step;
            return;
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = !Array.isArray(val.value) ? val.value / onePinInterval | 0 : 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value = nearestPinVal;
          } else {
            val.value += where ? props.step : -props.step;
          }
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min):
            (_a = dots.value[0]) == null ? void 0 : _a.focus();
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min):
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max):
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min):
            moveDot(true, 0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max):
            moveDot(true, 1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(false, 1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(false, 1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props.step > val.value[0] && pin * props.step < val.value[1];
      } else {
        return pin * props.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e) => {
      getStaticData();
      return props.vertical ? offset.value - e.clientY : e.clientX - offset.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value) && Array.isArray(currentValue.value) && Array.isArray(props.modelValue)) {
        if (isDiff(currentValue.value[slider], newValue)) {
          currentValue.value.splice(slider, 1, newValue);
          if (slider === 0) {
            val.value = [currentValue.value.splice(slider, 1, newValue)[0], props.modelValue[1]];
            currentValue.value = [...val.value];
          } else {
            val.value = [props.modelValue[0], currentValue.value.splice(slider, 1, newValue)[0]];
            currentValue.value = [...val.value];
          }
        }
      } else {
        if (newValue < props.min || newValue > props.max) {
          return false;
        }
        if (isDiff(currentValue.value, newValue)) {
          currentValue.value = newValue;
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(props.modelValue) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value[1] = val.value[0];
            currentSliderDotIndex.value = 0;
          }
          const v = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v);
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value[0] = val.value[1];
            currentSliderDotIndex.value = 1;
          }
          const v = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v);
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const limitValue = (val2) => {
      const inRange = (v) => {
        if (v < props.min) {
          return props.min;
        } else if (v > props.max) {
          return props.max;
        }
        return v;
      };
      if (Array.isArray(val2)) {
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 0) {
          const v = inRange(val2[1]);
          return [v, v];
        }
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 1) {
          const v = inRange(val2[0]);
          return [v, v];
        }
        return val2.map((v) => inRange(v));
      } else {
        return inRange(val2);
      }
    };
    const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
    const clickOnContainer = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": props.min,
      "aria-valuemax": props.max,
      "aria-label": !slots.label && !props.label ? `current slider value is ${String(props.modelValue)}` : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      ariaOrientation: props.vertical ? "vertical" : "horizontal",
      ariaDisabled: props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(props.modelValue) ? props.modelValue : void 0,
      "aria-valuetext": Array.isArray(props.modelValue) ? String(props.modelValue) : void 0
    }));
    onMounted(() => {
      if (validateSlider(props.modelValue, props.step, props.min, props.max, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props.step,
      () => props.min,
      () => props.max,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return {
      getColor,
      dot,
      dots,
      setItemRefByIndex,
      orders,
      sliderContainer,
      val,
      getValueByOrder,
      sliderClass,
      dotClass,
      labelStyles,
      processedStyles,
      getPinStyles,
      dottedStyles,
      getDottedStyles,
      clickOnContainer,
      hasMouseDown,
      trackStyles,
      pinsCol,
      checkActivePin,
      isFocused,
      isActiveDot,
      getTrackLabel,
      currentSliderDotIndex,
      ariaLabelIdComputed,
      ariaAttributesComputed
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
const _hoisted_2 = ["id"];
const _hoisted_3 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
const _hoisted_4 = ["tabindex", "onFocus"];
const _hoisted_5 = ["tabindex"];
const _hoisted_6 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
const _hoisted_7 = ["id"];
const _hoisted_8 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_1, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "append" : "prepend")
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "va-input__label",
      id: _ctx.ariaLabelIdComputed,
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_2)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_3, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    createElementVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args)),
      onMouseup: _cache[4] || (_cache[4] = ($event) => _ctx.hasMouseDown = false),
      onTouchstart: _cache[5] || (_cache[5] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args))
    }, [
      createElementVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4),
      _ctx.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i) => {
        return openBlock(), createElementBlock("div", {
          key: i,
          class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": _ctx.checkActivePin(pin) }]),
          style: normalizeStyle(_ctx.getPinStyles(pin))
        }, null, 6);
      }), 128)) : createCommentVNode("", true),
      _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createElementVNode("div", {
          ref: "process",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          "aria-hidden": "true",
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
          return openBlock(), createElementBlock("div", {
            key: "dot" + order,
            ref_for: true,
            ref: _ctx.setItemRefByIndex(order),
            class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
            style: normalizeStyle(_ctx.getDottedStyles(order)),
            tabindex: _ctx.disabled || _ctx.readonly ? void 0 : 0,
            onFocus: ($event) => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
            onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = false)
          }, [
            _ctx.isActiveDot(order) ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
              class: "va-slider__handler__dot--focus"
            }, null, 4)) : createCommentVNode("", true),
            _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle(_ctx.labelStyles),
              class: "va-slider__handler__dot--value"
            }, [
              renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1)
              ])
            ], 4)) : createCommentVNode("", true)
          ], 46, _hoisted_4);
        }), 128))
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createElementVNode("div", {
          ref: "process",
          "aria-hidden": "true",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        createElementVNode("div", {
          ref: "dot",
          class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
          style: normalizeStyle(_ctx.dottedStyles),
          tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = false)
        }, [
          _ctx.isActiveDot(0) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-slider__handler__dot--focus",
            style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
          }, null, 4)) : createCommentVNode("", true),
          _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-slider__handler__dot--value",
            style: normalizeStyle(_ctx.labelStyles)
          }, [
            renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
              createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1)
            ])
          ], 4)) : createCommentVNode("", true)
        ], 46, _hoisted_5)
      ], 64))
    ], 544),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_6, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && _ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 4,
      class: "va-input__label va-input__label--inverse",
      style: normalizeStyle(_ctx.labelStyles),
      id: _ctx.ariaLabelIdComputed
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_7)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_8, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "prepend" : "append")
    ])) : createCommentVNode("", true)
  ], 16);
}
var _VaSlider = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSlider as _ };

import './VaSlider.css';
//# sourceMappingURL=VaSlider.js.map
