import { defineComponent, ref, provide, onMounted, inject, nextTick, onUnmounted, openBlock, createBlock, resolveDynamicComponent, withCtx, renderSlot } from "vue";
import { F as FormServiceKey } from "./consts.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaForm_vue_vue_type_style_index_0_lang = "";
const isVaForm = (value) => !!value.focusInvalid;
const _sfc_main = defineComponent({
  name: "VaForm",
  emits: ["validation"],
  props: {
    autofocus: { type: Boolean, default: false },
    tag: { type: String, default: "div" }
  },
  setup(props, { emit }) {
    const nestedFormElements = ref([]);
    const parentFormProvider = () => inject(FormServiceKey, void 0);
    provide(FormServiceKey, {
      onChildMounted: (child) => childMountedHandler(child),
      onChildUnmounted: (removableChild) => childUnmountedHandler(removableChild)
    });
    const childMountedHandler = (child) => {
      nestedFormElements.value.push(child);
    };
    const childUnmountedHandler = (removableChild) => {
      nestedFormElements.value = nestedFormElements.value.filter((child) => child !== removableChild);
    };
    const reset = () => {
      nestedFormElements.value.filter(({ reset: reset2 }) => reset2).forEach((item) => {
        item.reset();
      });
    };
    const resetValidation = () => {
      nestedFormElements.value.filter(({ resetValidation: resetValidation2 }) => resetValidation2).forEach((item) => {
        item.resetValidation();
      });
    };
    const focus = () => {
      var _a;
      (_a = nestedFormElements.value.find(({ focus: focus2 }) => focus2)) == null ? void 0 : _a.focus();
    };
    const focusInvalid = () => {
      const invalidComponent = nestedFormElements.value.find((item) => !isVaForm(item) && item.hasError());
      if (invalidComponent) {
        invalidComponent.focus();
      } else {
        nestedFormElements.value.forEach((item) => isVaForm(item) && item.focusInvalid());
      }
    };
    const validate = () => {
      const formValid = nestedFormElements.value.filter(({ validate: validate2 }) => validate2).map((child) => child.validate()).every((isValid) => isValid);
      emit("validation", formValid);
      return formValid;
    };
    const publicMethods = {
      reset,
      resetValidation,
      focus,
      focusInvalid,
      validate
    };
    onMounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildMounted) == null ? void 0 : _b.call(_a, publicMethods);
      if (props.autofocus) {
        nextTick(focus);
      }
    });
    onUnmounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildUnmounted) == null ? void 0 : _b.call(_a, publicMethods);
    });
    return publicMethods;
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), { class: "va-form" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
var _VaForm = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaForm as _ };

import './VaForm.css';
//# sourceMappingURL=VaForm.js.map
