var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, computed, nextTick, resolveComponent, openBlock, createBlock, normalizeClass, normalizeStyle, withCtx, createVNode, mergeProps, createSlots, createElementVNode, toHandlers, renderSlot, normalizeProps, guardReactiveProps, createCommentVNode, withModifiers, withKeys, renderList } from "vue";
import { o as omit_1 } from "../../../vendor.js";
import { e as extractComponentProps, f as filterComponentProps } from "../../utils/child-props.js";
import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.js";
import "colortranslator";
import { u as useFocusEmits, a as useFocus } from "../../composables/useFocus.js";
import "../../composables/useDropdown.js";
import { a as useValidationEmits, u as useValidationProps, b as useValidation } from "../../composables/useValidation.js";
import { u as useSyncProp } from "../../composables/useSyncProp.js";
import { u as useTimeParser } from "./hooks/time-text-parser.js";
import { u as useTimeFormatter } from "./hooks/time-text-formatter.js";
import { _ as _VaTimePicker } from "../va-time-picker/VaTimePicker.js";
import "../va-input/index.js";
import { V as VaIcon } from "../va-icon/VaIcon.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.js";
var VaTimeInput_vue_vue_type_style_index_0_lang = "";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const _sfc_main = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    "update:modelValue",
    "update:isOpen"
  ],
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, useClearableProps), VaInputWrapperProps), extractComponentProps(_VaTimePicker)), useValidationProps), {
    isOpen: { type: Boolean, default: void 0 },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" }
  }),
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
    const [modelValueSync] = useSyncProp("modelValue", props, emit);
    const { parse, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(modelValueSync.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a;
      const val = (_a = e.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v = parse(val);
      if (isValid.value && v) {
        modelValueSync.value = v;
      } else {
        modelValueSync.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
    };
    const { computedError, computedErrorMessages, listeners, validationAriaAttributes } = useValidation(props, emit, reset, focus);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const iconProps = computed(() => ({
      name: props.icon,
      color: props.color,
      size: "small"
    }));
    const computedInputWrapperProps = computed(() => __spreadProps(__spreadValues({}, filterComponentProps(props, VaInputWrapperProps).value), {
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const inputAttributesComputed = computed(() => __spreadValues(__spreadValues({
      readonly: props.readonly || !props.manualInput,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || "selected date",
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    return {
      input,
      timePicker,
      timePickerProps: filterComponentProps(props, extractComponentProps(_VaTimePicker)),
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      modelValueSync,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      iconTabindexComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, {
    modelValue: _ctx.doShowDropdown,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.doShowDropdown = $event),
    class: normalizeClass(["va-time-input", _ctx.$attrs.class]),
    placement: "bottom-start",
    "inner-anchor-selector": ".va-input-wrapper__field",
    style: normalizeStyle(_ctx.$attrs.style),
    offset: [2, 0],
    "close-on-content-click": false,
    disabled: _ctx.$props.disabled,
    "keyboard-navigation": ""
  }, {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({ class: "va-time-input__anchor" }, _ctx.computedInputWrapperProps), createSlots({
        default: withCtx(() => [
          createElementVNode("input", mergeProps({
            ref: "input",
            class: "va-time-input__input"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.computedInputListeners), {
            onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
          }), null, 16)
        ]),
        prependInner: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(__spreadProps(__spreadValues({}, slotScope), { toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))),
          _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": "toggle dropdown",
            "aria-hidden": "false",
            tabindex: _ctx.iconTabindexComputed
          }, _ctx.iconProps), null, 16, ["tabindex"])) : createCommentVNode("", true)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": "reset time",
            "aria-hidden": "false",
            tabindex: _ctx.iconTabindexComputed
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["tabindex", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            role: "button",
            "aria-label": "toggle dropdown",
            "aria-hidden": "false",
            tabindex: _ctx.iconTabindexComputed
          }, _ctx.iconProps), null, 16, ["tabindex"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(__spreadProps(__spreadValues({}, slotScope), { toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))))
            ])
          };
        })
      ]), 1040)
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.modelValueSync = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown", "onKeypress"])
    ]),
    _: 3
  }, 8, ["modelValue", "class", "style", "disabled"]);
}
var _VaTimeInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaTimeInput as _ };

import './VaTimeInput.css';
//# sourceMappingURL=VaTimeInput.js.map
