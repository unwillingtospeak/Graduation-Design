var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, ref, computed, resolveComponent, openBlock, createBlock, resolveDynamicComponent, mergeProps, toHandlers, withCtx, createElementVNode, normalizeClass, createCommentVNode, renderSlot } from "vue";
import "../../../vendor.js";
import { u as useColors } from "../../composables/useColors.js";
import { u as useLoadingProps } from "../../composables/useLoading.js";
import "../../composables/useDropdown.js";
import { u as useRouterLinkProps, a as useRouterLink } from "../../composables/useRouterLink.js";
import { u as useSizeProps, a as useSize } from "../../composables/useSize.js";
import { u as useTextColor } from "../../composables/useTextColor.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaProgressCircle } from "../va-progress-circle/index.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaButton_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaButton",
  components: { VaIcon, VaProgressCircle },
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, useSizeProps), useLoadingProps), useRouterLinkProps), {
    color: { type: String, default: "primary" },
    textColor: { type: String, default: void 0 },
    tag: { type: String, default: "button" },
    outline: { type: Boolean, default: void 0 },
    gradient: { type: Boolean, default: void 0 },
    flat: { type: Boolean, default: void 0 },
    type: { type: String, default: "button" },
    disabled: { type: Boolean, default: false },
    block: { type: Boolean, default: false },
    rounded: { type: Boolean, default: true },
    round: { type: Boolean, default: void 0 },
    spaceBetweenItems: { type: Boolean, default: void 0 },
    icon: { type: String, default: void 0 },
    iconRight: { type: String, default: void 0 },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  }),
  setup(props, { slots }) {
    const button = shallowRef();
    const { sizeComputed } = useSize(props);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const hoverState = ref(false);
    const focusState = ref(false);
    const { getColor, getGradientBackground, shiftHSLAColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const isSlotContentPassed = computed(() => {
      var _a, _b, _c;
      return !!((_c = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) == null ? void 0 : _b[0]) == null ? void 0 : _c.children);
    });
    const computedType = computed(() => {
      switch (tagComputed.value) {
        case "a":
        case "router-link":
        case "nuxt-link":
          return void 0;
        default:
          return props.type;
      }
    });
    const onlyIcon = computed(() => {
      return Boolean(!slots.default && (props.iconRight && !props.icon || !props.iconRight && props.icon));
    });
    const computedClass = computed(() => ({
      "va-button--default": !props.flat && !props.outline && !props.disabled,
      "va-button--flat": props.flat,
      "va-button--outline": props.outline,
      "va-button--disabled": props.disabled,
      "va-button--hover": hoverState.value,
      "va-button--focus": focusState.value,
      "va-button--large": props.size === "large",
      "va-button--small": props.size === "small",
      "va-button--normal": !props.size || props.size === "medium",
      "va-button--loading": props.loading,
      "va-button--block": props.block,
      "va-button--square": !props.rounded,
      "va-button--round": props.round || onlyIcon.value,
      "va-button--no-label": !isSlotContentPassed.value,
      "va-button--space-between-items": props.spaceBetweenItems
    }));
    const ariaLabelComputed = computed(() => onlyIcon.value ? props.icon || props.iconRight : void 0);
    const loaderSize = computed(() => {
      const size = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size ? `${+size[1] / 2}${size[2]}` : sizeComputed.value;
    });
    const computedStyle = computed(() => {
      const borderColor = props.outline ? colorComputed.value : "";
      let background = props.gradient ? getGradientBackground(colorComputed.value) : colorComputed.value;
      if (isTransparentBackground.value) {
        background = "var(--va-transparent)";
      }
      if (hoverState.value) {
        const alpha = props.outline ? -0.9 : -0.8;
        const lightness = 5;
        const color = isTransparentBackground.value ? shiftHSLAColor(colorComputed.value, { a: alpha }) : shiftHSLAColor(colorComputed.value, { l: lightness });
        background = props.gradient ? getGradientBackground(color) : color;
      }
      if (focusState.value) {
        const alpha = props.outline ? -0.8 : -0.7;
        const lightness = 10;
        const color = isTransparentBackground.value ? shiftHSLAColor(colorComputed.value, { a: alpha }) : shiftHSLAColor(colorComputed.value, { l: lightness });
        background = props.gradient ? getGradientBackground(color) : color;
      }
      return {
        color: textColorComputed.value,
        borderColor,
        background
      };
    });
    const focus = () => {
      var _a;
      return (_a = button.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      return (_a = button.value) == null ? void 0 : _a.blur();
    };
    return {
      button,
      tagComputed,
      hrefComputed,
      computedClass,
      computedStyle,
      computedType,
      textColorComputed,
      loaderSize,
      focusState,
      ariaLabelComputed,
      hoverState,
      focus,
      blur
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    class: ["va-button", _ctx.computedClass],
    ref: "button",
    "aria-live": "polite",
    "aria-disabled": _ctx.$props.disabled,
    "aria-label": _ctx.ariaLabelComputed,
    style: _ctx.computedStyle,
    disabled: _ctx.$props.disabled,
    type: _ctx.computedType,
    href: _ctx.hrefComputed,
    target: _ctx.$props.target,
    to: _ctx.$props.to,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    "active-class": _ctx.$props.activeClass,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass,
    tabindex: _ctx.loading ? -1 : 0
  }, toHandlers(_ctx.$attrs), {
    onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.focusState = true),
    onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.focusState = false),
    onMouseleave: _cache[2] || (_cache[2] = ($event) => _ctx.hoverState = false),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.hoverState = true)
  }), {
    default: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass(["va-button__content", { "va-button__content--loading": _ctx.loading }])
      }, [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-button__left-icon",
          name: _ctx.icon,
          size: _ctx.size,
          color: _ctx.textColorComputed
        }, null, 8, ["name", "size", "color"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.iconRight ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          class: "va-button__right-icon",
          name: _ctx.iconRight,
          size: _ctx.size,
          color: _ctx.textColorComputed
        }, null, 8, ["name", "size", "color"])) : createCommentVNode("", true)
      ], 2),
      _ctx.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
        key: 0,
        class: "va-button__loader",
        indeterminate: "",
        size: _ctx.loaderSize,
        color: _ctx.computedStyle.color,
        thickness: 0.15
      }, null, 8, ["size", "color", "thickness"])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["aria-disabled", "aria-label", "class", "style", "disabled", "type", "href", "target", "to", "replace", "append", "active-class", "exact", "exact-active-class", "tabindex"]);
}
var VaButton = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { VaButton as V };

import './VaButton.css';
//# sourceMappingURL=VaButton.js.map
