var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, computed, toRef, nextTick, openBlock, createElementBlock, normalizeClass, renderSlot, normalizeProps, guardReactiveProps, createBlock, Teleport, withModifiers, createCommentVNode } from "vue";
import { p as pick_1, k as kebabCase_1 } from "../../../vendor.js";
import { g as generateUniqueId } from "../../services/utils.js";
import { u as useBem } from "../../composables/useBem.js";
import { u as useClickOutside } from "../../composables/useClickOutside.js";
import "colortranslator";
import { u as useDebounceFn } from "../../composables/useDebounce.js";
import { u as useHTMLElement } from "../../composables/useHTMLElement.js";
import { p as placementsPositions, u as useDropdown } from "../../composables/useDropdown.js";
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
import { u as useDocument } from "../../composables/useDocument.js";
import { u as useIsMounted } from "../../composables/useIsMounted.js";
import { u as useAnchorSelector } from "./hooks/useAnchorSelector.js";
import { u as useCursorAnchor } from "./hooks/useCursorAnchor.js";
import { u as useKeyboardNavigation, a as useMouseNavigation } from "./hooks/useDropdownNavigation.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaDropdown_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaDropdown",
  props: __spreadProps(__spreadValues({}, useStatefulProps), {
    stateful: { default: true },
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    target: { type: String, default: void 0 },
    preventOverflow: { type: Boolean, default: false },
    keepAnchorWidth: { type: Boolean, default: false },
    isContentHoverable: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    offset: { type: [Array, Number], default: 0 },
    stickToEdges: { type: Boolean, default: false },
    autoPlacement: { type: Boolean, default: true },
    cursor: { type: Boolean, default: false },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    placement: {
      type: String,
      default: "auto",
      validator: (value) => placementsPositions.includes(value)
    },
    keyboardNavigation: { type: Boolean, default: false }
  }),
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "close", "open"],
  setup(props, { emit }) {
    const contentRef = shallowRef();
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const computedClass = useBem("va-dropdown", () => pick_1(props, ["disabled"]));
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onMouseEnter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseLeave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close && props.trigger !== "none") {
        valueComputed.value = false;
      }
    };
    const elRef = useHTMLElement("anchorRef");
    if (props.keyboardNavigation) {
      useKeyboardNavigation(elRef, valueComputed);
    }
    useMouseNavigation(elRef, {
      click(e) {
        if (props.trigger !== "click" && kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-click", props.closeOnAnchorClick, e);
        } else {
          if (props.trigger !== "click") {
            return;
          }
          valueComputed.value = true;
          emit("anchor-click", e);
        }
      },
      contextmenu(e) {
        if (kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        e.preventDefault();
        if (valueComputed.value) {
          emitAndClose("anchor-right-click", props.closeOnAnchorClick, e);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-right-click", e);
        }
      },
      dblclick(e) {
        if (props.trigger !== "dblclick" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-dblclick", props.closeOnAnchorClick, e);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-dblclick", e);
        }
      },
      mouseenter: onMouseEnter,
      mouseleave: onMouseLeave
    });
    const { anchorRef: computedAnchorRef } = useAnchorSelector(props);
    useClickOutside([computedAnchorRef, contentRef], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    const cursorAnchor = useCursorAnchor(computedAnchorRef, valueComputed);
    useDropdown(computed(() => props.cursor ? cursorAnchor.value : computedAnchorRef.value), contentRef, computed(() => ({
      placement: props.placement,
      keepAnchorWidth: props.keepAnchorWidth,
      offset: props.offset,
      stickToEdges: props.stickToEdges,
      autoPlacement: props.autoPlacement,
      root: teleportTargetComputed.value,
      viewport: targetComputed.value
    })));
    const idComputed = computed(generateUniqueId);
    const document = useDocument();
    const isPopoverFloating = computed(() => props.preventOverflow || props.cursor);
    const targetComputed = computed(() => {
      var _a, _b, _c;
      const target = (_a = document.value) == null ? void 0 : _a.querySelector(props.target || "body");
      if (!target) {
        return (_b = document.value) == null ? void 0 : _b.body;
      }
      if (computedAnchorRef.value && !target.contains(computedAnchorRef.value)) {
        return (_c = document.value) == null ? void 0 : _c.body;
      }
      return target;
    });
    const teleportTargetComputed = computed(() => {
      if (!isPopoverFloating.value) {
        return elRef.value;
      }
      return targetComputed.value;
    });
    const teleportDisabled = computed(() => props.disabled || !isPopoverFloating.value);
    return {
      teleportTargetComputed,
      teleportDisabled,
      isMounted: useIsMounted(),
      anchorRef: computedAnchorRef,
      valueComputed,
      contentRef,
      computedClass,
      idComputed,
      emitAndClose,
      onMouseEnter,
      onMouseLeave,
      hide: () => {
        valueComputed.value = false;
      },
      show: () => {
        valueComputed.value = true;
      }
    };
  }
});
const _hoisted_1 = ["aria-disabled", "aria-expanded", "aria-controls"];
const _hoisted_2 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-dropdown", _ctx.computedClass]),
    ref: "anchorRef",
    role: "button",
    "aria-label": "toggle dropdown",
    "aria-disabled": _ctx.$props.disabled,
    "aria-expanded": !!_ctx.valueComputed,
    "aria-controls": _ctx.idComputed
  }, [
    renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show }))),
    _ctx.isMounted ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.teleportTargetComputed,
      disabled: _ctx.teleportDisabled
    }, [
      _ctx.valueComputed ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "contentRef",
        class: "va-dropdown__content-wrapper",
        id: _ctx.idComputed,
        onMouseover: _cache[0] || (_cache[0] = ($event) => _ctx.$props.isContentHoverable && _ctx.onMouseEnter()),
        onMouseout: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.emitAndClose("content-click", _ctx.closeOnContentClick), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show })))
      ], 40, _hoisted_2)) : createCommentVNode("", true)
    ], 8, ["to", "disabled"])) : createCommentVNode("", true)
  ], 10, _hoisted_1);
}
var _VaDropdown = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaDropdown as _ };

import './VaDropdown.css';
//# sourceMappingURL=VaDropdown.js.map
