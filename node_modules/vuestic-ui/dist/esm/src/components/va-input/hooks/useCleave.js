var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { ref, onMounted, onBeforeUnmount, watch, computed } from "vue";
import Cleave from "cleave.js";
const DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
const useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true },
  modelValue: { type: String }
};
const useCleave = (element, props, emit) => {
  const cleave = ref();
  const getMask = (mask) => {
    if (typeof mask === "string") {
      return DEFAULT_MASK_TOKENS[mask] ? __spreadValues({}, DEFAULT_MASK_TOKENS[mask]) : {};
    }
    return __spreadValues({}, mask);
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const initCleave = () => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    cleave.value = new Cleave(element.value, getMask(props.mask));
  };
  onMounted(() => {
    initCleave();
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  watch(() => [element.value, props.mask], () => {
    initCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return props.modelValue;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (props.mask !== "string" && !Object.keys(props.mask).length) {
      emit("update:modelValue", value);
      return;
    }
    if (cleave.value) {
      cleave.value.setRawValue(value);
      if (props.returnRaw) {
        emit("update:modelValue", cleave.value.getRawValue());
        return;
      }
    }
    emit("update:modelValue", value);
  };
  return {
    cleave,
    computedValue,
    onInput
  };
};
export { useCleave as a, useCleaveProps as u };
//# sourceMappingURL=useCleave.js.map
