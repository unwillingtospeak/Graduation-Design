var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, computed, toRefs, resolveComponent, openBlock, createBlock, mergeProps, createSlots, withCtx, withModifiers, withKeys, createCommentVNode, renderSlot, normalizeProps, guardReactiveProps, createElementBlock, renderList } from "vue";
import { o as omit_1, p as pick_1 } from "../../../vendor.js";
import { e as extractComponentProps, f as filterComponentProps } from "../../utils/child-props.js";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.js";
import "colortranslator";
import { u as useEmitProxy } from "../../composables/useEmitProxy.js";
import { u as useFocusDeep } from "../../composables/useFocusDeep.js";
import { u as useFormProps } from "../../composables/useForm.js";
import "../../composables/useDropdown.js";
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from "../../composables/useValidation.js";
import { u as useCleaveProps, a as useCleave } from "./hooks/useCleave.js";
import { V as VaInputWrapper } from "./components/VaInputWrapper/VaInputWrapper.js";
import { V as VaTextarea } from "./components/VaTextarea/VaTextarea.js";
import { V as VaIcon } from "../va-icon/VaIcon.js";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
const VaTextareaProps = extractComponentProps(VaTextarea);
const { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(["change", "keyup", "keypress", "keydown", "focus", "blur"]);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
const _sfc_main = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaTextarea, VaIcon },
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, useFormProps), useValidationProps), useClearableProps), useCleaveProps), VaTextareaProps), {
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    modelValue: { type: [String, Number], default: "" },
    label: { type: String, default: "" },
    type: { type: String, default: "text" },
    loading: { type: Boolean, default: false },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    ariaLabel: { type: String, default: void 0 },
    counter: { type: Boolean, default: false },
    maxLength: { type: Number, default: void 0 },
    color: { type: String, default: "primary" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  }),
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits()
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const isFocused = useFocusDeep();
    const reset = () => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
    };
    const focus = () => {
      var _a;
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = input.value) == null ? void 0 : _a.blur();
    };
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes
    } = useValidation(props, emit, reset, focus);
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const computedCleaveTarget = computed(() => props.type === "textarea" ? void 0 : input.value);
    const { computedValue, onInput } = useCleave(computedCleaveTarget, props, emit);
    const inputListeners = createInputListeners(emit);
    const onFocus = (e) => {
      inputListeners.onFocus(e);
      validationListeners.onFocus();
    };
    const onBlur = (e) => {
      inputListeners.onBlur(e);
      validationListeners.onBlur();
    };
    const inputEvents = __spreadProps(__spreadValues({}, inputListeners), {
      onFocus,
      onBlur,
      onInput
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => __spreadValues(__spreadValues({
      ariaLabel: props.ariaLabel || props.label,
      ariaRequired: props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      ariaDisabled: props.disabled,
      ariaReadonly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    const computedInputAttributes = computed(() => __spreadValues(__spreadValues({}, computedChildAttributes.value), pick_1(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode"])));
    const valueLengthComputed = computed(() => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0);
    return {
      input,
      inputEvents,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      textareaProps: filterComponentProps(props, VaTextareaProps),
      computedValue,
      tabIndexComputed,
      computedError,
      computedErrorMessages,
      isFocused,
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      reset,
      focus,
      blur
    };
  }
});
const _hoisted_1 = ["value"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaTextarea = resolveComponent("VaTextarea");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps(_ctx.fieldListeners, {
    class: ["va-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style,
    color: _ctx.$props.color,
    readonly: _ctx.$props.readonly,
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    label: _ctx.$props.label,
    bordered: _ctx.$props.bordered,
    outline: _ctx.$props.outline,
    requiredMark: _ctx.$props.requiredMark,
    focused: _ctx.isFocused,
    "counter-value": _ctx.valueLengthComputed,
    "max-length": _ctx.$props.maxLength,
    onClick: _ctx.focus
  }), createSlots({
    icon: withCtx((slotScope) => [
      _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
        key: 0,
        role: "button",
        "aria-hidden": "false",
        "aria-label": "reset",
        class: "va-input__icons__reset",
        tabindex: _ctx.tabIndexComputed
      }, _ctx.clearIconProps, {
        onClick: withModifiers(_ctx.reset, ["stop"]),
        onKeydown: [
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
        ]
      }), null, 16, ["tabindex", "onClick", "onKeydown"])) : createCommentVNode("", true),
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
        key: 1,
        color: _ctx.$props.color,
        size: "small",
        name: "loop",
        spin: "counter-clockwise"
      }, null, 8, ["color"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      _ctx.type === "textarea" && !_ctx.$slots.content ? (openBlock(), createBlock(_component_VaTextarea, mergeProps({
        key: 0,
        ref: "input"
      }, __spreadValues(__spreadValues(__spreadValues({}, _ctx.computedChildAttributes), _ctx.textareaProps), _ctx.inputEvents), { class: "va-input__content__input" }), null, 16)) : !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "va-input__content__input"
      }, __spreadValues(__spreadValues({}, _ctx.computedInputAttributes), _ctx.inputEvents), { value: _ctx.computedValue }), null, 16, _hoisted_1)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      };
    })
  ]), 1040, ["class", "style", "color", "readonly", "disabled", "success", "messages", "error", "error-messages", "error-count", "label", "bordered", "outline", "requiredMark", "focused", "counter-value", "max-length", "onClick"]);
}
var _VaInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaInput as _ };
//# sourceMappingURL=VaInput.js.map
