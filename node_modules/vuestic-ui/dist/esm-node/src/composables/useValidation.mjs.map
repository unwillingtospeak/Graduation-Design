{"version":3,"file":"useValidation.mjs","sources":["../../../../src/composables/useValidation.ts"],"sourcesContent":["import { inject, onBeforeUnmount, onMounted, PropType, watch, ExtractPropTypes, computed } from 'vue'\nimport flatten from 'lodash/flatten.js'\nimport isFunction from 'lodash/isFunction.js'\nimport isString from 'lodash/isString.js'\n\nimport { useSyncProp } from './useSyncProp'\nimport { useFocus } from './useFocus'\nimport { FormServiceKey } from '../components/va-form/consts'\n\ntype ValidationRule<V extends any = any> = ((v: V) => any | string)\n\nconst normalizeValidationRules = (rules: string | ValidationRule[] = [], callArguments: unknown = null) => {\n  if (isString(rules)) { rules = [rules] as any }\n\n  return (rules as ValidationRule[])\n    .map((rule) => isFunction(rule) ? rule(callArguments) : rule)\n}\n\nexport const useValidationProps = {\n  modelValue: { required: false },\n  error: { type: Boolean, default: undefined },\n  errorMessages: { type: [Array, String] as PropType<string[] | string>, default: undefined },\n  errorCount: { type: [String, Number], default: 1 },\n  rules: { type: Array as PropType<ValidationRule<any>[]>, default: () => [] as any },\n  success: { type: Boolean, default: false },\n  messages: { type: [Array, String] as PropType<string[] | string>, default: () => [] },\n  immediateValidation: { type: Boolean, default: false },\n}\n\nexport type ValidationProps<V extends any> = typeof useValidationProps & {\n  modelValue: { type: PropType<V> }\n  rules: { type: PropType<ValidationRule<V>[]> }\n}\n\nexport const useValidationEmits = ['update:error', 'update:errorMessages']\n\nexport const useValidation = <V, P extends ExtractPropTypes<typeof useValidationProps>>(\n  props: P,\n  emit: (event: any, ...args: any[]) => void,\n  reset: () => any,\n  focus: () => any,\n) => {\n  const { isFocused, onFocus, onBlur } = useFocus()\n\n  const [computedError] = useSyncProp('error', props, emit, false)\n  const [computedErrorMessages] = useSyncProp('errorMessages', props, emit, [] as string[])\n\n  const resetValidation = () => {\n    computedError.value = false\n    computedErrorMessages.value = []\n  }\n\n  const validate = (): boolean => {\n    if (!props.rules || !props.rules.length) {\n      return true\n    }\n\n    let error = false\n    let errorMessages: string[] = []\n\n    const rules = flatten(props.rules)\n\n    normalizeValidationRules(rules, props.modelValue)\n      .forEach((validationResult: boolean | string) => {\n        if (isString(validationResult)) {\n          errorMessages = [...errorMessages, validationResult]\n          error = true\n        } else if (validationResult === false) {\n          error = true\n        }\n      })\n\n    computedErrorMessages.value = errorMessages\n    computedError.value = error\n\n    return !error\n  }\n\n  watch(isFocused, (newVal) => !newVal && validate())\n\n  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation })\n\n  const context = {\n    resetValidation,\n    focus,\n    validate,\n    reset,\n    hasError: () => computedError.value,\n  }\n\n  const form = inject(FormServiceKey, undefined)\n\n  const validationAriaAttributes = computed(() => ({\n    'aria-invalid': !!computedErrorMessages.value.length,\n    'aria-errormessage': typeof computedErrorMessages.value === 'string'\n      ? computedErrorMessages.value\n      : computedErrorMessages.value.join(', '),\n  }))\n\n  onMounted(() => {\n    form?.onChildMounted(context as any)\n  })\n\n  onBeforeUnmount(() => {\n    form?.onChildUnmounted(context as any)\n  })\n\n  return {\n    computedError,\n    computedErrorMessages,\n    listeners: { onFocus, onBlur },\n    validate,\n    resetValidation,\n    validationAriaAttributes,\n  }\n}\n"],"names":["useValidationProps","modelValue","required","error","type","Boolean","default","errorMessages","Array","String","errorCount","Number","rules","success","messages","immediateValidation","useValidationEmits","useValidation","props","emit","reset","focus","isFocused","onFocus","onBlur","useFocus","computedError","useSyncProp","computedErrorMessages","resetValidation","value","validate","length","callArguments","isString","map","rule","isFunction","normalizeValidationRules","flatten","forEach","validationResult","watch","newVal","immediate","context","hasError","form","inject","FormServiceKey","validationAriaAttributes","computed","join","onMounted","onChildMounted","onBeforeUnmount","onChildUnmounted","listeners"],"mappings":"2QAWA,MAOaA,EAAqB,CAChCC,WAAY,CAAEC,UAAU,GACxBC,MAAO,CAAEC,KAAMC,QAASC,aAAS,GACjCC,cAAe,CAAEH,KAAM,CAACI,MAAOC,QAAwCH,aAAS,GAChFI,WAAY,CAAEN,KAAM,CAACK,OAAQE,QAASL,QAAS,GAC/CM,MAAO,CAAER,KAAMI,MAA0CF,QAAS,IAAM,IACxEO,QAAS,CAAET,KAAMC,QAASC,SAAS,GACnCQ,SAAU,CAAEV,KAAM,CAACI,MAAOC,QAAwCH,QAAS,IAAM,IACjFS,oBAAqB,CAAEX,KAAMC,QAASC,SAAS,IAQpCU,EAAqB,CAAC,eAAgB,wBAEtCC,cAAgB,CAC3BC,EACAC,EACAC,EACAC,KAEA,MAAMC,UAAEA,EAAAC,QAAWA,EAASC,OAAAA,GAAWC,KAEhCC,GAAiBC,EAAY,QAAST,EAAOC,GAAM,IACnDS,GAAyBD,EAAY,gBAAiBT,EAAOC,EAAM,IAEpEU,gBAAkB,KACtBH,EAAcI,OAAQ,EACtBF,EAAsBE,MAAQ,IAG1BC,SAAW,KACf,IAAKb,EAAMN,QAAUM,EAAMN,MAAMoB,OACxB,OAAA,EAGT,IAAI7B,GAAQ,EACRI,EAA0B,GAiB9B,MAhE6B,EAACK,EAAmC,GAAIqB,EAAyB,QAC5FC,EAAStB,KAAUA,EAAQ,CAACA,IAExBA,EACLuB,KAAKC,GAASC,EAAWD,GAAQA,EAAKH,GAAiBG,KA+CxDE,CAFcC,EAAQrB,EAAMN,OAEIM,EAAMjB,YACnCuC,SAASC,IACJP,EAASO,IACKlC,EAAA,IAAIA,EAAekC,GAC3BtC,GAAA,IACsB,IAArBsC,IACDtC,GAAA,MAIdyB,EAAsBE,MAAQvB,EAC9BmB,EAAcI,MAAQ3B,GAEdA,GAGVuC,EAAMpB,GAAYqB,IAAYA,GAAUZ,aAElCW,GAAA,IAAMxB,EAAMjB,aAAY,IAAM8B,YAAY,CAAEa,UAAW1B,EAAMH,sBAEnE,MAAM8B,EAAU,CACdhB,gBAAAA,gBACAR,MAAAA,EACAU,SAAAA,SACAX,MAAAA,EACA0B,SAAU,IAAMpB,EAAcI,OAG1BiB,EAAOC,EAAOC,OAAgB,GAE9BC,EAA2BC,GAAS,KAAO,CAC/C,iBAAkBvB,EAAsBE,MAAME,OAC9C,oBAA4D,iBAAhCJ,EAAsBE,MAC9CF,EAAsBE,MACtBF,EAAsBE,MAAMsB,KAAK,UAWhC,OARPC,GAAU,KACR,MAAAN,GAAAA,EAAMO,eAAeT,MAGvBU,GAAgB,KACd,MAAAR,GAAAA,EAAMS,iBAAiBX,MAGlB,CACLnB,cAAAA,EACAE,sBAAAA,EACA6B,UAAW,CAAElC,QAAAA,EAASC,OAAAA,GACtBO,SAAAA,SACAF,gBAAAA,gBACAqB,yBAAAA"}