{"version":3,"file":"useDropdown.mjs","sources":["../../../../src/composables/useDropdown.ts"],"sourcesContent":["import { computed, Ref, unref, watch, watchEffect, watchPostEffect } from 'vue'\n\nimport { mapObject } from '../utils/map-object'\nimport { useDomRect } from './useDomRect'\nimport { useClientOnly } from './useClientOnly'\n\nexport type PlacementPosition = 'top' | 'bottom' | 'left' | 'right'\nexport type PlacementAlignment = 'start' | 'end' | 'center'\nexport type Placement = PlacementPosition | 'auto' | `${PlacementPosition}-${PlacementAlignment}`\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nexport const placementsPositions = ['top', 'bottom', 'left', 'right']\n  .reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ['auto'] as string[])\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parsePlacement = (placement: Placement) => {\n  let [position, align] = placement.split('-') as [PlacementPosition | 'auto', PlacementAlignment | undefined]\n  if (position === 'auto') {\n    position = 'bottom'\n  }\n\n  return { position, align: align || 'center' }\n}\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (placement: Placement, anchor: DOMRect, content: DOMRect) => {\n  const { position, align } = parsePlacement(placement)\n\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (placement: Placement, offset: Offset): Coords => {\n  const { position } = parsePlacement(placement)\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, viewport: DOMRect) => {\n  const xMax = viewport.right\n  const yMax = viewport.bottom\n  const xMin = viewport.left\n  const yMin = viewport.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, viewport: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (placement: Placement, coords: Coords, content: DOMRect, viewport: DOMRect): Placement => {\n  const { position, align } = parsePlacement(placement)\n  const overflow = calculateContentOverflow(coords, content, viewport)\n\n  const newPlacements = {\n    top: ['bottom', align].join('-') as Placement,\n    bottom: ['top', align].join('-') as Placement,\n    right: ['left', align].join('-') as Placement,\n    left: ['right', align].join('-') as Placement,\n  }\n\n  return overflow[position] ? newPlacements[position] : placement\n}\n\nconst findFirstRelativeParent = (el: Element | null) => {\n  while (el) {\n    if (window.getComputedStyle(el).position === 'relative') { return el }\n    el = el.parentElement\n  }\n\n  return document.body\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  placement: Placement,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string | HTMLElement,\n  viewport?: HTMLElement,\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param options make options reactive if you want popover to react on options change.\n */\nexport const useDropdown = (\n  anchorRef: Ref<HTMLElement | undefined>,\n  contentRef: Ref<HTMLElement | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n) => {\n  const documentRef = useClientOnly(() => document)\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) {\n      let el\n      if (typeof root === 'string') {\n        el = documentRef.value.querySelector(root)\n      } else {\n        el = root\n      }\n      if (!el) { return documentRef.value.body }\n      return findFirstRelativeParent(el)\n    }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const css = {\n    width: 'max-content',\n    position: 'absolute',\n  }\n\n  watchPostEffect(() => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    const { placement, offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value)\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(placement, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n    const viewportRect = unref(options).viewport?.getBoundingClientRect() ?? rootRect\n\n    if (autoPlacement) {\n      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect)\n      if (newPlacement !== placement) {\n        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPlacement, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect)\n    }\n\n    coords.x -= rootRect.x\n    coords.y -= rootRect.y\n\n    if (contentRef.value) {\n      let widthCss = {}\n      if (keepAnchorWidth) {\n        const { width } = anchorDomRect.value\n        widthCss = { width: `${width}px`, maxWidth: `${width}px` }\n      }\n\n      Object.assign(contentRef.value.style, {\n        ...css,\n        ...coordsToCss(coords),\n        ...widthCss,\n      })\n    }\n  })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n"],"names":["placementsPositions","reduce","acc","position","parsePlacement","placement","align","split","calculateContentAlignment","anchorStart","anchorSize","contentSize","calculateContentCoords","anchor","content","alignmentX","left","width","alignmentY","top","height","x","y","right","bottom","calculateOffsetCoords","offset","main","cross","Array","isArray","parseOffset","calculateContentOverflow","coords","viewport","xMax","yMax","xMin","yMin","Math","max","clamp","min","v","useDropdown","anchorRef","contentRef","options","documentRef","useClientOnly","document","rootRef","computed","value","root","unref","el","querySelector","window","getComputedStyle","parentElement","body","findFirstRelativeParent","domRect","anchorDomRect","useDomRect","contentDomRect","css","watchPostEffect","keepAnchorWidth","autoPlacement","stickToEdges","offsetCoords","mapObject","c","key","rootRect","getBoundingClientRect","viewportRect","_b","_a","newPlacement","overflow","newPlacements","join","getAutoPlacement","offsetX","offsetY","calculateClipToEdge","widthCss","maxWidth","Object","assign","style","__spreadValues","coordsToCss"],"mappings":"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"}