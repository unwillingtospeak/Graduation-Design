{"version":3,"file":"VaAffix-utils.mjs","sources":["../../../../../src/components/va-affix/VaAffix-utils.ts"],"sourcesContent":["import throttle from 'lodash/throttle.js'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: HTMLElement | undefined;\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: DOMRect | undefined;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  if (!element) { return }\n\n  const isInitialCall = !eventName\n  const coordinates = element.getBoundingClientRect()\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  const nextState = isInitialCall && initialPosition\n    ? computeAffixedState({ coordinates: initialPosition, ...options })\n    : computeAffixedState({ coordinates, ...options })\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n"],"names":["getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","isInitialCall","options","nextState","__spreadValues","prevState","checkAffixedStateChange","currentState","width","__spreadProps","useCaptureDefault","useEventsHandlerWithThrottle","events","handler","useCapture","wait","clearHandlersArray","map","_handler","throttle","event","addEventListener","removeEventListener","forEach","clear"],"mappings":"wgBAoBmC,SAAAA,kBACjC,OAAOC,SAASC,gBAAgBC,cAC9BC,OAAOC,aACPJ,SAASK,KAAKH,aAGmB,SAAAI,qBAAAC,YACnCA,EAAAC,UACAA,EAAAC,aACAA,EAAAC,OACAA,IAEA,IAAIC,GAAe,EACfC,GAAkB,EAEtB,MAAMC,EAAed,kBAEjB,GAAa,MAAbS,GAAqBK,EACvB,GAAIH,IAAWP,OACbQ,EAAeJ,EAAYO,KAAON,MAC7B,CACC,MAAAM,IAAEA,GAASJ,EAAuBK,wBACzBJ,EAAAJ,EAAYO,IAAMA,GAAON,EAIxC,GAAgB,MAAhBC,GAAwBI,EAC1B,GAAIH,IAAWP,OACKS,EAAAL,EAAYS,QAAUH,EAAeJ,MAClD,CACC,MAAAO,OAAEA,GAAYN,EAAuBK,wBACzBH,EAAAI,EAAST,EAAYS,QAAUP,EAI9C,MAAA,CACLE,aAAAA,EACAC,gBAAAA,GAmBG,SAAAK,qBAA+BC,EAA0BC,GAC9D,MAAMT,OAAEA,EAAQU,QAAAA,EAAAZ,UAASA,eAAWC,EAAcY,SAAAA,EAAAC,SAAUA,kBAAUC,GAAoBJ,EAE1F,IAAKC,EAAW,OAEhB,MAAMI,GAAiBN,EACjBX,EAAca,EAAQL,wBACtBU,EAAU,CACdhB,aAAAA,EACAD,UAAAA,EACAE,OAAAA,GAGIgB,EACFpB,oBAAoBqB,eADNH,GAAiBD,EACT,CAAAhB,YAAagB,GACb,CAAAhB,YAAAA,GADiCkB,IAGrDG,EAAYN,KAhCpB,SAAAO,wBAAkCC,EAAqBJ,GACrD,OAAOI,EAAanB,eAAiBe,EAAUf,cAC7CmB,EAAalB,kBAAoBc,EAAUd,gBAgCzCiB,CAAwBD,EAAWF,GAE5BE,EAAUG,QAAUxB,EAAYwB,OACzCV,EAASW,gCAAKJ,GAAL,CAAgBG,MAAOxB,EAAYwB,SAF5CV,EAASW,gCAAKN,GAAL,CAAgBK,MAAOxB,EAAYwB,SAMhD,SAAAE,kBAA4Bf,GAG1B,MAAqB,WAAdA,EASF,SAAAgB,6BAAuCC,GAAkBC,QAC9DA,EAAAC,WACAA,EAAaJ,kBAAAK,KACbA,EAAO,KAED,MAAAC,EAAqBJ,EAAOK,KAAiBtB,IAC3C,MAAAuB,EAAWC,GAAUC,GAAiBP,EAAQlB,EAAWyB,IAAQL,GAIvE,OAFAnC,OAAOyC,iBAAiB1B,EAAWuB,EAAUJ,EAAWnB,IAEjD,IAAMf,OAAO0C,oBAAoB3B,EAAWuB,EAAUJ,EAAWnB,OAG1E,MAAO,IAAMqB,EAAmBO,SAAQC,GAASA"}