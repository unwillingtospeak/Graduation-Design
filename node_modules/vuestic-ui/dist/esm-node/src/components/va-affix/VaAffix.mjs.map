{"version":3,"file":"VaAffix.mjs","sources":["../../../../../src/components/va-affix/VaAffix.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, nextTick, onMounted, onBeforeUnmount, shallowRef } from 'vue'\nimport noop from 'lodash/noop.js'\n\nimport { getWindow } from '../../utils/ssr-utils'\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number, default: undefined },\n    offsetBottom: { type: Number, default: undefined },\n    target: { type: [Object, Function] as PropType<HTMLElement | Window | (() => HTMLElement | Window)>, default: getWindow },\n  },\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n\n    const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target)\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state = ref<State>({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (!target) {\n        return 0\n      }\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (!target) { return 0 }\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }))\n\n    const initialPosition = ref<DOMRect>()\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n\n    onMounted(() => {\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      const events = ['scroll', 'resize']\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    onBeforeUnmount(clearEventListeners)\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n"],"names":["_sfc_main","defineComponent","name","emits","props","offsetTop","type","Number","default","offsetBottom","target","Object","Function","getWindow","setup","emit","element","shallowRef","getTargetElement","isAffixed","computed","state","value","isTopAffixed","isBottomAffixed","ref","getState","setState","newState","calculateTop","Window","top","getBoundingClientRect","calculateBottom","bottom","borderTopWidth","borderBottomWidth","getComputedStyle","offsetHeight","clientHeight","scrollBarHeight","parseInt","getWindowHeight","convertToPixels","calculate","result","computedClass","computedStyle","width","initialPosition","throttledEventHandler","eventName","event","context","handleThrottledEvent","clearEventListeners","noop","onMounted","_a","useEventsHandlerWithThrottle","handler","nextTick","onBeforeUnmount","class","_openBlock","_createElementBlock","_hoisted_1","_createElementVNode","style","_normalizeStyle","_ctx","_renderSlot","$slots","key","_normalizeClass","_createCommentVNode"],"mappings":"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"}