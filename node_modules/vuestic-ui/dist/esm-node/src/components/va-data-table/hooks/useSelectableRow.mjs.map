{"version":3,"file":"useSelectableRow.mjs","sources":["../../../../../../src/components/va-data-table/hooks/useSelectableRow.ts"],"sourcesContent":["import { Ref, computed, watch, ref } from 'vue'\n\nimport { getItemKey } from './useRows'\n\nimport type { DataTableRow, DataTableItem, DataTableSelectMode, DataTableItemKey } from '../types'\n\ninterface useSelectableProps {\n  modelValue: (DataTableItem | DataTableItemKey)[] | undefined // selectedItems\n  selectable: boolean\n  selectMode: DataTableSelectMode\n  itemsTrackBy: string | ((item: DataTableItem) => any)\n  [prop: string]: unknown\n}\nexport type TEmits = 'update:modelValue' | 'selectionChange'\nexport type TSelectionChange = {\n  currentSelectedItems: (DataTableItem | DataTableItemKey)[],\n  previousSelectedItems: (DataTableItem | DataTableItemKey)[],\n}\nexport type TSelectableEmits = (event: TEmits, arg: (DataTableItem | DataTableItemKey)[] | TSelectionChange) => void\n\nexport default function useSelectableRow (\n  paginatedRows: Ref<DataTableRow[]>,\n  props: useSelectableProps,\n  emit: TSelectableEmits,\n) {\n  const selectedItemsFallback = ref<(DataTableItem | DataTableItemKey)[]>([])\n\n  const selectedItemsSync = computed<(DataTableItem | DataTableItemKey)[]>({\n    get () {\n      if (props.modelValue === undefined) {\n        return selectedItemsFallback.value\n      } else {\n        return props.modelValue\n      }\n    },\n\n    set (modelValue) {\n      if (props.modelValue === undefined) {\n        selectedItemsFallback.value = modelValue\n      }\n\n      emit('update:modelValue', modelValue)\n    },\n  })\n\n  const prevSelectedRowIndex = ref(-1)\n\n  // clear all the selected rows when the `select-mode`'s value changes from multiple to single\n  // (though it's safe enough to leave a selected item when changing from single to multiple\n  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {\n    if (newSelectMode === 'single' && oldSelectMode === 'multiple') {\n      selectedItemsSync.value = []\n      setPrevSelectedRowIndex(-1)\n    }\n  })\n\n  // watch for rows changes (happens when filtering is applied e.g.)\n  watch(paginatedRows, () => { setPrevSelectedRowIndex(-1) })\n\n  // emit the \"selection-change\" event each time the selection changes\n  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {\n    emit('selectionChange', {\n      currentSelectedItems,\n      previousSelectedItems,\n    })\n  }, { immediate: true })\n\n  // if user provide `props.itemsTrackBy !== ''` than `selectedItemsSync` and `props.modelValue`\n  // would be the array with keys (received from `props.itemsTrackBy`)\n  // else they would be the array with source (`DataTableItem` type)\n  const getKey = (source: DataTableItem) => getItemKey(source, props.itemsTrackBy)\n\n  const noRowsSelected = computed(() => (\n    !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source)))\n  ))\n\n  const allRowsSelected = computed(() => {\n    if (paginatedRows.value.length === 0) { return false }\n\n    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)))\n  })\n\n  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value)\n\n  function isRowSelected (row: DataTableRow) {\n    return selectedItemsSync.value.includes(getKey(row.source))\n  }\n\n  function selectAllRows () {\n    selectedItemsSync.value = [...new Set([\n      ...selectedItemsSync.value,\n      ...paginatedRows.value.map(row => getKey(row.source)),\n    ])]\n  }\n\n  function unselectAllRows () {\n    const paginatedRowsKeys = paginatedRows.value.map(row => getKey(row.source))\n\n    selectedItemsSync.value = selectedItemsSync.value\n      .filter((item) => !paginatedRowsKeys.includes(item))\n  }\n\n  // The one calling this function must guarantee that the row isn't already selected\n  function selectRow (row: DataTableRow) {\n    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)]\n  }\n\n  function selectOnlyRow (row: DataTableRow) {\n    selectedItemsSync.value = [getKey(row.source)]\n  }\n\n  // The one calling this function must guarantee that the row is selected\n  function unselectRow (row: DataTableRow) {\n    const index = selectedItemsSync.value.findIndex(item => item === getKey(row.source))\n\n    selectedItemsSync.value = [\n      ...selectedItemsSync.value.slice(0, index),\n      ...selectedItemsSync.value.slice(index + 1),\n    ]\n  }\n\n  function setPrevSelectedRowIndex (rowInitialIndex: number) {\n    if (rowInitialIndex === -1) {\n      prevSelectedRowIndex.value = -1\n    } else {\n      const prevSelectedRow = paginatedRows.value.find(row => row.initialIndex === rowInitialIndex)\n\n      prevSelectedRow\n        ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow)\n        : prevSelectedRowIndex.value = -1\n    }\n  }\n\n  function getRowsToSelect (targetIndex: number) {\n    let start\n    let end\n\n    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {\n      start = Math.min(prevSelectedRowIndex.value, targetIndex)\n      end = Math.max(prevSelectedRowIndex.value, targetIndex)\n    } else {\n      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex)\n      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex)\n    }\n\n    return paginatedRows.value.slice(start, end + 1)\n  }\n\n  function mergeSelection (rowsToSelect: DataTableRow[]) {\n    const rowsToSelectedItems = rowsToSelect.map(row => getKey(row.source))\n\n    if (noRowsSelected.value) {\n      selectedItemsSync.value = rowsToSelectedItems\n      return\n    }\n\n    const isInternalSelection = rowsToSelectedItems.every(item => selectedItemsSync.value.includes(item))\n\n    if (isInternalSelection) {\n      selectedItemsSync.value = selectedItemsSync.value.filter(item => !rowsToSelectedItems.includes(item))\n      return\n    }\n\n    selectedItemsSync.value = [...new Set([\n      ...selectedItemsSync.value,\n      ...rowsToSelectedItems,\n    ])]\n  }\n\n  function toggleRowSelection (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    if (isRowSelected(row)) {\n      unselectRow(row)\n      props.selectMode === 'single' ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex)\n    } else {\n      props.selectMode === 'single' ? selectOnlyRow(row) : selectRow(row)\n      setPrevSelectedRowIndex(row.initialIndex)\n    }\n  }\n\n  function ctrlSelectRow (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    toggleRowSelection(row)\n  }\n\n  function shiftSelectRows (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    if (props.selectMode === 'single' || prevSelectedRowIndex.value === -1) {\n      return toggleRowSelection(row)\n    }\n\n    const targetIndex = paginatedRows.value.indexOf(row)\n    mergeSelection(getRowsToSelect(targetIndex))\n    setPrevSelectedRowIndex(-1)\n  }\n\n  function toggleBulkSelection () {\n    if (allRowsSelected.value) {\n      unselectAllRows()\n    } else {\n      selectAllRows()\n    }\n\n    setPrevSelectedRowIndex(-1)\n  }\n\n  return {\n    ctrlSelectRow,\n    shiftSelectRows,\n    toggleRowSelection,\n    toggleBulkSelection,\n    isRowSelected,\n    noRowsSelected,\n    severalRowsSelected,\n    allRowsSelected,\n  }\n}\n"],"names":["useSelectableRow","paginatedRows","props","emit","selectedItemsFallback","ref","selectedItemsSync","computed","get","modelValue","value","set","prevSelectedRowIndex","watch","selectMode","newSelectMode","oldSelectMode","setPrevSelectedRowIndex","currentSelectedItems","previousSelectedItems","immediate","getKey","source","getItemKey","itemsTrackBy","noRowsSelected","some","includes","allRowsSelected","length","every","severalRowsSelected","isRowSelected","row","rowInitialIndex","prevSelectedRow","find","initialIndex","indexOf","toggleRowSelection","selectable","unselectRow","index","findIndex","item","slice","selectOnlyRow","selectRow","ctrlSelectRow","shiftSelectRows","mergeSelection","rowsToSelect","rowsToSelectedItems","map","filter","Set","getRowsToSelect","targetIndex","start","end","Math","min","max","toggleBulkSelection","unselectAllRows","paginatedRowsKeys","selectAllRows"],"mappings":"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"}