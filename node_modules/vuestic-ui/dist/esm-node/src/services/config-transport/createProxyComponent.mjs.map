{"version":3,"file":"createProxyComponent.mjs","sources":["../../../../../src/services/config-transport/createProxyComponent.ts"],"sourcesContent":["import { getCurrentInstance, ComponentInternalInstance, DefineComponent, SetupContext, Ref, shallowReadonly } from 'vue'\nimport { useComponentConfigProps } from '../component-config/component-config'\n\n/** Compiled and reactive props. By default they passed to setup fn */\ntype Props = Record<string, unknown>;\n/** Raw props */\ntype RawProps = Record<string, unknown>;\n\n/**\n * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.\n * @returns new props object, where some props replaced with props from config.\n */\nconst createPropsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  /**\n   * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.\n   * It is a default props that passed to setup function.\n   */\n  const instanceProps: Props = instance.props\n\n  return new Proxy(instanceProps, {\n    get: (target, key: string) => {\n      /**\n       * Props passed to VNode. Not compiled at all and not reactive.\n       * VNode props contained only props passed from parent.\n       */\n      const incommingProps: RawProps = instance.vnode.props || {}\n\n      /**\n       * Make sure to access both original and from config prop in get.\n       * Since instanceProps and propsFromConfig both are reactive, we need to know that both of\n       * this objects are dependency of effect where proxy is used.\n       * If original prop will not be accessed vue will not track reactivity for original props object.\n       */\n      const originalProp = target[key]\n      const propFromConfig = propsFromConfig.value[key]\n\n      // Return prop from config only if user didn't pass props manually\n      if (incommingProps[key] === undefined && propFromConfig !== undefined) {\n        return propFromConfig\n      }\n\n      return originalProp\n    },\n  })\n}\n\n/**\n * Patch instance props with Proxy.\n * This will change props object during render and in Devtools.\n */\nconst patchInstanceProps = (instance: ComponentInternalInstance, props: Props) => {\n  instance.props = props\n}\n\nexport const createProxyComponent = <T extends DefineComponent>(component: T) => {\n  const customSetup = (originalProps: Props, ctx: SetupContext) => {\n    const instance = getCurrentInstance()! // Not null during setup call\n    const propsFromConfig = useComponentConfigProps(component)\n\n    const props = createPropsWithCustomConfig(instance, propsFromConfig)\n\n    patchInstanceProps(instance, props)\n\n    return component.setup?.(shallowReadonly(props), ctx)\n  }\n\n  return new Proxy(component, {\n    get (target, key: any) {\n      if (key === 'setup') { return customSetup }\n\n      return target[key]\n    },\n  })\n}\n"],"names":["createProxyComponent","component","customSetup","originalProps","ctx","instance","getCurrentInstance","props","propsFromConfig","instanceProps","Proxy","get","target","key","incommingProps","vnode","originalProp","propFromConfig","value","createPropsWithCustomConfig","useComponentConfigProps","patchInstanceProps","_a","setup","call","shallowReadonly"],"mappings":"2HAYA,MA0CaA,qBAAmDC,IACxD,MAAAC,YAAc,CAACC,EAAsBC,WACzC,MAAMC,EAAWC,IAGXC,EA/C0B,EAACF,EAAqCG,KAKxE,MAAMC,EAAuBJ,EAASE,MAE/B,OAAA,IAAIG,MAAMD,EAAe,CAC9BE,IAAK,CAACC,EAAQC,KAKZ,MAAMC,EAA2BT,EAASU,MAAMR,OAAS,GAQnDS,EAAeJ,EAAOC,GACtBI,EAAiBT,EAAgBU,MAAML,GAG7C,YAA4B,IAAxBC,EAAeD,SAAyC,IAAnBI,EAChCA,EAGFD,MAkBKG,CAA4Bd,EAFlBe,EAAwBnB,IAMhD,MAbuB,EAACI,EAAqCE,KAC/DF,EAASE,MAAQA,GAUfc,CAAmBhB,EAAUE,GAEtB,OAAUe,EAAArB,EAAAsB,YAAQ,EAAAD,EAAAE,KAAAvB,EAAAwB,EAAgBlB,GAAQH,IAG5C,OAAA,IAAIM,MAAMT,EAAW,CAC1BU,IAAA,CAAKC,EAAQC,IACC,UAARA,EAA0BX,YAEvBU,EAAOC"}