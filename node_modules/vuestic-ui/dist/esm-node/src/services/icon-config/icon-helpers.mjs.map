{"version":3,"file":"icon-helpers.mjs","sources":["../../../../../src/services/icon-config/icon-helpers.ts"],"sourcesContent":["import merge from 'lodash/merge.js'\nimport { isMatchDynamicSegments, dynamicSegments } from './utils/dynamic-segment'\nimport { isMatchRegex, regexGroupsValues } from './utils/regex'\nimport {\n  IconConfig,\n  IconConfiguration,\n  IconConfigurationString,\n  IconConfigurationRegex,\n  isIconConfigurationString,\n  isIconConfigurationRegex,\n  IconProps,\n} from './types'\n\nconst isMatchConfiguration = (iconName: string, iconConfiguration: IconConfiguration) => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return isMatchDynamicSegments(iconName, iconConfiguration.name)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return isMatchRegex(iconName, iconConfiguration.name)\n  }\n\n  return false\n}\n\nconst resolveIconConfigurationString = (iconName: string, iconConfiguration: IconConfigurationString) => {\n  const args = dynamicSegments(iconName, iconConfiguration.name)\n  return iconConfiguration.resolve && iconConfiguration.resolve(args)\n}\n\nconst resolveIconConfigurationRegex = (iconName: string, iconConfig: IconConfigurationRegex) => {\n  if (iconConfig.name.global) {\n    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`)\n  }\n  const args = regexGroupsValues(iconName, iconConfig.name) as string[]\n  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args)\n}\n\nconst resolveIconConfiguration = (iconName: string, iconConfiguration: IconConfiguration): IconProps | undefined => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return resolveIconConfigurationString(iconName, iconConfiguration)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return resolveIconConfigurationRegex(iconName, iconConfiguration)\n  }\n\n  throw Error('Unknown icon config')\n}\n\nconst findMatchedIconConfiguration = (iconName: string, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration => {\n  const matchedConfig = globalIconConfig.find((config) => {\n    if (namesToIgnore.includes(config.name.toString())) { return false }\n\n    return isMatchConfiguration(iconName, config)\n  })\n\n  if (!matchedConfig) { throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`) }\n\n  return matchedConfig\n}\n\nconst findIconConfiguration = (iconName: string | undefined, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration | undefined => {\n  if (!iconName) { return }\n\n  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore)\n  const resolvedIconConfiguration = merge(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration)\n\n  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()]\n\n  return merge(\n    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),\n    resolvedIconConfiguration,\n  )\n}\n\n/** Removes name, to, resolveFromRegex and resolve from IconConfiguration */\nconst iconPropsFromIconConfiguration = (iconConfiguration: IconConfiguration): IconProps => {\n  const junkKeys = ['name', 'to', 'resolve', 'resolveFromRegex']\n\n  const configuration: Record<string, string> = iconConfiguration as any\n  junkKeys.forEach((key) => { delete configuration[key] })\n  return configuration\n}\n\nexport const getIconConfiguration = (name: string, iconConfig: IconConfig): IconProps => {\n  const configuration = findIconConfiguration(name, iconConfig)\n\n  if (configuration === undefined) { return {} }\n\n  return iconPropsFromIconConfiguration(configuration)\n}\n"],"names":["resolveIconConfiguration","iconName","iconConfiguration","isIconConfigurationString","args","dynamicSegments","name","resolve","resolveIconConfigurationString","isIconConfigurationRegex","iconConfig","global","Error","regexGroupsValues","resolveFromRegex","resolveIconConfigurationRegex","findMatchedIconConfiguration","globalIconConfig","namesToIgnore","matchedConfig","find","config","includes","toString","isMatchDynamicSegments","isMatchRegex","isMatchConfiguration","findIconConfiguration","matchedIconConfiguration","resolvedIconConfiguration","merge","to","getIconConfiguration","configuration","forEach","key","iconPropsFromIconConfiguration"],"mappings":"8KAaA,MAwBMA,yBAA2B,CAACC,EAAkBC,KAC9C,GAAAC,EAA0BD,GACrB,MAf4B,EAACD,EAAkBC,KACxD,MAAME,EAAOC,EAAgBJ,EAAUC,EAAkBI,MACzD,OAAOJ,EAAkBK,SAAWL,EAAkBK,QAAQH,IAarDI,CAA+BP,EAAUC,GAE9C,GAAAO,EAAyBP,GACpB,MAb2B,EAACD,EAAkBS,KACnD,GAAAA,EAAWJ,KAAKK,OAClB,MAAM,IAAIC,MAAM,6BAA6BF,EAAWJ,iDAE1D,MAAMF,EAAOS,EAAkBZ,EAAUS,EAAWJ,MACpD,OAAOI,EAAWI,kBAAoBJ,EAAWI,oBAAoBV,IAQ5DW,CAA8Bd,EAAUC,GAGjD,MAAMU,MAAM,wBAGRI,6BAA+B,CAACf,EAAkBgB,EAA8BC,EAA0B,MAC9G,MAAMC,EAAgBF,EAAiBG,MAAMC,IACvCH,EAAcI,SAASD,EAAOf,KAAKiB,aArCd,EAACtB,EAAkBC,IAC1CC,EAA0BD,GACrBsB,EAAuBvB,EAAUC,EAAkBI,QAExDG,EAAyBP,IACpBuB,EAAaxB,EAAUC,EAAkBI,MAkCzCoB,CAAqBzB,EAAUoB,KAGxC,IAAKF,EAAuB,MAAA,IAAIP,MAAM,iCAAiCX,qCAEhE,OAAAkB,GAGHQ,sBAAwB,CAAC1B,EAA8BgB,EAA8BC,EAA0B,MACnH,IAAKjB,EAAY,OAEjB,MAAM2B,EAA2BZ,6BAA6Bf,EAAUgB,EAAkBC,GACpFW,EAA4BC,EAAM9B,yBAAyBC,EAAU2B,GAA2BA,GAItG,OAFAV,EAAgB,IAAIA,EAAeU,EAAyBtB,KAAKiB,YAE1DO,EACLH,sBAAsBE,EAA0BE,GAAId,EAAkBC,GACtEW,IAaSG,qBAAuB,CAAC1B,EAAcI,KAC3C,MAAAuB,EAAgBN,sBAAsBrB,EAAMI,GAElD,YAAsB,IAAlBuB,EAAsC,GAXL,CAAC/B,IACtC,MAEM+B,EAAwC/B,EAEvC,MAJU,CAAC,OAAQ,KAAM,UAAW,oBAGlCgC,SAASC,WAAiBF,EAAcE,MAC1CF,GAQAG,CAA+BH"}